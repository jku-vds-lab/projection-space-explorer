{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///../src/utils.js","webpack:///../node_modules/rollup-plugin-node-builtins/src/es6/events.js","webpack:///../node_modules/obliterator/iterator.js","webpack:///../node_modules/obliterator/take.js","webpack:///../src/errors.js","webpack:///../src/data.js","webpack:///../src/indices.js","webpack:///../src/attributes.js","webpack:///../node_modules/obliterator/chain.js","webpack:///../src/iteration/edges.js","webpack:///../src/iteration/neighbors.js","webpack:///../src/serialization.js","webpack:///../src/graph.js","webpack:///../src/classes.js","webpack:///./src/components/workers/worker_force.ts"],"names":["assign","target","arguments","i","l","length","k","getMatchingEdge","graph","source","type","sourceData","_nodes","get","edge","out","undirected","isGraph","value","_typeof","addUndirectedEdgeWithKey","dropNode","isPlainObject","constructor","Object","prettyPrint","integer","string","prettyString","privateProperty","name","defineProperty","enumerable","configurable","writable","readOnlyProperty","descriptor","EventHandlers","EventEmitter","init","call","this","$getMaxListeners","that","undefined","_maxListeners","defaultMaxListeners","emitNone","handler","isFn","self","len","listeners","arrayClone","emitOne","arg1","emitTwo","arg2","emitThree","arg3","emitMany","args","apply","_addListener","listener","prepend","m","events","existing","e","TypeError","_events","newListener","emit","_eventsCount","unshift","push","warned","w","Error","emitter","count","console","warn","log","_onceWrap","fired","g","removeListener","listenerCount","evlistener","arr","copy","Array","Iterator","next","done","prototype","create","usingDomains","domain","active","getPrototypeOf","setMaxListeners","n","isNaN","getMaxListeners","er","doError","error","err","context","domainEmitter","domainThrown","addListener","on","prependListener","once","prependOnceListener","list","position","originalListener","index","pop","spliceOne","removeAllListeners","key","keys","ret","unwrapListeners","eventNames","Reflect","ownKeys","step","_next","Symbol","iterator","of","empty","is","Infinity","array","slice","GraphError","message","data","InvalidArgumentsGraphError","captureStackTrace","NotFoundGraphError","UsageGraphError","MixedNodeData","attributes","inDegree","outDegree","undirectedDegree","directedSelfLoops","undirectedSelfLoops","DirectedNodeData","UndirectedNodeData","DirectedEdgeData","generatedKey","UndirectedEdgeData","updateStructureIndex","edgeData","targetData","multi","outKey","inKey","edgeOrSet","Set","add","clearEdgeFromStructureIndex","sourceIndex","set","size","upgradeToMixed","ATTRIBUTES_METHODS","element","attacher","Class","method","EdgeDataClass","_edges","hasOwnProperty","meta","updater","oldAttributes","before","after","current","iterators","iterate","EDGES_ITERATION","direction","collect","edges","object","forEach","forEachSimple","callback","forEachMulti","createIterator","inner","values","collectForKey","forEachForKey","createIteratorForKey","v","createEdgeArray","take","undirectedSize","directedSize","mask","forEachEdge","createEdgeIterator","createEdgeArrayForNode","nodeData","forEachEdgeForNode","fn","createEdgeIteratorForNode","chain","createEdgeArrayForPath","forEachEdgeForPath","createEdgeIteratorForPath","NEIGHBORS_ITERATION","merge","neighbors","neighbor","createNeighborArrayForNode","forEachInObject","neighborData","forEachInObjectOnce","visited","has","createObjectIterator","createDedupedObjectIterator","nodeHasNeighbor","node","attachForEachNeighbor","description","forEachName","toUpperCase","forEachNeighborForNode","attachNeighborIteratorCreator","iteratorName","createNeighborIterator","serializeNode","serialized","serializeEdge","validateSerializedNode","validateSerializedEdge","TYPES","EMITTER_PROPS","DEFAULTS","allowSelfLoops","edgeKeyGenerator","addEdge","mustGenerateKey","eventData","_edgeKeyGenerator","_undirectedSize","_directedSize","mergeEdge","alreadyExistingEdgeData","alreadyExistingEdge","addNode","Graph","options","NodeDataClass","Map","prop","_this","_options","hasNode","hasDirectedEdge","hasUndirectedEdge","hasEdge","directedEdge","undirectedEdge","selfLoops","loops","directedDegree","degree","extremities","opposite","directed","selfLoop","mergeNode","dropEdge","clear","clearEdges","clearIndex","getAttribute","_attributes","getAttributes","hasAttribute","setAttribute","updateAttribute","removeAttribute","replaceAttributes","mergeAttributes","getNodeAttribute","getNodeAttributes","hasNodeAttribute","setNodeAttribute","updateNodeAttribute","removeNodeAttribute","replaceNodeAttributes","mergeNodeAttributes","adjacency","nodes","forEachNode","nodeEntries","exportNode","exportEdge","importNode","importEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdgeWithKey","addDirectedEdgeWithKey","mergeUndirectedEdge","mergeDirectedEdge","addUndirectedEdge","addDirectedEdge","_this2","nullCopy","emptyCopy","upgradeToMulti","toJSON","toString","pluralOrder","order","pluralSize","inspect","multiIndex","label","desc","_this3","dummy","verb","generateKey","attachAttributesMethods","attachEdgeArrayCreator","attachForEachEdge","originalName","attachEdgeIteratorCreator","attachEdgeIterationMethods","node1","node2","attachNeighborArrayCreator","attachNeighborIterationMethods","DirectedGraph","_Graph","UndirectedGraph","_Graph2","MultiGraph","_Graph3","MultiDirectedGraph","_Graph4","MultiUndirectedGraph","_Graph5","attachStaticFromMethod","from","instance","exports","require","NODE_X","NODE_Y","NODE_DX","NODE_DY","NODE_OLD_DX","NODE_OLD_DY","NODE_MASS","NODE_CONVERGENCE","NODE_SIZE","NODE_FIXED","EDGE_SOURCE","EDGE_TARGET","EDGE_WEIGHT","REGION_NODE","REGION_CENTER_X","REGION_CENTER_Y","REGION_SIZE","REGION_NEXT_SIBLING","REGION_FIRST_CHILD","REGION_MASS","REGION_MASS_CENTER_X","REGION_MASS_CENTER_Y","SUBDIVISION_ATTEMPTS","PPN","PPE","PPR","MAX_FORCE","NodeMatrix","EdgeMatrix","r","n1","n2","rn","s","adjustSizes","thetaSquared","barnesHutTheta","outboundAttCompensation","coefficient","xDist","yDist","ewc","distance","factor","RegionMatrix","outboundAttractionDistribution","barnesHutOptimize","minX","maxX","minY","maxY","q","q2","subdivisionAttempts","Math","min","max","dx","dy","scalingRatio","pow","sqrt","gravity","strongGravityMode","edgeWeightInfluence","linLogMode","force","swinging","traction","nodespeed","newX","newY","slowDown","validateSettings","settings","graphToByteArrays","j","Float32Array","getEdgeAttribute","assignLayoutChanges","collectLayoutChanges","positions","x","y","assignH","objects","DEFAULT_SETTINGS","abstractSynchronousLayout","params","iterations","validationError","matrices","addEventListener","meshIndex","destination","postMessage","progress","res"],"mappings":"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","file":"force.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/components/workers/worker_force.ts\");\n","/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexport function assign() {\n  const target = arguments[0] || {};\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i])\n      continue;\n\n    for (const k in arguments[i])\n      target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nexport function getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData)\n    return edge;\n\n  if (type === 'mixed') {\n    edge = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target])\n    );\n  }\n  else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  }\n  else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a Graph implementation instance.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isGraph(value) {\n  return (\n    value !== null &&\n    typeof value === 'object' &&\n    typeof value.addUndirectedEdgeWithKey === 'function' &&\n    typeof value.dropNode === 'function'\n  );\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nexport function isPlainObject(value) {\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    value.constructor === Object\n  );\n}\n\n/**\n * Pretty prints the given integer.\n *\n * @param  {number}  integer - Target integer.\n * @return {string}          - The pretty string.\n */\nexport function prettyPrint(integer) {\n  const string = '' + integer;\n\n  let prettyString = '';\n\n  for (let i = 0, l = string.length; i < l; i++) {\n    const j = l - i - 1;\n\n    prettyString = string[j] + prettyString;\n\n    if (!((i - 2) % 3) && i !== l - 1)\n      prettyString = ',' + prettyString;\n  }\n\n  return prettyString;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nexport function privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nexport function readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  }\n  else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nexport function incrementalId() {\n  let i = 0;\n\n  return () => {\n    return `_geid${i++}_`;\n  };\n}\n","'use strict';\n\nvar domain;\n\n// This constructor is used to store event handlers. Instantiating this is\n// faster than explicitly calling `Object.create(null)` to get a \"clean\" empty\n// object (tested with v8 v4.9).\nfunction EventHandlers() {}\nEventHandlers.prototype = Object.create(null);\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nexport default EventEmitter;\nexport {EventEmitter};\n\n// nodejs oddity\n// require('events') === require('events').EventEmitter\nEventEmitter.EventEmitter = EventEmitter\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.prototype.domain = undefined;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\nEventEmitter.init = function() {\n  this.domain = null;\n  if (EventEmitter.usingDomains) {\n    // if there is an active domain, then attach to it.\n    if (domain.active && !(this instanceof domain.Domain)) {\n      this.domain = domain.active;\n    }\n  }\n\n  if (!this._events || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = new EventHandlers();\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || isNaN(n))\n    throw new TypeError('\"n\" argument must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\n// These standalone emit* functions are used to optimize calling of event\n// handlers for fast cases because emit() itself often has a variable number of\n// arguments and can be deoptimized because of that. These functions always have\n// the same number of arguments and thus do not get deoptimized, so the code\n// inside them can execute faster.\nfunction emitNone(handler, isFn, self) {\n  if (isFn)\n    handler.call(self);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self);\n  }\n}\nfunction emitOne(handler, isFn, self, arg1) {\n  if (isFn)\n    handler.call(self, arg1);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1);\n  }\n}\nfunction emitTwo(handler, isFn, self, arg1, arg2) {\n  if (isFn)\n    handler.call(self, arg1, arg2);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2);\n  }\n}\nfunction emitThree(handler, isFn, self, arg1, arg2, arg3) {\n  if (isFn)\n    handler.call(self, arg1, arg2, arg3);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].call(self, arg1, arg2, arg3);\n  }\n}\n\nfunction emitMany(handler, isFn, self, args) {\n  if (isFn)\n    handler.apply(self, args);\n  else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      listeners[i].apply(self, args);\n  }\n}\n\nEventEmitter.prototype.emit = function emit(type) {\n  var er, handler, len, args, i, events, domain;\n  var needDomainExit = false;\n  var doError = (type === 'error');\n\n  events = this._events;\n  if (events)\n    doError = (doError && events.error == null);\n  else if (!doError)\n    return false;\n\n  domain = this.domain;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    er = arguments[1];\n    if (domain) {\n      if (!er)\n        er = new Error('Uncaught, unspecified \"error\" event');\n      er.domainEmitter = this;\n      er.domain = domain;\n      er.domainThrown = false;\n      domain.emit('error', er);\n    } else if (er instanceof Error) {\n      throw er; // Unhandled 'error' event\n    } else {\n      // At least give some kind of context to the user\n      var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n      err.context = er;\n      throw err;\n    }\n    return false;\n  }\n\n  handler = events[type];\n\n  if (!handler)\n    return false;\n\n  var isFn = typeof handler === 'function';\n  len = arguments.length;\n  switch (len) {\n    // fast cases\n    case 1:\n      emitNone(handler, isFn, this);\n      break;\n    case 2:\n      emitOne(handler, isFn, this, arguments[1]);\n      break;\n    case 3:\n      emitTwo(handler, isFn, this, arguments[1], arguments[2]);\n      break;\n    case 4:\n      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);\n      break;\n    // slower\n    default:\n      args = new Array(len - 1);\n      for (i = 1; i < len; i++)\n        args[i - 1] = arguments[i];\n      emitMany(handler, isFn, this, args);\n  }\n\n  if (needDomainExit)\n    domain.exit();\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n\n  events = target._events;\n  if (!events) {\n    events = target._events = new EventHandlers();\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (!existing) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] :\n                                          [existing, listener];\n    } else {\n      // If we've already got an array, just append.\n      if (prepend) {\n        existing.unshift(listener);\n      } else {\n        existing.push(listener);\n      }\n    }\n\n    // Check for listener leak\n    if (!existing.warned) {\n      m = $getMaxListeners(target);\n      if (m && m > 0 && existing.length > m) {\n        existing.warned = true;\n        var w = new Error('Possible EventEmitter memory leak detected. ' +\n                            existing.length + ' ' + type + ' listeners added. ' +\n                            'Use emitter.setMaxListeners() to increase limit');\n        w.name = 'MaxListenersExceededWarning';\n        w.emitter = target;\n        w.type = type;\n        w.count = existing.length;\n        emitWarning(w);\n      }\n    }\n  }\n\n  return target;\n}\nfunction emitWarning(e) {\n  typeof console.warn === 'function' ? console.warn(e) : console.log(e);\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction _onceWrap(target, type, listener) {\n  var fired = false;\n  function g() {\n    target.removeListener(type, g);\n    if (!fired) {\n      fired = true;\n      listener.apply(target, arguments);\n    }\n  }\n  g.listener = listener;\n  return g;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function')\n    throw new TypeError('\"listener\" argument must be a function');\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function')\n        throw new TypeError('\"listener\" argument must be a function');\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      list = events[type];\n      if (!list)\n        return this;\n\n      if (list === listener || (list.listener && list.listener === listener)) {\n        if (--this._eventsCount === 0)\n          this._events = new EventHandlers();\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length; i-- > 0;) {\n          if (list[i] === listener ||\n              (list[i].listener && list[i].listener === listener)) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (list.length === 1) {\n          list[0] = undefined;\n          if (--this._eventsCount === 0) {\n            this._events = new EventHandlers();\n            return this;\n          } else {\n            delete events[type];\n          }\n        } else {\n          spliceOne(list, position);\n        }\n\n        if (events.removeListener)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events;\n\n      events = this._events;\n      if (!events)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (!events.removeListener) {\n        if (arguments.length === 0) {\n          this._events = new EventHandlers();\n          this._eventsCount = 0;\n        } else if (events[type]) {\n          if (--this._eventsCount === 0)\n            this._events = new EventHandlers();\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        for (var i = 0, key; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = new EventHandlers();\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners) {\n        // LIFO order\n        do {\n          this.removeListener(type, listeners[listeners.length - 1]);\n        } while (listeners[0]);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  var evlistener;\n  var ret;\n  var events = this._events;\n\n  if (!events)\n    ret = [];\n  else {\n    evlistener = events[type];\n    if (!evlistener)\n      ret = [];\n    else if (typeof evlistener === 'function')\n      ret = [evlistener.listener || evlistener];\n    else\n      ret = unwrapListeners(evlistener);\n  }\n\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n  for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)\n    list[i] = list[k];\n  list.pop();\n}\n\nfunction arrayClone(arr, i) {\n  var copy = new Array(i);\n  while (i--)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","/**\n * Obliterator Iterator Class\n * ===========================\n *\n * Simple class representing the library's iterators.\n */\n\n/**\n * Iterator class.\n *\n * @constructor\n * @param {function} next - Next function.\n */\nfunction Iterator(next) {\n\n  // Hiding the given function\n  Object.defineProperty(this, '_next', {\n    writable: false,\n    enumerable: false,\n    value: next\n  });\n\n  // Is the iterator complete?\n  this.done = false;\n}\n\n/**\n * Next function.\n *\n * @return {object}\n */\n// NOTE: maybe this should dropped for performance?\nIterator.prototype.next = function() {\n  if (this.done)\n    return {done: true};\n\n  var step = this._next();\n\n  if (step.done)\n    this.done = true;\n\n  return step;\n};\n\n/**\n * If symbols are supported, we add `next` to `Symbol.iterator`.\n */\nif (typeof Symbol !== 'undefined')\n  Iterator.prototype[Symbol.iterator] = function() {\n    return this;\n  };\n\n/**\n * Returning an iterator of the given values.\n *\n * @param  {any...} values - Values.\n * @return {Iterator}\n */\nIterator.of = function() {\n  var args = arguments,\n      l = args.length,\n      i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    return {done: false, value: args[i++]};\n  });\n};\n\n/**\n * Returning an empty iterator.\n *\n * @return {Iterator}\n */\nIterator.empty = function() {\n  var iterator = new Iterator(null);\n  iterator.done = true;\n\n  return iterator;\n};\n\n/**\n * Returning whether the given value is an iterator.\n *\n * @param  {any} value - Value.\n * @return {boolean}\n */\nIterator.is = function(value) {\n  if (value instanceof Iterator)\n    return true;\n\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    typeof value.next === 'function'\n  );\n};\n\n/**\n * Exporting.\n */\nmodule.exports = Iterator;\n","/* eslint no-constant-condition: 0 */\n/**\n * Obliterator Take Function\n * ==========================\n *\n * Function taking n or every value of the given iterator and returns them\n * into an array.\n */\n\n/**\n * Take.\n *\n * @param  {Iterator} iterator - Target iterator.\n * @param  {number}   [n]      - Optional number of items to take.\n * @return {array}\n */\nmodule.exports = function take(iterator, n) {\n  var l = arguments.length > 1 ? n : Infinity,\n      array = l !== Infinity ? new Array(l) : [],\n      step,\n      i = 0;\n\n  while (true) {\n\n    if (i === l)\n      return array;\n\n    step = iterator.next();\n\n    if (step.done) {\n\n      if (i !== n)\n        return array.slice(0, i);\n\n      return array;\n    }\n\n    array[i++] = step.value;\n  }\n};\n","/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nexport class GraphError extends Error {\n  constructor(message, data) {\n    super();\n    this.name = 'GraphError';\n    this.message = message || '';\n    this.data = data || {};\n  }\n}\n\nexport class InvalidArgumentsGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, InvalidArgumentsGraphError.prototype.constructor);\n  }\n}\n\nexport class NotFoundGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nexport class UsageGraphError extends GraphError {\n  constructor(message, data) {\n    super(message, data);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n","/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function MixedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.directedSelfLoops = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n}\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function DirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes || {};\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n}\n\nDirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nexport function UndirectedNodeData(key, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes || {};\n\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedSelfLoops = 0;\n\n  // Indices\n  this.undirected = {};\n}\n\nUndirectedNodeData.prototype.upgradeToMixed = function() {\n\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedSelfLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * DirectedEdgeData class.\n *\n * @constructor\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function DirectedEdgeData(key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n\n/**\n * UndirectedEdgeData class.\n *\n * @constructor\n * @param {string}  string       - The edge's key.\n * @param {boolean} generatedKey - Was its key generated?\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nexport function UndirectedEdgeData(key, generatedKey, source, target, attributes) {\n\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n\n  // Was its key generated?\n  this.generatedKey = generatedKey;\n}\n","/**\n * Graphology Indexes Functions\n * =============================\n *\n * Bunch of functions used to compute or clear indexes.\n */\n\n/**\n * Function updating the 'structure' index with the given edge's data.\n * Note that in the case of the multi graph, related edges are stored in a\n * set that is the same for A -> B & B <- A.\n *\n * @param {Graph}    graph      - Target Graph instance.\n * @param {EdgeData} edgeData   - Added edge's data.\n * @param {NodeData} sourceData - Source node's data.\n * @param {NodeData} targetData - Target node's data.\n */\nexport function updateStructureIndex(\n  graph,\n  undirected,\n  edgeData,\n  source,\n  target,\n  sourceData,\n  targetData\n) {\n  const multi = graph.multi;\n\n  const outKey = undirected ? 'undirected' : 'out',\n        inKey = undirected ? 'undirected' : 'in';\n\n  // Handling source\n  let edgeOrSet = sourceData[outKey][target];\n\n  if (typeof edgeOrSet === 'undefined') {\n    edgeOrSet = multi ? new Set() : edgeData;\n    sourceData[outKey][target] = edgeOrSet;\n  }\n\n  if (multi)\n    edgeOrSet.add(edgeData);\n\n  // If selfLoop, we break here\n  if (source === target)\n    return;\n\n  // Handling target (we won't add the edge because it was already taken\n  // care of with source above)\n  if (typeof targetData[inKey][source] === 'undefined')\n    targetData[inKey][source] = edgeOrSet;\n}\n\n/**\n * Function clearing the 'structure' index data related to the given edge.\n *\n * @param {Graph}    graph    - Target Graph instance.\n * @param {EdgeData} edgeData - Dropped edge's data.\n */\nexport function clearEdgeFromStructureIndex(graph, undirected, edgeData) {\n  const multi = graph.multi;\n\n  const {source: sourceData, target: targetData} = edgeData;\n\n  const source = sourceData.key,\n        target = targetData.key;\n\n  // NOTE: since the edge set is the same for source & target, we can only\n  // affect source\n  const outKey = undirected ? 'undirected' : 'out',\n        sourceIndex = sourceData[outKey];\n\n  const inKey = undirected ? 'undirected' : 'in';\n\n  if (target in sourceIndex) {\n\n    if (multi) {\n      const set = sourceIndex[target];\n\n      if (set.size === 1) {\n        delete sourceIndex[target];\n        delete targetData[inKey][source];\n      }\n      else {\n        set.delete(edgeData);\n      }\n    }\n    else\n      delete sourceIndex[target];\n  }\n\n  if (multi)\n    return;\n\n  const targetIndex = targetData[inKey];\n\n  delete targetIndex[source];\n}\n\n/**\n * Function clearing the whole 'structure' index.\n *\n * @param {Graph} graph - Target Graph instance.\n */\nexport function clearStructureIndex(graph) {\n  graph._nodes.forEach(data => {\n\n    // Clearing now useless properties\n    if (typeof data.in !== 'undefined') {\n      data.in = {};\n      data.out = {};\n    }\n\n    if (typeof data.undirected !== 'undefined') {\n      data.undirected = {};\n    }\n  });\n}\n\n/**\n * Function used to upgrade a simple `structure` index to a multi on.\n *\n * @param {Graph}  graph - Target Graph instance.\n */\nexport function upgradeStructureIndexToMulti(graph) {\n  graph._nodes.forEach((data, node) => {\n\n    // Directed\n    if (data.out) {\n\n      for (const neighbor in data.out) {\n        const edges = new Set();\n        edges.add(data.out[neighbor]);\n        data.out[neighbor] = edges;\n        graph._nodes.get(neighbor).in[node] = edges;\n      }\n    }\n\n    // Undirected\n    if (data.undirected) {\n      for (const neighbor in data.undirected) {\n        if (neighbor > node)\n          continue;\n\n        const edges = new Set();\n        edges.add(data.undirected[neighbor]);\n        data.undirected[neighbor] = edges;\n        graph._nodes.get(neighbor).undirected[node] = edges;\n      }\n    }\n  });\n}\n","/**\n * Graphology Attributes methods\n * ==============================\n *\n * Attributes-related methods being exactly the same for nodes & edges,\n * we abstract them here for factorization reasons.\n */\nimport {\n  assign,\n  isPlainObject,\n  getMatchingEdge\n} from './utils';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  DirectedEdgeData,\n  UndirectedEdgeData\n} from './data';\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeGetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesGetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 1) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeChecker(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeSetter(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeUpdater(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 3) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.${method}: updater should be a function.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      meta: {\n        name,\n        value: data.attributes[name]\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributeRemover(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesReplacer(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    const oldAttributes = data.attributes;\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      meta: {\n        before: oldAttributes,\n        after: attributes\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n * @param {Class}    EdgeDataClass - Class of the edges to filter.\n */\nfunction attachAttributesMerger(Class, method, type, EdgeDataClass) {\n\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function(element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(`Graph.${method}: cannot find this type of edges in your ${this.type} graph.`);\n\n    if (arguments.length > 2) {\n\n      if (this.multi)\n        throw new UsageGraphError(`Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);\n\n      const source = '' + element,\n            target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`);\n    }\n    else {\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" edge in the graph.`);\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.${method}: provided attributes are not a plain object.`);\n\n    if (type !== 'mixed' && !(data instanceof EdgeDataClass))\n      throw new NotFoundGraphError(`Graph.${method}: could not find the \"${element}\" ${type} edge in the graph.`);\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      meta: {\n        data: attributes\n      }\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachAttributesMerger\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nexport function attachAttributesMethods(Graph) {\n  ATTRIBUTES_METHODS.forEach(function({name, attacher}) {\n\n    // For edges\n    attacher(\n      Graph,\n      name('Edge'),\n      'mixed',\n      DirectedEdgeData\n    );\n\n    // For directed edges\n    attacher(\n      Graph,\n      name('DirectedEdge'),\n      'directed',\n      DirectedEdgeData\n    );\n\n    // For undirected edges\n    attacher(\n      Graph,\n      name('UndirectedEdge'),\n      'undirected',\n      UndirectedEdgeData\n    );\n  });\n}\n","/**\n * Obliterator Chain Function\n * ===========================\n *\n * Variadic function combining the given iterators.\n */\nvar Iterator = require('./iterator.js');\n\n/**\n * Chain.\n *\n * @param  {...Iterator} iterators - Target iterators.\n * @return {Iterator}\n */\nmodule.exports = function chain() {\n  var iterators = arguments,\n      current,\n      i = -1;\n\n  return new Iterator(function iterate() {\n    if (!current) {\n      i++;\n\n      if (i >= iterators.length)\n        return {done: true};\n\n      current = iterators[i];\n    }\n\n    var step = current.next();\n\n    if (step.done) {\n      current = null;\n      return iterate();\n    }\n\n    return step;\n  });\n};\n","/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\nimport {UndirectedEdgeData} from '../data';\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function collecting edges from the given object.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @return {array}         - The found edges.\n */\nfunction collect(edges, object) {\n  for (const k in object) {\n    if (object[k] instanceof Set)\n      object[k].forEach(edgeData => edges.push(edgeData.key));\n    else\n      edges.push(object[k].key);\n  }\n}\n\n/**\n * Function iterating over edges from the given object using a callback.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    );\n  }\n}\n\nfunction forEachMulti(object, callback) {\n  for (const k in object) {\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    ));\n  }\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let inner = null,\n      i = 0;\n\n  return new Iterator(function next() {\n    let edgeData;\n\n    if (inner) {\n      const step = inner.next();\n\n      if (step.done) {\n        inner = null;\n        i++;\n        return next();\n      }\n\n      edgeData = step.value;\n    }\n    else {\n      if (i >= l)\n        return {done: true};\n\n      const k = keys[i];\n\n      edgeData = object[k];\n\n      if (edgeData instanceof Set) {\n        inner = edgeData.values();\n        return next();\n      }\n\n      i++;\n    }\n\n    return {\n      done: false,\n      value: [\n        edgeData.key,\n        edgeData.attributes,\n        edgeData.source.key,\n        edgeData.target.key,\n        edgeData.source.attributes,\n        edgeData.target.attributes\n      ]\n    };\n  });\n}\n\n/**\n * Function collecting edges from the given object at given key.\n *\n * @param  {array}  edges  - Edges array to populate.\n * @param  {object} object - Target object.\n * @param  {mixed}  k      - Neighbor key.\n * @return {array}         - The found edges.\n */\nfunction collectForKey(edges, object, k) {\n\n  if (!(k in object))\n    return;\n\n  if (object[k] instanceof Set)\n    object[k].forEach(edgeData => edges.push(edgeData.key));\n  else\n    edges.push(object[k].key);\n\n  return;\n}\n\n/**\n * Function iterating over the egdes from the object at given key using\n * a callback.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKey(object, k, callback) {\n\n  if (!(k in object))\n    return;\n\n  if (object[k] instanceof Set)\n    object[k].forEach(edgeData => callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    ));\n  else {\n    const edgeData = object[k];\n\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes\n    );\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  const v = object[k];\n\n  if (v instanceof Set) {\n    const iterator = v.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      return {\n        done: false,\n        value: [\n          edgeData.key,\n          edgeData.attributes,\n          edgeData.source.key,\n          edgeData.target.key,\n          edgeData.source.attributes,\n          edgeData.target.attributes\n        ]\n      };\n    });\n  }\n\n  return Iterator.of([\n    v.key,\n    v.attributes,\n    v.source.key,\n    v.target.key,\n    v.source.attributes,\n    v.target.attributes\n  ]);\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0)\n    return [];\n\n  if (type === 'mixed' || type === graph.type)\n    return take(graph._edges.keys(), graph._edges.size);\n\n  const size = type === 'undirected' ?\n    graph.undirectedSize :\n    graph.directedSize;\n\n  const list = new Array(size),\n        mask = type === 'undirected';\n\n  let i = 0;\n\n  graph._edges.forEach((data, edge) => {\n\n    if ((data instanceof UndirectedEdgeData) === mask)\n      list[i++] = edge;\n  });\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(graph, type, callback) {\n  if (graph.size === 0)\n    return;\n\n  if (type === 'mixed' || type === graph.type) {\n    graph._edges.forEach((data, key) => {\n\n      const {attributes, source, target} = data;\n\n      callback(\n        key,\n        attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes\n      );\n    });\n  }\n  else {\n    const mask = type === 'undirected';\n\n    graph._edges.forEach((data, key) => {\n      if ((data instanceof UndirectedEdgeData) === mask) {\n\n        const {attributes, source, target} = data;\n\n        callback(\n          key,\n          attributes,\n          source.key,\n          target.key,\n          source.attributes,\n          target.attributes\n        );\n      }\n    });\n  }\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0)\n    return Iterator.empty();\n\n  let iterator;\n\n  if (type === 'mixed') {\n    iterator = graph._edges.values();\n\n    return new Iterator(function next() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      const value = [\n        data.key,\n        data.attributes,\n        data.source.key,\n        data.target.key,\n        data.source.attributes,\n        data.target.attributes\n      ];\n\n      return {value, done: false};\n    });\n  }\n\n  iterator = graph._edges.values();\n\n  return new Iterator(function next() {\n    const step = iterator.next();\n\n    if (step.done)\n      return step;\n\n    const data = step.value;\n\n    if ((data instanceof UndirectedEdgeData) === (type === 'undirected')) {\n      const value = [\n        data.key,\n        data.attributes,\n        data.source.key,\n        data.target.key,\n        data.source.attributes,\n        data.target.attributes\n      ];\n\n      return {value, done: false};\n    }\n\n    return next();\n  });\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(type, direction, nodeData) {\n  const edges = [];\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      collect(edges, nodeData.in);\n    if (direction !== 'in')\n      collect(edges, nodeData.out);\n  }\n\n  if (type !== 'directed') {\n    collect(edges, nodeData.undirected);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(multi, type, direction, nodeData, callback) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out')\n      fn(nodeData.in, callback);\n    if (direction !== 'in')\n      fn(nodeData.out, callback);\n  }\n\n  if (type !== 'directed') {\n    fn(nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.out));\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, direction, sourceData, target) {\n  const edges = [];\n\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      collectForKey(edges, sourceData.in, target);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      collectForKey(edges, sourceData.out, target);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      collectForKey(edges, sourceData.undirected, target);\n  }\n\n  return edges;\n}\n\n/**\n * Function iterating over edges for the given path using a callback.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(type, direction, sourceData, target, callback) {\n  if (type !== 'undirected') {\n\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out')\n      forEachForKey(sourceData.in, target, callback);\n\n    if (typeof sourceData.out !== 'undefined' && direction !== 'in')\n      forEachForKey(sourceData.out, target, callback);\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined')\n      forEachForKey(sourceData.undirected, target, callback);\n  }\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = Iterator.empty();\n\n  if (type !== 'undirected') {\n\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.undirected, target));\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length)\n      return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(source, target, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(type, direction, sourceData, target, callback);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nexport function attachEdgeIteratorCreator(Class, description) {\n  const {\n    name: originalName,\n    type,\n    direction\n  } = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(source, target) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    if (!arguments.length)\n      return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${source}\" node in the graph.`);\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${source}\" source node in the graph.`);\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(`Graph.${name}:  could not find the \"${target}\" target node in the graph.`);\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\nimport Iterator from 'obliterator/iterator';\nimport chain from 'obliterator/chain';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError\n} from '../errors';\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function merging neighbors into the given set iterating over the given object.\n *\n * @param {BasicSet} neighbors - Neighbors set.\n * @param {object}   object    - Target object.\n */\nfunction merge(neighbors, object) {\n  if (typeof object === 'undefined')\n    return;\n\n  for (const neighbor in object)\n    neighbors.add(neighbor);\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return Object.keys(nodeData[direction]);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const neighbors = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      merge(neighbors, nodeData.in);\n    }\n    if (direction !== 'in') {\n      merge(neighbors, nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    merge(neighbors, nodeData.undirected);\n  }\n\n  return take(neighbors.values(), neighbors.size);\n}\n\n/**\n * Function iterating over the given node's relevant neighbors using a\n * callback.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObject(nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachInObjectOnce(visited, nodeData, object, callback) {\n  for (const k in object) {\n    let edgeData = object[k];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      continue;\n\n    visited.add(neighborData.key);\n\n    callback(\n      neighborData.key,\n      neighborData.attributes\n    );\n  }\n}\n\nfunction forEachNeighborForNode(type, direction, nodeData, callback) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObject(nodeData, nodeData.undirected, callback);\n\n    if (typeof direction === 'string')\n      return forEachInObject(nodeData, nodeData[direction], callback);\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      forEachInObjectOnce(visited, nodeData, nodeData.in, callback);\n    }\n    if (direction !== 'in') {\n      forEachInObjectOnce(visited, nodeData, nodeData.out, callback);\n    }\n  }\n\n  if (type !== 'directed') {\n    forEachInObjectOnce(visited, nodeData, nodeData.undirected, callback);\n  }\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createObjectIterator(nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object),\n        l = keys.length;\n\n  let i = 0;\n\n  return new Iterator(function next() {\n    if (i >= l)\n      return {done: true};\n\n    let edgeData = object[keys[i++]];\n\n    if (edgeData instanceof Set)\n      edgeData = edgeData.values().next().value;\n\n    const sourceData = edgeData.source,\n          targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited.has(neighborData.key))\n      return next();\n\n    visited.add(neighborData.key);\n\n    return {\n      done: false,\n      value: [neighborData.key, neighborData.attributes]\n    };\n  });\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createObjectIterator(nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createObjectIterator(nodeData, nodeData[direction]);\n  }\n\n  let iterator = Iterator.empty();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  const visited = new Set();\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.in));\n    }\n    if (direction !== 'in') {\n      iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.out));\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(iterator, createDedupedObjectIterator(visited, nodeData, nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function returning whether the given node has target neighbor.\n *\n * @param  {Graph}        graph     - Target graph.\n * @param  {string}       type      - Type of neighbor.\n * @param  {string}       direction - Direction.\n * @param  {any}          node      - Target node.\n * @param  {any}          neighbor  - Target neighbor.\n * @return {boolean}\n */\nfunction nodeHasNeighbor(graph, type, direction, node, neighbor) {\n\n  const nodeData = graph._nodes.get(node);\n\n  if (type !== 'undirected') {\n\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined') {\n      for (const k in nodeData.in)\n        if (k === neighbor)\n          return true;\n    }\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined') {\n      for (const k in nodeData.out)\n        if (k === neighbor)\n          return true;\n    }\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    for (const k in nodeData.undirected)\n        if (k === neighbor)\n          return true;\n  }\n\n  return false;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  /**\n   * Function returning an array or the count of certain neighbors.\n   *\n   * Arity 1: Return all of a node's relevant neighbors.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return whether the two nodes are indeed neighbors.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The neighbors or the number of neighbors.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (arguments.length === 2) {\n      const node1 = '' + arguments[0],\n            node2 = '' + arguments[1];\n\n      if (!this._nodes.has(node1))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node1}\" node in the graph.`);\n\n      if (!this._nodes.has(node2))\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node2}\" node in the graph.`);\n\n      // Here, we want to assess whether the two given nodes are neighbors\n      return nodeHasNeighbor(\n        this,\n        type,\n        direction,\n        node1,\n        node2\n      );\n    }\n    else if (arguments.length === 1) {\n      node = '' + node;\n\n      const nodeData = this._nodes.get(node);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(`Graph.${name}: could not find the \"${node}\" node in the graph.`);\n\n      // Here, we want to iterate over a node's relevant neighbors\n      const neighbors = createNeighborArrayForNode(\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n\n      return neighbors;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid number of arguments (expecting 1 or 2 and got ${arguments.length}).`);\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function(node, callback) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${forEachName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighborForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {\n    name,\n    type,\n    direction\n  } = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function(node) {\n\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return Iterator.empty();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(`Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`);\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nexport function attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n","/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used to validate import-export formats & to ouput\n * them from internal graph data.\n *\n * Serialized Node:\n * {key, ?attributes}\n *\n * Serialized Edge:\n * {key?, source, target, attributes?, undirected?}\n *\n * Serialized Graph:\n * {nodes[], edges?[]}\n */\nimport {UndirectedEdgeData} from './data';\nimport {assign, isPlainObject} from './utils';\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nexport function serializeNode(key, data) {\n  const serialized = {key};\n\n  if (Object.keys(data.attributes).length)\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nexport function serializeEdge(key, data) {\n  const serialized = {\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  // We export the key unless if it was provided by the user\n  if (!data.generatedKey)\n    serialized.key = key;\n\n  if (Object.keys(data.attributes).length)\n    serialized.attributes = assign({}, data.attributes);\n\n  if (data instanceof UndirectedEdgeData)\n    serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('key' in value))\n    return 'no-key';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  return null;\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nexport function validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    return 'not-object';\n\n  if (!('source' in value))\n    return 'no-source';\n\n  if (!('target' in value))\n    return 'no-target';\n\n  if ('attributes' in value &&\n      (!isPlainObject(value.attributes) || value.attributes === null))\n    return 'invalid-attributes';\n\n  if ('undirected' in value &&\n      (typeof value.undirected !== 'boolean'))\n    return 'invalid-undirected';\n\n  return null;\n}\n","/* eslint no-nested-ternary: 0 */\n/**\n * Graphology Reference Implementation\n * ====================================\n *\n * Reference implementation of the graphology specs.\n */\nimport {EventEmitter} from 'events';\nimport Iterator from 'obliterator/iterator';\nimport take from 'obliterator/take';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\nimport {\n  MixedNodeData,\n  DirectedNodeData,\n  UndirectedNodeData,\n  DirectedEdgeData,\n  UndirectedEdgeData\n} from './data';\n\nimport {\n  updateStructureIndex,\n  clearEdgeFromStructureIndex,\n  clearStructureIndex,\n  upgradeStructureIndexToMulti\n} from './indices';\n\nimport {attachAttributesMethods} from './attributes';\nimport {attachEdgeIterationMethods} from './iteration/edges';\nimport {attachNeighborIterationMethods} from './iteration/neighbors';\n\nimport {\n  serializeNode,\n  serializeEdge,\n  validateSerializedNode,\n  validateSerializedEdge\n} from './serialization';\n\nimport {\n  assign,\n  getMatchingEdge,\n  isGraph,\n  isPlainObject,\n  prettyPrint,\n  privateProperty,\n  readOnlyProperty,\n  incrementalId\n} from './utils';\n\n/**\n * Enums.\n */\nconst TYPES = new Set([\n  'directed',\n  'undirected',\n  'mixed'\n]);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`,\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  edgeKeyGenerator: null,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  const sourceData = graph._nodes.get(source),\n        targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(`Graph.${name}: source node \"${source}\" not found.`);\n\n  if (!targetData)\n    throw new NotFoundGraphError(`Graph.${name}: target node \"${target}\" not found.`);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    throw new UsageGraphError(`Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);\n  }\n\n  // Storing some data\n  const DataClass = undirected ? UndirectedEdgeData : DirectedEdgeData;\n\n  const edgeData = new DataClass(\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected)\n      sourceData.undirectedSelfLoops++;\n    else\n      sourceData.directedSelfLoops++;\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(`Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(`Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(`Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(`Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);\n\n  let sourceData = graph._nodes.get(source),\n      targetData = graph._nodes.get(target),\n      edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdge = null;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are coherent\n      if (\n        (edgeData.source !== source || edgeData.target !== target) ||\n        (undirected && (edgeData.source !== target || edgeData.target !== source))\n      ) {\n        throw new UsageGraphError(`Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (${edgeData.source}, ${edgeData.target}).`);\n      }\n\n      alreadyExistingEdge = edge;\n    }\n  }\n\n  let alreadyExistingEdgeData;\n\n  // Here, we might have a source / target collision\n  if (\n    !alreadyExistingEdge &&\n    !graph.multi &&\n    sourceData &&\n    (\n      undirected ?\n        typeof sourceData.undirected[target] !== 'undefined' :\n        typeof sourceData.out[target] !== 'undefined'\n    )\n  ) {\n    alreadyExistingEdgeData = getMatchingEdge(graph, source, target, undirected ? 'undirected' : 'directed');\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (!attributes)\n      return alreadyExistingEdge;\n\n    // Merging the attributes\n    assign(alreadyExistingEdgeData.attributes, attributes);\n    return alreadyExistingEdge;\n  }\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey)\n    edge = graph._edgeKeyGenerator(eventData);\n\n  // Coercion of edge key\n  edge = '' + edge;\n\n  // Here, we have a key collision\n  if (graph._edges.has(edge))\n    throw new UsageGraphError(`Graph.${name}: the \"${edge}\" edge already exists in the graph.`);\n\n  if (!sourceData) {\n    graph.addNode(source);\n    sourceData = graph._nodes.get(source);\n\n    if (source === target)\n      targetData = sourceData;\n  }\n  if (!targetData) {\n    graph.addNode(target);\n    targetData = graph._nodes.get(target);\n  }\n\n  // Storing some data\n  const DataClass = undirected ? UndirectedEdgeData : DirectedEdgeData;\n\n  edgeData = new DataClass(\n    edge,\n    mustGenerateKey,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  if (source === target) {\n    if (undirected)\n      sourceData.undirectedSelfLoops++;\n    else\n      sourceData.directedSelfLoops++;\n  }\n  else {\n    if (undirected) {\n      sourceData.undirectedDegree++;\n      targetData.undirectedDegree++;\n    }\n    else {\n      sourceData.outDegree++;\n      targetData.inDegree++;\n    }\n  }\n\n  // Updating relevant index\n  updateStructureIndex(\n    graph,\n    undirected,\n    edgeData,\n    source,\n    target,\n    sourceData,\n    targetData\n  );\n\n  if (undirected)\n    graph._undirectedSize++;\n  else\n    graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nexport default class Graph extends EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (options.edgeKeyGenerator && typeof options.edgeKeyGenerator !== 'function')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'edgeKeyGenerator' option. Expecting a function but got \"${options.edgeKeyGenerator}\".`);\n\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`);\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`);\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`);\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass = options.type === 'mixed' ?\n      MixedNodeData :\n      (options.type === 'directed') ?\n        DirectedNodeData :\n        UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_edgeKeyGenerator', options.edgeKeyGenerator || incrementalId());\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'undirected')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData instanceof DirectedEdgeData\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.out[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n\n    // Early termination\n    if (this.type === 'directed')\n      return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return (\n        !!edgeData &&\n        edgeData instanceof UndirectedEdgeData\n      );\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      const edges = nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    }\n    else if (arguments.length === 2) {\n\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData)\n        return false;\n\n      // Is there a directed edge pointing toward target?\n      let edges = typeof nodeData.out !== 'undefined' && nodeData.out[target];\n\n      if (!edges)\n        edges = typeof nodeData.undirected !== 'undefined' && nodeData.undirected[target];\n\n      if (!edges)\n        return false;\n\n      return this.multi ? !!edges.size : true;\n    }\n\n    throw new InvalidArgumentsGraphError(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`);\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n\n    if (this.type === 'undirected')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.directedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n\n    if (this.type === 'directed')\n      return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError('Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.');\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError('Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.');\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${source}\" source node in the graph.`);\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(`Graph.edge: could not find the \"${target}\" target node in the graph.`);\n\n    const edgeData = (\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined\n    );\n\n    if (edgeData)\n      return edgeData.key;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} allowSelfLoops - Count self-loops?\n   * @return {number}            - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.inDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.inDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.inDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's out degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.outDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(`Graph.outDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    const loops = selfLoops ? nodeData.directedSelfLoops : 0;\n\n    return nodeData.outDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's directed degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.directedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.directedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'undirected')\n      return 0;\n\n    return this.inDegree(node, selfLoops) + this.outDegree(node, selfLoops);\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's undirected degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.undirectedDegree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`);\n\n    if (this.type === 'directed')\n      return 0;\n\n    const data = this._nodes.get(node),\n          loops = selfLoops ? (data.undirectedSelfLoops * 2) : 0;\n\n    return data.undirectedDegree + loops;\n  }\n\n  /**\n   * Method returning the given node's degree.\n   *\n   * @param  {any}     node      - The node's key.\n   * @param  {boolean} selfLoops - Count self-loops?\n   * @return {number}            - The node's degree.\n   *\n   * @throws {Error} - Will throw if the selfLoops arg is not boolean.\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node, selfLoops = true) {\n    if (typeof selfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(`Graph.degree: Expecting a boolean but got \"${selfLoops}\" for the second parameter (allowing self-loops to be counted).`);\n\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.degree: could not find the \"${node}\" node in the graph.`);\n\n    let degree = 0;\n\n    if (this.type !== 'undirected')\n      degree += this.directedDegree(node, selfLoops);\n\n    if (this.type !== 'directed')\n      degree += this.undirectedDegree(node, selfLoops);\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.source: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.target: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(`Graph.extremities: could not find the \"${edge}\" edge in the graph.`);\n\n    return [\n      edgeData.source.key,\n      edgeData.target.key\n    ];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    if (!this._nodes.has(node))\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${node}\" node in the graph.`);\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.opposite: could not find the \"${edge}\" edge in the graph.`);\n\n    const {source: sourceData, target: targetData} = data;\n\n    const source = sourceData.key,\n          target = targetData.key;\n\n    if (node !== source && node !== target)\n      throw new NotFoundGraphError(`Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`);\n\n    return node === source ? target : source;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  undirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.undirected: could not find the \"${edge}\" edge in the graph.`);\n\n    return data instanceof UndirectedEdgeData;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  directed(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.directed: could not find the \"${edge}\" edge in the graph.`);\n\n    return data instanceof DirectedEdgeData;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  selfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.selfLoop: could not find the \"${edge}\" edge in the graph.`);\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    if (this._nodes.has(node))\n      throw new UsageGraphError(`Graph.addNode: the \"${node}\" node already exist in the graph.`);\n\n    const data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(`Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`);\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes)\n        assign(data.attributes, attributes);\n      return node;\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return node;\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    if (!this.hasNode(node))\n      throw new NotFoundGraphError(`Graph.dropNode: could not find the \"${node}\" node in the graph.`);\n\n    // Removing attached edges\n    const edges = this.edges(node);\n\n    // NOTE: we could go faster here\n    for (let i = 0, l = edges.length; i < l; i++)\n      this.dropEdge(edges[i]);\n\n    const data = this._nodes.get(node);\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: data.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0],\n            target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`);\n    }\n    else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(`Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`);\n    }\n\n    // Dropping the edge from the register\n    this._edges.delete(edgeData.key);\n\n    // Updating related degrees\n    const {\n      source: sourceData,\n      target: targetData,\n      attributes\n    } = edgeData;\n\n    const undirected = edgeData instanceof UndirectedEdgeData;\n\n    if (sourceData === targetData) {\n      sourceData.selfLoops--;\n    }\n    else {\n      if (undirected) {\n        sourceData.undirectedDegree--;\n        targetData.undirectedDegree--;\n      }\n      else {\n        sourceData.outDegree--;\n        targetData.inDegree--;\n      }\n    }\n\n    // Clearing index\n    clearEdgeFromStructureIndex(this, undirected, edgeData);\n\n    if (undirected)\n      this._undirectedSize--;\n    else\n      this._directedSize--;\n\n    // Emitting\n    this.emit('edgeDropped', {\n      key: edge,\n      attributes,\n      source: sourceData.key,\n      target: targetData.key,\n      undirected\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing indices\n    this.clearIndex();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    this._attributes[name] = updater(this._attributes[name]);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      meta: {\n        name,\n        value: this._attributes[name]\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceAttributes: provided attributes are not a plain object.');\n\n    const before = this._attributes;\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      meta: {\n        before,\n        after: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeAttributes: provided attributes are not a plain object.');\n\n    this._attributes = assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      meta: {\n        data: this._attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method returning the desired attribute for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to get.\n   * @return {any}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes[name];\n  }\n\n  /**\n   * Method returning the attributes for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @return {object}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  getNodeAttributes(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.getNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes;\n  }\n\n  /**\n   * Method checking whether the given attribute exists for the given node.\n   *\n   * @param  {any}    node - Target node.\n   * @param  {string} name - Name of the attribute to check.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  hasNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    return data.attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to set.\n   * @param  {any}    value - Value for the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  setNodeAttribute(node, name, value) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.setNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.setNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or value, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      meta: {\n        name,\n        value\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method checking setting the desired attribute for the given node.\n   *\n   * @param  {any}      node    - Target node.\n   * @param  {string}   name    - Name of the attribute to set.\n   * @param  {function} updater - Function that will update the attribute.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if less than 3 arguments are passed.\n   * @throws {Error} - Will throw if updater is not a function.\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  updateNodeAttribute(node, name, updater) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.updateNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError('Graph.updateNodeAttribute: not enough arguments. Either you forgot to pass the attribute\\'s name or updater, or you meant to use #.replaceNodeAttributes / #.mergeNodeAttributes instead.');\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.updateAttribute: updater should be a function.');\n\n    const attributes = data.attributes;\n\n    attributes[name] = updater(attributes[name]);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'set',\n      meta: {\n        name,\n        value: attributes[name]\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired attribute for the given node.\n   *\n   * @param  {any}    node  - Target node.\n   * @param  {string} name  - Name of the attribute to remove.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  removeNodeAttribute(node, name) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.hasNodeAttribute: could not find the \"${node}\" node in the graph.`);\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'remove',\n      meta: {\n        name\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method completely replacing the attributes of the given node.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  replaceNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.replaceNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.replaceNodeAttributes: provided attributes are not a plain object.');\n\n    const oldAttributes = data.attributes;\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'replace',\n      meta: {\n        before: oldAttributes,\n        after: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the attributes of the given node with the provided ones.\n   *\n   * @param  {any}    node       - Target node.\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   * @throws {Error} - Will throw if the given attributes is not a plain object.\n   */\n  mergeNodeAttributes(node, attributes) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.mergeNodeAttributes: could not find the \"${node}\" node in the graph.`);\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError('Graph.mergeNodeAttributes: provided attributes are not a plain object.');\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: node,\n      type: 'merge',\n      meta: {\n        data: attributes\n      }\n    });\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEach(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEach: expecting a callback.');\n\n    this._edges.forEach((edgeData, key) => {\n      const sourceData = edgeData.source,\n            targetData = edgeData.target;\n\n      callback(\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        key,\n        edgeData.attributes\n      );\n    });\n  }\n\n  /**\n   * Method returning an iterator over the graph's adjacency.\n   *\n   * @return {Iterator}\n   */\n  adjacency() {\n    const iterator = this._edges.values();\n\n    return new Iterator(function() {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const edgeData = step.value;\n\n      const sourceData = edgeData.source,\n            targetData = edgeData.target;\n\n      return {\n        done: false,\n        value: [\n          sourceData.key,\n          targetData.key,\n          sourceData.attributes,\n          targetData.attributes,\n          edgeData.key,\n          edgeData.attributes\n        ]\n      };\n    });\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return take(this._nodes.keys(), this._nodes.size);\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError('Graph.forEachNode: expecting a callback.');\n\n    this._nodes.forEach((data, key) => {\n      callback(key, data.attributes);\n    });\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return new Iterator(() => {\n      const step = iterator.next();\n\n      if (step.done)\n        return step;\n\n      const data = step.value;\n\n      return {value: [data.key, data.attributes], done: false};\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method exporting the target node.\n   *\n   * @param  {any}   node - Target node.\n   * @return {array}      - The serialized node.\n   *\n   * @throws {Error} - Will throw if the node is not found.\n   */\n  exportNode(node) {\n    node = '' + node;\n\n    const data = this._nodes.get(node);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportNode: could not find the \"${node}\" node in the graph.`);\n\n    return serializeNode(node, data);\n  }\n\n  /**\n   * Method exporting the target edge.\n   *\n   * @param  {any}   edge - Target edge.\n   * @return {array}      - The serialized edge.\n   *\n   * @throws {Error} - Will throw if the edge is not found.\n   */\n  exportEdge(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(`Graph.exportEdge: could not find the \"${edge}\" edge in the graph.`);\n\n    return serializeEdge(edge, data);\n  }\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(key, data);\n    });\n\n    return {\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized node.\n   *\n   * @param  {object} data   - The serialized node.\n   * @param  {boolean} merge - Whether to merge the given node.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importNode(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedNode(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.');\n      if (error === 'no-key')\n        throw new InvalidArgumentsGraphError('Graph.importNode: no key provided.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importNode: invalid attributes. Attributes should be a plain object, null or omitted.');\n    }\n\n    // Adding the node\n    const {key, attributes = {}} = data;\n\n    if (merge)\n      this.mergeNode(key, attributes);\n    else\n      this.addNode(key, attributes);\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized edge.\n   *\n   * @param  {object}  data  - The serialized edge.\n   * @param  {boolean} merge - Whether to merge the given edge.\n   * @return {Graph}         - Returns itself for chaining.\n   */\n  importEdge(data, merge = false) {\n\n    // Validating\n    const error = validateSerializedEdge(data);\n\n    if (error) {\n\n      if (error === 'not-object')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.');\n      if (error === 'no-source')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing souce.');\n      if (error === 'no-target')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: missing target.');\n      if (error === 'invalid-attributes')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid attributes. Attributes should be a plain object, null or omitted.');\n      if (error === 'invalid-undirected')\n        throw new InvalidArgumentsGraphError('Graph.importEdge: invalid undirected. Undirected should be boolean or omitted.');\n    }\n\n    // Adding the edge\n    const {\n      source,\n      target,\n      attributes = {},\n      undirected = false\n    } = data;\n\n    let method;\n\n    if ('key' in data) {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdgeWithKey : this.mergeDirectedEdgeWithKey) :\n        (undirected ? this.addUndirectedEdgeWithKey : this.addDirectedEdgeWithKey);\n\n      method.call(\n        this,\n        data.key,\n        source,\n        target,\n        attributes\n      );\n    }\n    else {\n      method = merge ?\n        (undirected ? this.mergeUndirectedEdge : this.mergeDirectedEdge) :\n        (undirected ? this.addUndirectedEdge : this.addDirectedEdge);\n\n      method.call(\n        this,\n        source,\n        target,\n        attributes\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n\n    // Importing a Graph instance\n    if (isGraph(data)) {\n\n      this.import(data.export(), merge);\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError('Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.');\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError('Graph.import: invalid attributes. Expecting a plain object.');\n\n      if (merge)\n        this.mergeAttributes(data.attributes);\n      else\n        this.replaceAttributes(data.attributes);\n    }\n\n    // TODO: optimize\n    if (data.nodes)\n      data.nodes.forEach(node => this.importNode(node, merge));\n\n    if (data.edges)\n      data.edges.forEach(edge => this.importEdge(edge, merge));\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    return new Graph(assign({}, this._options, options));\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n\n    this._nodes.forEach((nodeData, key) => {\n      nodeData = new graph.NodeDataClass(key, assign({}, nodeData.attributes));\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @return {Graph} - The copy.\n   */\n  copy() {\n    const graph = new Graph(this._options);\n    graph.import(this);\n\n    return graph;\n  }\n\n  /**\n   * Method upgrading the graph to a mixed one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMixed() {\n    if (this.type === 'mixed')\n      return this;\n\n    // Upgrading node data:\n    // NOTE: maybe this could lead to some de-optimization by usual\n    // JavaScript engines but I cannot be sure of it. Another solution\n    // would be to reinstantiate the classes but this surely has a performance\n    // and memory impact.\n    this._nodes.forEach(data => (data.upgradeToMixed()));\n\n    // Mutating the options & the instance\n    this._options.type = 'mixed';\n    readOnlyProperty(this, 'type', this._options.type);\n    privateProperty(this, 'NodeDataClass', MixedNodeData);\n\n    return this;\n  }\n\n  /**\n   * Method upgrading the graph to a multi one.\n   *\n   * @return {Graph} - The copy.\n   */\n  upgradeToMulti() {\n    if (this.multi)\n      return this;\n\n    // Mutating the options & the instance\n    this._options.multi = true;\n    readOnlyProperty(this, 'multi', true);\n\n    // Upgrading indices\n    upgradeStructureIndexToMulti(this);\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Indexes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to clear the desired index to clear memory.\n   *\n   * @return {Graph}       - Returns itself for chaining.\n   */\n  clearIndex() {\n    clearStructureIndex(this);\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method used to perform string coercion and returning useful information\n   * about the Graph instance.\n   *\n   * @return {string} - String representation of the graph.\n   */\n  toString() {\n    const pluralOrder = this.order > 1 || this.order === 0,\n          pluralSize = this.size > 1 || this.size === 0;\n\n    return `Graph<${prettyPrint(this.order)} node${pluralOrder ? 's' : ''}, ${prettyPrint(this.size)} edge${pluralSize ? 's' : ''}>`;\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n          multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data instanceof UndirectedEdgeData ? '--' : '->';\n\n      let label = '';\n\n      const desc = `(${data.source.key})${direction}(${data.target.key})`;\n\n      if (!data.generatedKey) {\n        label += `[${key}]: `;\n      }\n      else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        }\n        else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (this.hasOwnProperty(k) &&\n          !EMITTER_PROPS.has(k) &&\n          typeof this[k] !== 'function')\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] = Graph.prototype.inspect;\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge'].forEach(verb => {\n    const name = method.name(verb),\n          fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function(source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes\n        );\n      };\n    }\n    else {\n      Graph.prototype[name] = function(edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes\n        );\n      };\n    }\n  });\n});\n\n/**\n * Self iterator.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.iterator] = Graph.prototype.adjacency;\n\n/**\n * Attributes-related.\n */\nattachAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n","/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\nimport {assign} from './utils';\nimport Graph from './graph';\n\nimport {\n  InvalidArgumentsGraphError,\n  NotFoundGraphError,\n  UsageGraphError\n} from './errors';\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({type: 'directed'}, options)\n    );\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({type: 'undirected'}, options)\n    );\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true}, options)\n    );\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true, type: 'directed'}, options)\n    );\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    super(\n      assign({multi: true, type: 'undirected'}, options)\n    );\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function(data, options) {\n    const instance = new Class(options);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\nexport {\n  Graph,\n  DirectedGraph,\n  UndirectedGraph,\n  MultiGraph,\n  MultiDirectedGraph,\n  MultiUndirectedGraph\n};\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst Graph = require('graphology');\r\n/* eslint no-constant-condition: 0 */\r\n/**\r\n * Graphology ForceAtlas2 Iteration\r\n * =================================\r\n *\r\n * Function used to perform a single iteration of the algorithm.\r\n */\r\n/**\r\n * Matrices properties accessors.\r\n */\r\nvar NODE_X = 0, NODE_Y = 1, NODE_DX = 2, NODE_DY = 3, NODE_OLD_DX = 4, NODE_OLD_DY = 5, NODE_MASS = 6, NODE_CONVERGENCE = 7, NODE_SIZE = 8, NODE_FIXED = 9;\r\nvar EDGE_SOURCE = 0, EDGE_TARGET = 1, EDGE_WEIGHT = 2;\r\nvar REGION_NODE = 0, REGION_CENTER_X = 1, REGION_CENTER_Y = 2, REGION_SIZE = 3, REGION_NEXT_SIBLING = 4, REGION_FIRST_CHILD = 5, REGION_MASS = 6, REGION_MASS_CENTER_X = 7, REGION_MASS_CENTER_Y = 8;\r\nvar SUBDIVISION_ATTEMPTS = 3;\r\n/**\r\n * Constants.\r\n */\r\nvar PPN = 10, PPE = 3, PPR = 9;\r\nvar MAX_FORCE = 10;\r\n/**\r\n * Function used to perform a single interation of the algorithm.\r\n *\r\n * @param  {object}       options    - Layout options.\r\n * @param  {Float32Array} NodeMatrix - Node data.\r\n * @param  {Float32Array} EdgeMatrix - Edge data.\r\n * @return {object}                  - Some metadata.\r\n */\r\nfunction iterate(options, NodeMatrix, EdgeMatrix) {\r\n    // Initializing variables\r\n    var l, r, n, n1, n2, rn, e, w, g, s;\r\n    var order = NodeMatrix.length, size = EdgeMatrix.length;\r\n    var adjustSizes = options.adjustSizes;\r\n    var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\r\n    var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\r\n    var RegionMatrix = [];\r\n    // 1) Initializing layout data\r\n    //-----------------------------\r\n    // Resetting positions & computing max values\r\n    for (n = 0; n < order; n += PPN) {\r\n        NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\r\n        NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\r\n        NodeMatrix[n + NODE_DX] = 0;\r\n        NodeMatrix[n + NODE_DY] = 0;\r\n    }\r\n    // If outbound attraction distribution, compensate\r\n    if (options.outboundAttractionDistribution) {\r\n        outboundAttCompensation = 0;\r\n        for (n = 0; n < order; n += PPN) {\r\n            outboundAttCompensation += NodeMatrix[n + NODE_MASS];\r\n        }\r\n        outboundAttCompensation /= (order / PPN);\r\n    }\r\n    // 1.bis) Barnes-Hut computation\r\n    //------------------------------\r\n    if (options.barnesHutOptimize) {\r\n        // Setting up\r\n        var minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity, q, q2, subdivisionAttempts;\r\n        // Computing min and max values\r\n        for (n = 0; n < order; n += PPN) {\r\n            minX = Math.min(minX, NodeMatrix[n + NODE_X]);\r\n            maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\r\n            minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\r\n            maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\r\n        }\r\n        // squarify bounds, it's a quadtree\r\n        var dx = maxX - minX, dy = maxY - minY;\r\n        if (dx > dy) {\r\n            minY -= (dx - dy) / 2;\r\n            maxY = minY + dx;\r\n        }\r\n        else {\r\n            minX -= (dy - dx) / 2;\r\n            maxX = minX + dy;\r\n        }\r\n        // Build the Barnes Hut root region\r\n        RegionMatrix[0 + REGION_NODE] = -1;\r\n        RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\r\n        RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\r\n        RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\r\n        RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\r\n        RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\r\n        RegionMatrix[0 + REGION_MASS] = 0;\r\n        RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\r\n        RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\r\n        // Add each node in the tree\r\n        l = 1;\r\n        for (n = 0; n < order; n += PPN) {\r\n            // Current region, starting with root\r\n            r = 0;\r\n            subdivisionAttempts = SUBDIVISION_ATTEMPTS;\r\n            while (true) {\r\n                // Are there sub-regions?\r\n                // We look at first child index\r\n                if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\r\n                    // There are sub-regions\r\n                    // We just iterate to find a \"leaf\" of the tree\r\n                    // that is an empty region or a region with a single node\r\n                    // (see next case)\r\n                    // Find the quadrant of n\r\n                    if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\r\n                        if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\r\n                            // Top Left quarter\r\n                            q = RegionMatrix[r + REGION_FIRST_CHILD];\r\n                        }\r\n                        else {\r\n                            // Bottom Left quarter\r\n                            q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\r\n                            // Top Right quarter\r\n                            q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\r\n                        }\r\n                        else {\r\n                            // Bottom Right quarter\r\n                            q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\r\n                        }\r\n                    }\r\n                    // Update center of mass and mass (we only do it for non-leave regions)\r\n                    RegionMatrix[r + REGION_MASS_CENTER_X] =\r\n                        (RegionMatrix[r + REGION_MASS_CENTER_X] * RegionMatrix[r + REGION_MASS] +\r\n                            NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\r\n                            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\r\n                    RegionMatrix[r + REGION_MASS_CENTER_Y] =\r\n                        (RegionMatrix[r + REGION_MASS_CENTER_Y] * RegionMatrix[r + REGION_MASS] +\r\n                            NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\r\n                            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\r\n                    RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\r\n                    // Iterate on the right quadrant\r\n                    r = q;\r\n                    continue;\r\n                }\r\n                else {\r\n                    // There are no sub-regions: we are in a \"leaf\"\r\n                    // Is there a node in this leave?\r\n                    if (RegionMatrix[r + REGION_NODE] < 0) {\r\n                        // There is no node in region:\r\n                        // we record node n and go on\r\n                        RegionMatrix[r + REGION_NODE] = n;\r\n                        break;\r\n                    }\r\n                    else {\r\n                        // There is a node in this region\r\n                        // We will need to create sub-regions, stick the two\r\n                        // nodes (the old one r[0] and the new one n) in two\r\n                        // subregions. If they fall in the same quadrant,\r\n                        // we will iterate.\r\n                        // Create sub-regions\r\n                        RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\r\n                        w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\r\n                        // NOTE: we use screen coordinates\r\n                        // from Top Left to Bottom Right\r\n                        // Top Left sub-region\r\n                        g = RegionMatrix[r + REGION_FIRST_CHILD];\r\n                        RegionMatrix[g + REGION_NODE] = -1;\r\n                        RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\r\n                        RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\r\n                        RegionMatrix[g + REGION_SIZE] = w;\r\n                        RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\r\n                        RegionMatrix[g + REGION_FIRST_CHILD] = -1;\r\n                        RegionMatrix[g + REGION_MASS] = 0;\r\n                        RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\r\n                        RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\r\n                        // Bottom Left sub-region\r\n                        g += PPR;\r\n                        RegionMatrix[g + REGION_NODE] = -1;\r\n                        RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\r\n                        RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\r\n                        RegionMatrix[g + REGION_SIZE] = w;\r\n                        RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\r\n                        RegionMatrix[g + REGION_FIRST_CHILD] = -1;\r\n                        RegionMatrix[g + REGION_MASS] = 0;\r\n                        RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\r\n                        RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\r\n                        // Top Right sub-region\r\n                        g += PPR;\r\n                        RegionMatrix[g + REGION_NODE] = -1;\r\n                        RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\r\n                        RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\r\n                        RegionMatrix[g + REGION_SIZE] = w;\r\n                        RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\r\n                        RegionMatrix[g + REGION_FIRST_CHILD] = -1;\r\n                        RegionMatrix[g + REGION_MASS] = 0;\r\n                        RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\r\n                        RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\r\n                        // Bottom Right sub-region\r\n                        g += PPR;\r\n                        RegionMatrix[g + REGION_NODE] = -1;\r\n                        RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\r\n                        RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\r\n                        RegionMatrix[g + REGION_SIZE] = w;\r\n                        RegionMatrix[g + REGION_NEXT_SIBLING] = RegionMatrix[r + REGION_NEXT_SIBLING];\r\n                        RegionMatrix[g + REGION_FIRST_CHILD] = -1;\r\n                        RegionMatrix[g + REGION_MASS] = 0;\r\n                        RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\r\n                        RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\r\n                        l += 4;\r\n                        // Now the goal is to find two different sub-regions\r\n                        // for the two nodes: the one previously recorded (r[0])\r\n                        // and the one we want to add (n)\r\n                        // Find the quadrant of the old node\r\n                        if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\r\n                            if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\r\n                                // Top Left quarter\r\n                                q = RegionMatrix[r + REGION_FIRST_CHILD];\r\n                            }\r\n                            else {\r\n                                // Bottom Left quarter\r\n                                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\r\n                                // Top Right quarter\r\n                                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\r\n                            }\r\n                            else {\r\n                                // Bottom Right quarter\r\n                                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\r\n                            }\r\n                        }\r\n                        // We remove r[0] from the region r, add its mass to r and record it in q\r\n                        RegionMatrix[r + REGION_MASS] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\r\n                        RegionMatrix[r + REGION_MASS_CENTER_X] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\r\n                        RegionMatrix[r + REGION_MASS_CENTER_Y] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\r\n                        RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\r\n                        RegionMatrix[r + REGION_NODE] = -1;\r\n                        // Find the quadrant of n\r\n                        if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\r\n                            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\r\n                                // Top Left quarter\r\n                                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\r\n                            }\r\n                            else {\r\n                                // Bottom Left quarter\r\n                                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\r\n                                // Top Right quarter\r\n                                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\r\n                            }\r\n                            else {\r\n                                // Bottom Right quarter\r\n                                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\r\n                            }\r\n                        }\r\n                        if (q === q2) {\r\n                            // If both nodes are in the same quadrant,\r\n                            // we have to try it again on this quadrant\r\n                            if (subdivisionAttempts--) {\r\n                                r = q;\r\n                                continue; // while\r\n                            }\r\n                            else {\r\n                                // we are out of precision here, and we cannot subdivide anymore\r\n                                // but we have to break the loop anyway\r\n                                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\r\n                                break; // while\r\n                            }\r\n                        }\r\n                        // If both quadrants are different, we record n\r\n                        // in its quadrant\r\n                        RegionMatrix[q2 + REGION_NODE] = n;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 2) Repulsion\r\n    //--------------\r\n    // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\r\n    if (options.barnesHutOptimize) {\r\n        coefficient = options.scalingRatio;\r\n        // Applying repulsion through regions\r\n        for (n = 0; n < order; n += PPN) {\r\n            // Computing leaf quad nodes iteration\r\n            r = 0; // Starting with root region\r\n            while (true) {\r\n                if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\r\n                    // The region has sub-regions\r\n                    // We run the Barnes Hut test to see if we are at the right distance\r\n                    distance = ((Math.pow(NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X], 2)) +\r\n                        (Math.pow(NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y], 2)));\r\n                    s = RegionMatrix[r + REGION_SIZE];\r\n                    if ((4 * s * s) / distance < thetaSquared) {\r\n                        // We treat the region as a single body, and we repulse\r\n                        xDist = NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\r\n                        yDist = NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\r\n                        if (adjustSizes === true) {\r\n                            //-- Linear Anti-collision Repulsion\r\n                            if (distance > 0) {\r\n                                factor = coefficient * NodeMatrix[n + NODE_MASS] *\r\n                                    RegionMatrix[r + REGION_MASS] / distance;\r\n                                NodeMatrix[n + NODE_DX] += xDist * factor;\r\n                                NodeMatrix[n + NODE_DY] += yDist * factor;\r\n                            }\r\n                            else if (distance < 0) {\r\n                                factor = -coefficient * NodeMatrix[n + NODE_MASS] *\r\n                                    RegionMatrix[r + REGION_MASS] / Math.sqrt(distance);\r\n                                NodeMatrix[n + NODE_DX] += xDist * factor;\r\n                                NodeMatrix[n + NODE_DY] += yDist * factor;\r\n                            }\r\n                        }\r\n                        else {\r\n                            //-- Linear Repulsion\r\n                            if (distance > 0) {\r\n                                factor = coefficient * NodeMatrix[n + NODE_MASS] *\r\n                                    RegionMatrix[r + REGION_MASS] / distance;\r\n                                NodeMatrix[n + NODE_DX] += xDist * factor;\r\n                                NodeMatrix[n + NODE_DY] += yDist * factor;\r\n                            }\r\n                        }\r\n                        // When this is done, we iterate. We have to look at the next sibling.\r\n                        r = RegionMatrix[r + REGION_NEXT_SIBLING];\r\n                        if (r < 0)\r\n                            break; // No next sibling: we have finished the tree\r\n                        continue;\r\n                    }\r\n                    else {\r\n                        // The region is too close and we have to look at sub-regions\r\n                        r = RegionMatrix[r + REGION_FIRST_CHILD];\r\n                        continue;\r\n                    }\r\n                }\r\n                else {\r\n                    // The region has no sub-region\r\n                    // If there is a node r[0] and it is not n, then repulse\r\n                    rn = RegionMatrix[r + REGION_NODE];\r\n                    if (rn >= 0 && rn !== n) {\r\n                        xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\r\n                        yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\r\n                        distance = xDist * xDist + yDist * yDist;\r\n                        if (adjustSizes === true) {\r\n                            //-- Linear Anti-collision Repulsion\r\n                            if (distance > 0) {\r\n                                factor = coefficient * NodeMatrix[n + NODE_MASS] *\r\n                                    NodeMatrix[rn + NODE_MASS] / distance;\r\n                                NodeMatrix[n + NODE_DX] += xDist * factor;\r\n                                NodeMatrix[n + NODE_DY] += yDist * factor;\r\n                            }\r\n                            else if (distance < 0) {\r\n                                factor = -coefficient * NodeMatrix[n + NODE_MASS] *\r\n                                    NodeMatrix[rn + NODE_MASS] / Math.sqrt(distance);\r\n                                NodeMatrix[n + NODE_DX] += xDist * factor;\r\n                                NodeMatrix[n + NODE_DY] += yDist * factor;\r\n                            }\r\n                        }\r\n                        else {\r\n                            //-- Linear Repulsion\r\n                            if (distance > 0) {\r\n                                factor = coefficient * NodeMatrix[n + NODE_MASS] *\r\n                                    NodeMatrix[rn + NODE_MASS] / distance;\r\n                                NodeMatrix[n + NODE_DX] += xDist * factor;\r\n                                NodeMatrix[n + NODE_DY] += yDist * factor;\r\n                            }\r\n                        }\r\n                    }\r\n                    // When this is done, we iterate. We have to look at the next sibling.\r\n                    r = RegionMatrix[r + REGION_NEXT_SIBLING];\r\n                    if (r < 0)\r\n                        break; // No next sibling: we have finished the tree\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        coefficient = options.scalingRatio;\r\n        // Square iteration\r\n        for (n1 = 0; n1 < order; n1 += PPN) {\r\n            for (n2 = 0; n2 < n1; n2 += PPN) {\r\n                // Common to both methods\r\n                xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\r\n                yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\r\n                if (adjustSizes === true) {\r\n                    //-- Anticollision Linear Repulsion\r\n                    distance = Math.sqrt(xDist * xDist + yDist * yDist) -\r\n                        NodeMatrix[n1 + NODE_SIZE] -\r\n                        NodeMatrix[n2 + NODE_SIZE];\r\n                    if (distance > 0) {\r\n                        factor = coefficient *\r\n                            NodeMatrix[n1 + NODE_MASS] *\r\n                            NodeMatrix[n2 + NODE_MASS] /\r\n                            distance / distance;\r\n                        // Updating nodes' dx and dy\r\n                        NodeMatrix[n1 + NODE_DX] += xDist * factor;\r\n                        NodeMatrix[n1 + NODE_DY] += yDist * factor;\r\n                        NodeMatrix[n2 + NODE_DX] += xDist * factor;\r\n                        NodeMatrix[n2 + NODE_DY] += yDist * factor;\r\n                    }\r\n                    else if (distance < 0) {\r\n                        factor = 100 * coefficient *\r\n                            NodeMatrix[n1 + NODE_MASS] *\r\n                            NodeMatrix[n2 + NODE_MASS];\r\n                        // Updating nodes' dx and dy\r\n                        NodeMatrix[n1 + NODE_DX] += xDist * factor;\r\n                        NodeMatrix[n1 + NODE_DY] += yDist * factor;\r\n                        NodeMatrix[n2 + NODE_DX] -= xDist * factor;\r\n                        NodeMatrix[n2 + NODE_DY] -= yDist * factor;\r\n                    }\r\n                }\r\n                else {\r\n                    //-- Linear Repulsion\r\n                    distance = Math.sqrt(xDist * xDist + yDist * yDist);\r\n                    if (distance > 0) {\r\n                        factor = coefficient *\r\n                            NodeMatrix[n1 + NODE_MASS] *\r\n                            NodeMatrix[n2 + NODE_MASS] /\r\n                            distance / distance;\r\n                        // Updating nodes' dx and dy\r\n                        NodeMatrix[n1 + NODE_DX] += xDist * factor;\r\n                        NodeMatrix[n1 + NODE_DY] += yDist * factor;\r\n                        NodeMatrix[n2 + NODE_DX] -= xDist * factor;\r\n                        NodeMatrix[n2 + NODE_DY] -= yDist * factor;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // 3) Gravity\r\n    //------------\r\n    g = options.gravity / options.scalingRatio;\r\n    coefficient = options.scalingRatio;\r\n    for (n = 0; n < order; n += PPN) {\r\n        factor = 0;\r\n        // Common to both methods\r\n        xDist = NodeMatrix[n + NODE_X];\r\n        yDist = NodeMatrix[n + NODE_Y];\r\n        distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\r\n        if (options.strongGravityMode) {\r\n            //-- Strong gravity\r\n            if (distance > 0)\r\n                factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\r\n        }\r\n        else {\r\n            //-- Linear Anti-collision Repulsion n\r\n            if (distance > 0)\r\n                factor = coefficient * NodeMatrix[n + NODE_MASS] * g / distance;\r\n        }\r\n        // Updating node's dx and dy\r\n        NodeMatrix[n + NODE_DX] -= xDist * factor;\r\n        NodeMatrix[n + NODE_DY] -= yDist * factor;\r\n    }\r\n    // 4) Attraction\r\n    //---------------\r\n    coefficient = 1 *\r\n        (options.outboundAttractionDistribution ?\r\n            outboundAttCompensation :\r\n            1);\r\n    // TODO: simplify distance\r\n    // TODO: coefficient is always used as -c --> optimize?\r\n    for (e = 0; e < size; e += PPE) {\r\n        n1 = EdgeMatrix[e + EDGE_SOURCE];\r\n        n2 = EdgeMatrix[e + EDGE_TARGET];\r\n        w = EdgeMatrix[e + EDGE_WEIGHT];\r\n        // Edge weight influence\r\n        ewc = Math.pow(w, options.edgeWeightInfluence);\r\n        // Common measures\r\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\r\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\r\n        // Applying attraction to nodes\r\n        if (adjustSizes === true) {\r\n            distance = Math.sqrt((Math.pow(xDist, 2) + Math.pow(yDist, 2)) -\r\n                NodeMatrix[n1 + NODE_SIZE] -\r\n                NodeMatrix[n2 + NODE_SIZE]);\r\n            if (options.linLogMode) {\r\n                if (options.outboundAttractionDistribution) {\r\n                    //-- LinLog Degree Distributed Anti-collision Attraction\r\n                    if (distance > 0) {\r\n                        factor = -coefficient * ewc * Math.log(1 + distance) /\r\n                            distance /\r\n                            NodeMatrix[n1 + NODE_MASS];\r\n                    }\r\n                }\r\n                else {\r\n                    //-- LinLog Anti-collision Attraction\r\n                    if (distance > 0) {\r\n                        factor = -coefficient * ewc * Math.log(1 + distance) / distance;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                if (options.outboundAttractionDistribution) {\r\n                    //-- Linear Degree Distributed Anti-collision Attraction\r\n                    if (distance > 0) {\r\n                        factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\r\n                    }\r\n                }\r\n                else {\r\n                    //-- Linear Anti-collision Attraction\r\n                    if (distance > 0) {\r\n                        factor = -coefficient * ewc;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\r\n            if (options.linLogMode) {\r\n                if (options.outboundAttractionDistribution) {\r\n                    //-- LinLog Degree Distributed Attraction\r\n                    if (distance > 0) {\r\n                        factor = -coefficient * ewc * Math.log(1 + distance) /\r\n                            distance /\r\n                            NodeMatrix[n1 + NODE_MASS];\r\n                    }\r\n                }\r\n                else {\r\n                    //-- LinLog Attraction\r\n                    if (distance > 0)\r\n                        factor = -coefficient * ewc * Math.log(1 + distance) / distance;\r\n                }\r\n            }\r\n            else {\r\n                if (options.outboundAttractionDistribution) {\r\n                    //-- Linear Attraction Mass Distributed\r\n                    // NOTE: Distance is set to 1 to override next condition\r\n                    distance = 1;\r\n                    factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\r\n                }\r\n                else {\r\n                    //-- Linear Attraction\r\n                    // NOTE: Distance is set to 1 to override next condition\r\n                    distance = 1;\r\n                    factor = -coefficient * ewc;\r\n                }\r\n            }\r\n        }\r\n        // Updating nodes' dx and dy\r\n        // TODO: if condition or factor = 1?\r\n        if (distance > 0) {\r\n            // Updating nodes' dx and dy\r\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\r\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\r\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\r\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\r\n        }\r\n    }\r\n    // 5) Apply Forces\r\n    //-----------------\r\n    var force, swinging, traction, nodespeed, newX, newY;\r\n    // MATH: sqrt and square distances\r\n    if (adjustSizes === true) {\r\n        for (n = 0; n < order; n += PPN) {\r\n            if (!NodeMatrix[n + NODE_FIXED]) {\r\n                force = Math.sqrt(Math.pow(NodeMatrix[n + NODE_DX], 2) +\r\n                    Math.pow(NodeMatrix[n + NODE_DY], 2));\r\n                if (force > MAX_FORCE) {\r\n                    NodeMatrix[n + NODE_DX] =\r\n                        NodeMatrix[n + NODE_DX] * MAX_FORCE / force;\r\n                    NodeMatrix[n + NODE_DY] =\r\n                        NodeMatrix[n + NODE_DY] * MAX_FORCE / force;\r\n                }\r\n                swinging = NodeMatrix[n + NODE_MASS] *\r\n                    Math.sqrt((NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\r\n                        (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\r\n                        (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\r\n                            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]));\r\n                traction = Math.sqrt((NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\r\n                    (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\r\n                    (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\r\n                        (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])) / 2;\r\n                nodespeed =\r\n                    0.1 * Math.log(1 + traction) / (1 + Math.sqrt(swinging));\r\n                // Updating node's positon\r\n                newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *\r\n                    (nodespeed / options.slowDown);\r\n                NodeMatrix[n + NODE_X] = newX;\r\n                newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *\r\n                    (nodespeed / options.slowDown);\r\n                NodeMatrix[n + NODE_Y] = newY;\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        for (n = 0; n < order; n += PPN) {\r\n            if (!NodeMatrix[n + NODE_FIXED]) {\r\n                swinging = NodeMatrix[n + NODE_MASS] *\r\n                    Math.sqrt((NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\r\n                        (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\r\n                        (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\r\n                            (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]));\r\n                traction = Math.sqrt((NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\r\n                    (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\r\n                    (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\r\n                        (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])) / 2;\r\n                nodespeed = NodeMatrix[n + NODE_CONVERGENCE] *\r\n                    Math.log(1 + traction) / (1 + Math.sqrt(swinging));\r\n                // Updating node convergence\r\n                NodeMatrix[n + NODE_CONVERGENCE] =\r\n                    Math.min(1, Math.sqrt(nodespeed *\r\n                        (Math.pow(NodeMatrix[n + NODE_DX], 2) +\r\n                            Math.pow(NodeMatrix[n + NODE_DY], 2)) /\r\n                        (1 + Math.sqrt(swinging))));\r\n                // Updating node's positon\r\n                newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] *\r\n                    (nodespeed / options.slowDown);\r\n                NodeMatrix[n + NODE_X] = newX;\r\n                newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] *\r\n                    (nodespeed / options.slowDown);\r\n                NodeMatrix[n + NODE_Y] = newY;\r\n            }\r\n        }\r\n    }\r\n    // We return the information about the layout (no need to return the matrices)\r\n    return {};\r\n}\r\n;\r\n/**\r\n * Graphology ForceAtlas2 Helpers\r\n * ===============================\r\n *\r\n * Miscellaneous helper functions.\r\n */\r\n/**\r\n * Function used to validate the given settings.\r\n *\r\n * @param  {object}      settings - Settings to validate.\r\n * @return {object|null}\r\n */\r\nfunction validateSettings(settings) {\r\n    if ('linLogMode' in settings &&\r\n        typeof settings.linLogMode !== 'boolean')\r\n        return { message: 'the `linLogMode` setting should be a boolean.' };\r\n    if ('outboundAttractionDistribution' in settings &&\r\n        typeof settings.outboundAttractionDistribution !== 'boolean')\r\n        return { message: 'the `outboundAttractionDistribution` setting should be a boolean.' };\r\n    if ('adjustSizes' in settings &&\r\n        typeof settings.adjustSizes !== 'boolean')\r\n        return { message: 'the `adjustSizes` setting should be a boolean.' };\r\n    if ('edgeWeightInfluence' in settings &&\r\n        typeof settings.edgeWeightInfluence !== 'number' &&\r\n        settings.edgeWeightInfluence < 0)\r\n        return { message: 'the `edgeWeightInfluence` setting should be a number >= 0.' };\r\n    if ('scalingRatio' in settings &&\r\n        typeof settings.scalingRatio !== 'number' &&\r\n        settings.scalingRatio < 0)\r\n        return { message: 'the `scalingRatio` setting should be a number >= 0.' };\r\n    if ('strongGravityMode' in settings &&\r\n        typeof settings.strongGravityMode !== 'boolean')\r\n        return { message: 'the `strongGravityMode` setting should be a boolean.' };\r\n    if ('gravity' in settings &&\r\n        typeof settings.gravity !== 'number' &&\r\n        settings.gravity < 0)\r\n        return { message: 'the `gravity` setting should be a number >= 0.' };\r\n    if ('slowDown' in settings &&\r\n        typeof settings.slowDown !== 'number' &&\r\n        settings.slowDown < 0)\r\n        return { message: 'the `slowDown` setting should be a number >= 0.' };\r\n    if ('barnesHutOptimize' in settings &&\r\n        typeof settings.barnesHutOptimize !== 'boolean')\r\n        return { message: 'the `barnesHutOptimize` setting should be a boolean.' };\r\n    if ('barnesHutTheta' in settings &&\r\n        typeof settings.barnesHutTheta !== 'number' &&\r\n        settings.barnesHutTheta < 0)\r\n        return { message: 'the `barnesHutTheta` setting should be a number >= 0.' };\r\n    return null;\r\n}\r\n;\r\n/**\r\n * Function generating a flat matrix for both nodes & edges of the given graph.\r\n *\r\n * @param  {Graph}  graph - Target graph.\r\n * @return {object}       - Both matrices.\r\n */\r\nfunction graphToByteArrays(graph) {\r\n    var nodes = graph.nodes(), edges = graph.edges(), order = nodes.length, size = edges.length, index = {}, i, j;\r\n    var NodeMatrix = new Float32Array(order * PPN), EdgeMatrix = new Float32Array(size * PPE);\r\n    // Iterate through nodes\r\n    for (i = j = 0; i < order; i++) {\r\n        // Node index\r\n        index[nodes[i]] = j;\r\n        // Populating byte array\r\n        NodeMatrix[j] = graph.getNodeAttribute(nodes[i], 'x');\r\n        NodeMatrix[j + 1] = graph.getNodeAttribute(nodes[i], 'y');\r\n        NodeMatrix[j + 2] = 0;\r\n        NodeMatrix[j + 3] = 0;\r\n        NodeMatrix[j + 4] = 0;\r\n        NodeMatrix[j + 5] = 0;\r\n        NodeMatrix[j + 6] = 1 + graph.degree(nodes[i]);\r\n        NodeMatrix[j + 7] = 1;\r\n        NodeMatrix[j + 8] = graph.getNodeAttribute(nodes[i], 'size') || 1;\r\n        NodeMatrix[j + 9] = 0;\r\n        j += PPN;\r\n    }\r\n    // Iterate through edges\r\n    for (i = j = 0; i < size; i++) {\r\n        // Populating byte array\r\n        EdgeMatrix[j] = index[graph.source(edges[i])];\r\n        EdgeMatrix[j + 1] = index[graph.target(edges[i])];\r\n        EdgeMatrix[j + 2] = graph.getEdgeAttribute(edges[i], 'weight') || 0;\r\n        j += PPE;\r\n    }\r\n    return {\r\n        nodes: NodeMatrix,\r\n        edges: EdgeMatrix\r\n    };\r\n}\r\n;\r\n/**\r\n * Function applying the layout back to the graph.\r\n *\r\n * @param {Graph}        graph      - Target graph.\r\n * @param {Float32Array} NodeMatrix - Node matrix.\r\n */\r\nfunction assignLayoutChanges(graph, NodeMatrix) {\r\n    var nodes = graph.nodes();\r\n    for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {\r\n        graph.setNodeAttribute(nodes[j], 'x', NodeMatrix[i]);\r\n        graph.setNodeAttribute(nodes[j], 'y', NodeMatrix[i + 1]);\r\n        j++;\r\n    }\r\n}\r\n;\r\n/**\r\n * Function collecting the layout positions.\r\n *\r\n * @param  {Graph}        graph      - Target graph.\r\n * @param  {Float32Array} NodeMatrix - Node matrix.\r\n * @return {object}                  - Map to node positions.\r\n */\r\nfunction collectLayoutChanges(graph, NodeMatrix) {\r\n    var nodes = graph.nodes(), positions = Object.create(null);\r\n    for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {\r\n        positions[nodes[j]] = {\r\n            x: NodeMatrix[i],\r\n            y: NodeMatrix[i + 1]\r\n        };\r\n        j++;\r\n    }\r\n    return positions;\r\n}\r\n;\r\nfunction assignH(target) {\r\n    target = target || {};\r\n    var objects = Array.prototype.slice.call(arguments).slice(1), i, k, l;\r\n    for (i = 0, l = objects.length; i < l; i++) {\r\n        if (!objects[i])\r\n            continue;\r\n        for (k in objects[i])\r\n            target[k] = objects[i][k];\r\n    }\r\n    return target;\r\n}\r\n;\r\nconst DEFAULT_SETTINGS = {\r\n    linLogMode: false,\r\n    outboundAttractionDistribution: false,\r\n    adjustSizes: false,\r\n    edgeWeightInfluence: 0,\r\n    scalingRatio: 1,\r\n    strongGravityMode: false,\r\n    gravity: 1,\r\n    slowDown: 1,\r\n    barnesHutOptimize: false,\r\n    barnesHutTheta: 0.5\r\n};\r\nfunction abstractSynchronousLayout(graph, params) {\r\n    let assign = null;\r\n    if (typeof params === 'number')\r\n        params = { iterations: params };\r\n    var iterations = params.iterations;\r\n    // Validating settings\r\n    var settings = assignH({}, DEFAULT_SETTINGS, params.settings), validationError = validateSettings(settings);\r\n    if (validationError)\r\n        throw new Error('graphology-layout-forceatlas2: ' + validationError.message);\r\n    // Building matrices\r\n    var matrices = graphToByteArrays(graph), i;\r\n    // Iterating\r\n    for (i = 0; i < iterations; i++)\r\n        iterate(settings, matrices.nodes, matrices.edges);\r\n    // Applying\r\n    if (assign) {\r\n        assignLayoutChanges(graph, matrices.nodes);\r\n        return;\r\n    }\r\n    return collectLayoutChanges(graph, matrices.nodes);\r\n}\r\nself.addEventListener('message', function (e) {\r\n    const nodes = e.data.nodes;\r\n    const edges = e.data.edges;\r\n    const params = e.data.params;\r\n    let graph = new Graph();\r\n    nodes.forEach(node => {\r\n        graph.addNode(node.meshIndex, {\r\n            x: node.x,\r\n            y: node.y\r\n        });\r\n    });\r\n    edges.forEach(edge => {\r\n        graph.addEdge(edge.source, edge.destination);\r\n    });\r\n    var iterations = params.iterations;\r\n    // Validating settings\r\n    var settings = assignH({}, DEFAULT_SETTINGS, params.settings), validationError = validateSettings(settings);\r\n    if (validationError)\r\n        throw new Error('graphology-layout-forceatlas2: ' + validationError.message);\r\n    // Building matrices\r\n    var matrices = graphToByteArrays(graph), i;\r\n    // Iterating\r\n    for (i = 0; i < iterations; i++) {\r\n        if (i % (iterations / 10) == 0) {\r\n            self.postMessage({\r\n                type: 'progress',\r\n                progress: (i / iterations) * 100\r\n            });\r\n        }\r\n        iterate(settings, matrices.nodes, matrices.edges);\r\n    }\r\n    let res = collectLayoutChanges(graph, matrices.nodes);\r\n    self.postMessage({\r\n        type: 'finish',\r\n        positions: res\r\n    });\r\n});\r\n"],"sourceRoot":""}