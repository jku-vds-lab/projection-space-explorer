{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/is-any-array/src/index.js","webpack:///./node_modules/ml-array-max/lib-es6/index.js","webpack:///./node_modules/ml-array-min/lib-es6/index.js","webpack:///./node_modules/ml-array-rescale/lib-es6/index.js","webpack:///./node_modules/ml-levenberg-marquardt/src/errorCalculation.js","webpack:///./node_modules/ml-levenberg-marquardt/src/index.js","webpack:///./node_modules/ml-levenberg-marquardt/src/step.js","webpack:///./node_modules/ml-matrix/src/abstractMatrix.js","webpack:///./node_modules/ml-matrix/src/dc/cholesky.js","webpack:///./node_modules/ml-matrix/src/dc/evd.js","webpack:///./node_modules/ml-matrix/src/dc/lu.js","webpack:///./node_modules/ml-matrix/src/dc/qr.js","webpack:///./node_modules/ml-matrix/src/dc/svd.js","webpack:///./node_modules/ml-matrix/src/dc/util.js","webpack:///./node_modules/ml-matrix/src/decompositions.js","webpack:///./node_modules/ml-matrix/src/index.js","webpack:///./node_modules/ml-matrix/src/linearDependencies.js","webpack:///./node_modules/ml-matrix/src/matrix.js","webpack:///./node_modules/ml-matrix/src/util.js","webpack:///./node_modules/ml-matrix/src/views/base.js","webpack:///./node_modules/ml-matrix/src/views/column.js","webpack:///./node_modules/ml-matrix/src/views/columnSelection.js","webpack:///./node_modules/ml-matrix/src/views/flipColumn.js","webpack:///./node_modules/ml-matrix/src/views/flipRow.js","webpack:///./node_modules/ml-matrix/src/views/row.js","webpack:///./node_modules/ml-matrix/src/views/rowSelection.js","webpack:///./node_modules/ml-matrix/src/views/selection.js","webpack:///./node_modules/ml-matrix/src/views/sub.js","webpack:///./node_modules/ml-matrix/src/views/transpose.js","webpack:///./node_modules/ml-matrix/src/wrap/WrapperMatrix1D.js","webpack:///./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js","webpack:///./node_modules/ml-matrix/src/wrap/wrap.js","webpack:///./node_modules/regenerator-runtime/runtime.js","webpack:///./src/components/Utility/UMAP/heap.ts","webpack:///./src/components/Utility/UMAP/index.ts","webpack:///./src/components/Utility/UMAP/matrix.ts","webpack:///./src/components/Utility/UMAP/nn_descent.ts","webpack:///./src/components/Utility/UMAP/tree.ts","webpack:///./src/components/Utility/UMAP/umap.ts","webpack:///./src/components/Utility/UMAP/utils.ts","webpack:///./src/components/workers/embeddings/worker_umap.ts"],"names":["Object","defineProperty","exports","value","smallestFlagged","deheapSort","buildCandidates","uncheckedHeapPush","heapPush","rejectionSample","makeHeap","utils","require","nPoints","size","makeArrays","fillValue","empty","map","filled","heap","push","Infinity","nSamples","poolSize","random","result","zeros","i","rejectSample","j","tauRandInt","broken","k","row","weight","index","flag","Math","floor","indices","weights","isNew","length","iSwap","ic1","ic2","heapShape2","currentGraph","nVertices","nNeighbors","maxCandidates","candidateNeighbors","idx","isn","d","tauRand","indHeap","distHeap","indHeapIndex","distHeapIndex","temp1","temp2","siftDown","heap1","heap2","ceiling","elt","leftChild","rightChild","swap","ind","dist","minDist","resultIndex","umap_1","enumerable","get","UMAP","getCSR","normalize","eliminateZeros","multiplyScalar","maximum","subtract","add","pairwiseMultiply","identity","transpose","SparseMatrix","rows","cols","values","dims","entries","Map","nRows","nCols","Error","col","checkDims","key","makeKey","set","withinBounds","has","defaultValue","ordered","rowColValues","forEach","sort","a","b","Array","from","fn","vals","getRows","getCols","output","matrix","elementWise","x","y","scalar","m","zeroIndices","Set","getValues","removeByZeroIndex","_","nextValues","filter","nextRows","nextCols","getDims","normType","normFn","normFns","colsByRow","nextMatrix","keys","norm","xs","max","sum","pow","sqrt","op","visited","operate","nextValue","valuesA","rowsA","colsA","valuesB","rowsB","colsB","indptr","currentRow","initializeSearch","makeInitializedNNSearch","makeInitializations","makeNNDescent","tree","distanceFn","nNDescent","data","leafArray","nIters","delta","rho","rpTreeInit","n","c","p","q","cj","ck","sorted","initFromRandom","queryPoints","_heap","initFromTree","_tree","searchFlatTree","nnSearchFn","graph","initialization","tried","vertex","candidates","slice","candidate","forest","results","makeLeafArray","makeForest","FlatTree","hyperplanes","offsets","children","nTrees","leafSize","trees","range","makeTree","flattenTree","makeEuclideanTree","splitResults","euclideanRandomProjectionSplit","indicesLeft","indicesRight","hyperplane","offset","node","isLeaf","dim","leftIndex","rightIndex","left","right","hyperplaneOffset","hyperplaneVector","nLeft","nRight","side","margin","nNodes","numNodes","nLeaves","numLeaves","recursiveFlatten","nodeNum","leafNum","splice","oldNodeNum","res","rpForest","selectSide","point","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","next","e","rejected","done","then","apply","initTransform","resetLocalConnectivity","fastIntersection","findABParams","cosine","euclidean","nnDescent","ml_levenberg_marquardt_1","SMOOTH_K_TOLERANCE","MIN_K_DIST_SCALE","params","learningRate","localConnectivity","nComponents","nEpochs","negativeSampleRate","repulsionStrength","setOpMixRatio","spread","transformQueueSize","targetMetric","targetWeight","targetNNeighbors","isInitialized","embedding","optimizationState","OptimizationState","setParam","undefined","X","initialEmbedding","initializeFit","optimizeLayout","callback","optimizeLayoutAsync","Y","knnIndices","knnDistances","getNEpochs","knnResults","nearestNeighbors","fuzzySimplicialSet","makeSearchFns","searchGraph","makeSearchGraph","processGraphForSupervisedProjection","initializeSimplicialSetEmbedding","head","tail","epochsPerSample","initializeOptimization","prepareForOptimizationLoop","search","knn","distances","neighbor","distance","toTransform","rawData","min","init","adjustedLocalConnectivity","smoothKNNDistance","sigmas","rhos","computeMembershipStrengths","normed","csrMatrix","eIndices","reshape2d","eWeights","graphMax","reduce","val","makeEpochsPerSample","assignOptimizationStateParameters","headEmbedding","tailEmbedding","currentEpoch","lt","farDist","categoricalSimplicialSetIntersection","optimizeLayoutStep","log2","log","metricNNDescent","round","sparseMatrix","prodMatrix","simplicialSet","target","unknownDist","intersection","nIter","bandwidth","lo","hi","mid","ithDistances","nonZeroDists","interpolation","psum","exp","abs","meanIthDistances","mean","meanDistances","graphValues","getAll","entry","w","state","assign","moveOther","epochsPerNegativeSample","epochOfNextNegativeSample","epochOfNextSample","initialAlpha","alpha","gamma","clipValue","current","other","distSquared","rDist","gradCoeff","gradD","clip","nNegSamples","epochCallback","epochCompleted","shouldStop","isFinished","setTimeout","normX","normY","curve","xv","linear","yv","gte","initialValues","options","damping","gradientDifference","maxIterations","errorTolerance","default","parameterValues","z","max2d","ones","vec","item","v","len","input","count","UMAP_1","self","addEventListener","context","messageType","raw","umap","seeded","seed","postMessage","getEmbedding"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFa;;AAEb;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAmC;;AAEnC;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;;AAEA;AACA,OAAO,mDAAO;AACd;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAEe,kEAAG,EAAC;;;;;;;;;;;;;AC1BnB;AAAA;AAAA;AAAmC;;AAEnC;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;;AAEA;AACA,OAAO,mDAAO;AACd;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAEe,kEAAG,EAAC;;;;;;;;;;;;;AC1BnB;AAAA;AAAA;AAAA;AAAA;AAAmC;AACJ;AACA;;AAE/B;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO,YAAY;AAC9B,WAAW,MAAM;AACjB;;AAEA;AACA;;AAEA,OAAO,mDAAO;AACd;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,SAAS,mDAAO;AAChB;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA,mBAAmB,4DAAG;AACtB,mBAAmB,4DAAG;;AAEtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;;AAEe,sEAAO,EAAC;;;;;;;;;;;;;ACzDvB;AAAA;AAAA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,cAAc;AACzB,WAAW,SAAS;AACpB,YAAY;AACZ;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAkD;AACxB;;AAE1B;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,iEAAgB;;AAE9B;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qDAAI;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;;AAEA,YAAY,iEAAgB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAA4C;;AAE5C;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA,aAAa,gDAAM;AACnB;;AAEA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,cAAc;AACzB,YAAY;AACZ;AACA;AACA;;AAEA;;AAEA,qBAAqB,WAAW;AAChC;AACA;;AAEA,aAAa,gDAAM;AACnB;;AAEA;AACA;AACA;AACA,YAAY,kCAAkC;AAC9C,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,YAAY;AACZ;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gDAAM;;AAEvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAO;AAC7B;AACA;;AAEA,eAAe,gDAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAuC;;AAED;AACC;AAKvB;AACoC;AACZ;AACA;AACY;AACM;AACM;AAClB;AACE;AACM;;AAEvC;AACf;;AAEA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,4BAA4B,qBAAqB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,SAAS;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,EAAE;AACrB,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,uBAAuB,eAAe;AACtC,yBAAyB,QAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;A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CA,mBAAmB,aAAa;AAChC,oBAAoB,OAAO;AAC3B;AACA;AACA,eAAe,+DAAiB;AAChC,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA,MAAM,2DAAa;AACnB,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA,MAAM,8DAAgB;AACtB,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,2DAAa;AACnB;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,2DAAa;AACnB;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,2DAAa;AACnB;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,2DAAa;AACnB;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,8DAAgB;AACtB;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,8DAAgB;AACtB;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,8DAAgB;AACtB;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,8DAAgB;AACtB;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA,iBAAiB,sDAAQ;AACzB;AACA,iBAAiB,yDAAW;AAC5B;AACA,iBAAiB,oDAAM;AACvB;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,uBAAuB,eAAe;AACtC,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA;AACA,OAAO;AACP,mDAAmD,KAAK;AACxD;AACA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B;AACA;;AAEA,uBAAuB,OAAO;AAC9B;AACA,qBAAqB,OAAO;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,GAAG,KAAK,GAAG,OAAO,GAAG,KAAK,GAAG;AACjE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,qBAAqB,gEAAO,kBAAkB,WAAW;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC,qBAAqB,gEAAO;AAC5B;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,OAAO;AAC5B,uBAAuB,OAAO;AAC9B,yBAAyB,OAAO;AAChC,2BAA2B,OAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,qBAAqB,eAAe;AACpC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,wDAAU;AAChB;AACA,4BAA4B,aAAa;AACzC,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,oBAAoB;AACzC,iCAAiC,gBAAgB;AACjD;AACA,4DAA4D,WAAW;AACvE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,MAAM;AACzB,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,oBAAoB;AACzC,8BAA8B,aAAa;AAC3C;AACA,+DAA+D,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,MAAM,wDAAU;AAChB,qBAAqB,iBAAiB;AACtC,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,cAAc;AACjC,oBAAoB,OAAO;AAC3B;AACA;AACA,oBAAoB,0DAAY;AAChC;AACA,qBAAqB,wBAAwB;AAC7C;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,iBAAiB,wDAAmB;AACpC;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,2DAAa;AACnB,iBAAiB,kDAAa;AAC9B;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,MAAM,8DAAgB;AACtB,iBAAiB,sDAAgB;AACjC;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,iBAAiB,uDAAiB;AAClC;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA,iBAAiB,0DAAoB;AACrC;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,mBAAmB,OAAO;AAC1B,oBAAoB;AACpB;AACA;AACA,iBAAiB,kDAAa;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,mBAAmB,cAAc;AACjC,oBAAoB;AACpB;AACA;AACA,iBAAiB,wDAAmB;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,oBAAoB;AACpB;AACA;AACA,iBAAiB,2DAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,oBAAoB;AACpB;AACA;AACA,iBAAiB,8DAAyB;AAC1C;;;AAGA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA,qBAAqB,8CAAe;AACpC;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,4BAA4B,+CAAe,QAAQ,sBAAsB;;AAEzE;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;;AAGA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA,iEAAiE,qCAAqC;AACtG,wEAAwE,UAAU,YAAY,qBAAqB;AACnH,wEAAwE,UAAU,YAAY,qBAAqB;AACnH,+DAA+D,oBAAoB;AACnF,eAAe,qBAAqB;AACpC;AACA,0BAA0B,YAAY;AACtC,0BAA0B,YAAY;AACtC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC,GAAG;;AAEH;AACA,iEAAiE,qCAAqC;AACtG,+DAA+D,kBAAkB;AACjF,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,eAAe,sBAAsB;AACrC,sBAAsB,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,iFAAiF,qCAAqC;AACtH,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA,4BAA4B,iBAAiB;AAC7C,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACx4DA;AAAA;AAAA;AAAmD;;AAEnD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACe;AACf;AACA,YAAY,sDAAe;AAC3B;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,6CAAM;AACtB;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,YAAY,sDAAe;;AAE3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B,iBAAiB,WAAW;AAC5B,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,QAAQ;AACnC,iBAAiB,WAAW;AAC5B,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChGA;AAAA;AAAA;AAAA;AAAmD;;AAEG;;AAEtD;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACe;AACf,kCAAkC;AAClC,WAAW,0BAA0B;;AAErC,aAAa,sDAAe;AAC5B;AACA;AACA;;AAEA;AACA,YAAY,8DAAgB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,cAAc,8DAAgB;AAC9B;AACA,iBAAiB,OAAO;AACxB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS,6CAAM;AACf,mBAAmB,6CAAM;AACzB;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAM;AACtB;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;;AAEA,iBAAiB,QAAQ;AACzB;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,wDAAU;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,cAAc,wDAAU;AACxB;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,aAAa,WAAW;AACxB;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,eAAe;AAClC;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,OAAO;AACxB;AACA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA,sBAAsB,QAAQ;AAC9B;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,OAAO;AACpB,eAAe,OAAO;AACtB;AACA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA,qBAAqB,WAAW;AAChC;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA,gCAAgC,QAAQ;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;;AAEA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,QAAQ;AACrB;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;;AAEA,kBAAkB,UAAU;AAC5B,iBAAiB,WAAW;AAC5B;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACryBA;AAAA;AAAA;AAAmD;;AAEnD;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACe;AACf;AACA,aAAa,sDAAe;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB;AACA;;AAEA;;AAEA,eAAe,aAAa;AAC5B,iBAAiB,UAAU;AAC3B;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc;AACd;AACA;AACA,YAAY,6CAAM;;AAElB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,aAAa;AAC5B,qBAAqB,aAAa;AAClC,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC,iBAAiB,WAAW;AAC5B;AACA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAM;AACtB,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAM;AACtB,mBAAmB,UAAU;AAC7B,qBAAqB,aAAa;AAClC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvMA;AAAA;AAAA;AAAA;AAAmD;;AAEf;;AAEpC;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACe;AACf;AACA,YAAY,sDAAe;;AAE3B;AACA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB;AACA,iBAAiB,OAAO;AACxB,cAAc,wDAAU;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,YAAY,6CAAM;;AAElB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,OAAO;AACtB,iBAAiB,WAAW;AAC5B;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B,iBAAiB,WAAW;AAC5B;AACA;AACA,iBAAiB,OAAO;AACxB,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,gBAAgB,6CAAM;AACtB;AACA,eAAe,OAAO;AACtB,iBAAiB,OAAO;AACxB;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAM;AACtB;;AAEA,yBAAyB,QAAQ;AACjC,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA,qBAAqB,UAAU;AAC/B;AACA;;AAEA;;AAEA,qBAAqB,UAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5KA;AAAA;AAAA;AAAA;AAAmD;;AAEG;;AAEtD;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACe;AACf,iCAAiC;AACjC,YAAY,sDAAe;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,YAAY,8DAAgB;AAC5B,YAAY,8DAAgB;;AAE5B;AACA;;AAEA;AACA,mBAAmB,QAAQ;;AAE3B;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;AACA,uBAAuB,OAAO;AAC9B,iBAAiB,wDAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,OAAO;AAChC;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,OAAO;AAClC,iBAAiB,wDAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA,6BAA6B,OAAO;AACpC,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA,6BAA6B,QAAQ;AACrC;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,2BAA2B,OAAO;AAClC;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA,yBAAyB,WAAW;AACpC;AACA;AACA,SAAS;AACT,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,QAAQ;AACjC;AACA,6BAA6B,OAAO;AACpC;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW;AACpC,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA,gBAAgB,wDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,OAAO;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA,aAAa,6CAAM;;AAEnB,mBAAmB,WAAW;AAC9B;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,6CAAM;;AAEpB,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc;AACd;AACA;AACA,sBAAsB,6CAAM;AAC5B;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAAM;;AAEtB,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gBAAgB,6CAAM;;AAEtB,mBAAmB,WAAW;AAC9B,qBAAqB,WAAW;AAChC;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS,6CAAM;AACf,mBAAmB,6CAAM;AACzB;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS,6CAAM;AACf,mBAAmB,6CAAM;AACzB;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW,6CAAM;AACjB;AACA;;;;;;;;;;;;;AC7kBA;AAAA;AAAA;AAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB,UAAU;AAC3B;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACA;AACY;;AAEA;;AAElD;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP,WAAW,sDAAe;AAC1B;AACA,eAAe,+CAA0B;AACzC,GAAG;AACH,yBAAyB,6CAAM;AAC/B;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP,iBAAiB,sDAAe;AAChC,kBAAkB,sDAAe;AACjC;AACA,eAAe,+CAA0B;AACzC,GAAG;AACH;AACA,YAAY,8CAAe;AAC3B,YAAY,8CAAe;AAC3B;AACA;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsD;AACO;;AAE1B;AACiC;AACA;;AAElB;AACQ;AAIrC;AAIA;AAIK;AAC6C;AACA;;;;;;;;;;;;;ACtBvE;AAAA;AAAA;AAAA;AAAA;AAA+B;;AAED;AACoB;;AAElD;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;;AAEO,gDAAgD;AACvD,SAAS,mDAAmD;;AAE5D;AACA,oBAAoB,+CAAM;;AAE1B,iBAAiB,OAAO;AACxB,YAAY,+CAAM;AAClB;AACA,kBAAkB,+CAA0B;AAC5C;AACA,gBAAgB,4DAAG;AACnB,MAAM,+CAAM;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtEA;AAAA;AAAA;AAAA;AAA8C;AAM9B;;AAED,qBAAqB,+DAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,IAAI,2DAAa;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,aAAa;AAC1B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAa;AACjB,YAAY,4DAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA,IAAI,8DAAgB;AACpB;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,aAAa;AAC1B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAgB;AACpB,YAAY,+DAAiB;AAC7B,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA8B;;AAE9B;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY;AACZ,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,YAAY;AACZ,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEO;AACP,YAAY,+CAAM;AAClB,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP,YAAY,+CAAM;AAClB,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,iBAAiB,iBAAiB;AAClC,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;;;;;;;;;;;;;AChLA;AAAA;AAAA;AAAA;AAA+C;AAChB;;AAEhB,uBAAuB,+DAAc;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,+CAAM;AACjB;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAA8B;;AAEf,+BAA+B,6CAAQ;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAA6C;;AAEf;;AAEf,wCAAwC,6CAAQ;AAC/D;AACA,oBAAoB,gEAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAA8B;;AAEf,mCAAmC,6CAAQ;AAC1D;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAA8B;;AAEf,gCAAgC,6CAAQ;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAA8B;;AAEf,4BAA4B,6CAAQ;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAA0C;;AAEZ;;AAEf,qCAAqC,6CAAQ;AAC5D;AACA,iBAAiB,6DAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAuC;;AAET;;AAEf,kCAAkC,6CAAQ;AACzD;AACA,kBAAkB,0DAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAqC;;AAEP;;AAEf,4BAA4B,6CAAQ;AACnD;AACA,IAAI,wDAAU;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAA8B;;AAEf,kCAAkC,6CAAQ;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAA+C;AAChB;;AAEhB,8BAA8B,+DAAc;AAC3D;AACA;AACA,aAAa,cAAc;AAC3B,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,gCAAgC;AAChC,WAAW,WAAW;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,+CAAM;AACjB;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAA+C;AAChB;;AAEhB,8BAA8B,+DAAc;AAC3D;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,+CAAM;AACjB;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAgD;AACA;;AAEhD;AACA,WAAW,mCAAmC;AAC9C,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;AACP;AACA;AACA,iBAAiB,wDAAe;AAChC,KAAK;AACL,iBAAiB,wDAAe;AAChC;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA,EAAE,KAA0B,oBAAoB,SAAE;AAClD;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxtBa;AACb;;;;;;;;;;;;;;;;;;;AAkBAA,MA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","file":"umap.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/components/workers/embeddings/worker_umap.ts\");\n","'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the maximum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction max(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var maxValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\nexport default max;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the minimum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction min(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var minValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\nexport default min;\n","import isArray from 'is-any-array';\nimport max from 'ml-array-max';\nimport min from 'ml-array-min';\n\n/**\n *\n * @param {Array} input\n * @param {object} [options={}]\n * @param {Array} [options.output=[]] specify the output array, can be the input array for in place modification\n */\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!isArray(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = min(input);\n  var currentMax = max(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\nexport default rescale;\n","/**\n * Calculate current error\n * @ignore\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {Array<number>} parameters - Array of current parameter values\n * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter\n * @return {number}\n */\nexport default function errorCalculation(\n  data,\n  parameters,\n  parameterizedFunction\n) {\n  var error = 0;\n  const func = parameterizedFunction(parameters);\n\n  for (var i = 0; i < data.x.length; i++) {\n    error += Math.abs(data.y[i] - func(data.x[i]));\n  }\n\n  return error;\n}\n","import errorCalculation from './errorCalculation';\nimport step from './step';\n\n/**\n * Curve fitting algorithm\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter\n * @param {object} [options] - Options object\n * @param {number} [options.damping] - Levenberg-Marquardt parameter\n * @param {number} [options.gradientDifference = 10e-2] - Adjustment for decrease the damping parameter\n * @param {Array<number>} [options.minValues] - Minimum allowed values for parameters\n * @param {Array<number>} [options.maxValues] - Maximum allowed values for parameters\n * @param {Array<number>} [options.initialValues] - Array of initial parameter values\n * @param {number} [options.maxIterations = 100] - Maximum of allowed iterations\n * @param {number} [options.errorTolerance = 10e-3] - Minimum uncertainty allowed for each point\n * @return {{parameterValues: Array<number>, parameterError: number, iterations: number}}\n */\nexport default function levenbergMarquardt(\n  data,\n  parameterizedFunction,\n  options = {}\n) {\n  let {\n    maxIterations = 100,\n    gradientDifference = 10e-2,\n    damping = 0,\n    errorTolerance = 10e-3,\n    minValues,\n    maxValues,\n    initialValues\n  } = options;\n\n  if (damping <= 0) {\n    throw new Error('The damping option must be a positive number');\n  } else if (!data.x || !data.y) {\n    throw new Error('The data parameter must have x and y elements');\n  } else if (\n    !Array.isArray(data.x) ||\n    data.x.length < 2 ||\n    !Array.isArray(data.y) ||\n    data.y.length < 2\n  ) {\n    throw new Error(\n      'The data parameter elements must be an array with more than 2 points'\n    );\n  } else if (data.x.length !== data.y.length) {\n    throw new Error('The data parameter elements must have the same size');\n  }\n\n  var parameters =\n    initialValues || new Array(parameterizedFunction.length).fill(1);\n  let parLen = parameters.length;\n  maxValues = maxValues || new Array(parLen).fill(Number.MAX_SAFE_INTEGER);\n  minValues = minValues || new Array(parLen).fill(Number.MIN_SAFE_INTEGER);\n\n  if (maxValues.length !== minValues.length) {\n    throw new Error('minValues and maxValues must be the same size');\n  }\n\n  if (!Array.isArray(parameters)) {\n    throw new Error('initialValues must be an array');\n  }\n\n  var error = errorCalculation(data, parameters, parameterizedFunction);\n\n  var converged = error <= errorTolerance;\n\n  for (\n    var iteration = 0;\n    iteration < maxIterations && !converged;\n    iteration++\n  ) {\n    parameters = step(\n      data,\n      parameters,\n      damping,\n      gradientDifference,\n      parameterizedFunction\n    );\n\n    for (let k = 0; k < parLen; k++) {\n      parameters[k] = Math.min(\n        Math.max(minValues[k], parameters[k]),\n        maxValues[k]\n      );\n    }\n\n    error = errorCalculation(data, parameters, parameterizedFunction);\n    if (isNaN(error)) break;\n    converged = error <= errorTolerance;\n  }\n\n  return {\n    parameterValues: parameters,\n    parameterError: error,\n    iterations: iteration\n  };\n}\n","import { inverse, Matrix } from 'ml-matrix';\n\n/**\n * Difference of the matrix function over the parameters\n * @ignore\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {Array<number>} evaluatedData - Array of previous evaluated function values\n * @param {Array<number>} params - Array of previous parameter values\n * @param {number} gradientDifference - Adjustment for decrease the damping parameter\n * @param {function} paramFunction - The parameters and returns a function with the independent variable as a parameter\n * @return {Matrix}\n */\nfunction gradientFunction(\n  data,\n  evaluatedData,\n  params,\n  gradientDifference,\n  paramFunction\n) {\n  const n = params.length;\n  const m = data.x.length;\n\n  var ans = new Array(n);\n\n  for (var param = 0; param < n; param++) {\n    ans[param] = new Array(m);\n    var auxParams = params.concat();\n    auxParams[param] += gradientDifference;\n    var funcParam = paramFunction(auxParams);\n\n    for (var point = 0; point < m; point++) {\n      ans[param][point] = evaluatedData[point] - funcParam(data.x[point]);\n    }\n  }\n  return new Matrix(ans);\n}\n\n/**\n * Matrix function over the samples\n * @ignore\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {Array<number>} evaluatedData - Array of previous evaluated function values\n * @return {Matrix}\n */\nfunction matrixFunction(data, evaluatedData) {\n  const m = data.x.length;\n\n  var ans = new Array(m);\n\n  for (var point = 0; point < m; point++) {\n    ans[point] = [data.y[point] - evaluatedData[point]];\n  }\n\n  return new Matrix(ans);\n}\n\n/**\n * Iteration for Levenberg-Marquardt\n * @ignore\n * @param {{x:Array<number>, y:Array<number>}} data - Array of points to fit in the format [x1, x2, ... ], [y1, y2, ... ]\n * @param {Array<number>} params - Array of previous parameter values\n * @param {number} damping - Levenberg-Marquardt parameter\n * @param {number} gradientDifference - Adjustment for decrease the damping parameter\n * @param {function} parameterizedFunction - The parameters and returns a function with the independent variable as a parameter\n * @return {Array<number>}\n */\nexport default function step(\n  data,\n  params,\n  damping,\n  gradientDifference,\n  parameterizedFunction\n) {\n  var value = damping * gradientDifference * gradientDifference;\n  var identity = Matrix.eye(params.length, params.length, value);\n\n  const func = parameterizedFunction(params);\n  var evaluatedData = data.x.map((e) => func(e));\n\n  var gradientFunc = gradientFunction(\n    data,\n    evaluatedData,\n    params,\n    gradientDifference,\n    parameterizedFunction\n  );\n  var matrixFunc = matrixFunction(data, evaluatedData);\n  var inverseMatrix = inverse(\n    identity.add(gradientFunc.mmul(gradientFunc.transpose()))\n  );\n\n  params = new Matrix([params]);\n  params = params.sub(\n    inverseMatrix\n      .mmul(gradientFunc)\n      .mmul(matrixFunc)\n      .mul(gradientDifference)\n      .transpose()\n  );\n\n  return params.to1DArray();\n}\n","import rescale from 'ml-array-rescale';\r\n\r\nimport LuDecomposition from './dc/lu';\r\nimport SvDecomposition from './dc/svd';\r\nimport {\r\n  checkRowVector, checkRowIndex, checkColumnIndex, checkColumnVector,\r\n  checkRange, checkIndices,\r\n  sumByRow, sumByColumn, sumAll\r\n} from './util';\r\nimport MatrixTransposeView from './views/transpose';\r\nimport MatrixRowView from './views/row';\r\nimport MatrixSubView from './views/sub';\r\nimport MatrixSelectionView from './views/selection';\r\nimport MatrixRowSelectionView from './views/rowSelection';\r\nimport MatrixColumnSelectionView from './views/columnSelection';\r\nimport MatrixColumnView from './views/column';\r\nimport MatrixFlipRowView from './views/flipRow';\r\nimport MatrixFlipColumnView from './views/flipColumn';\r\n\r\nexport default function AbstractMatrix(superCtor) {\r\n  if (superCtor === undefined) superCtor = Object;\r\n\r\n  /**\r\n   * Real matrix\r\n   * @class Matrix\r\n   * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,\r\n   * 2D array containing the data or Matrix instance to clone\r\n   * @param {number} [nColumns] - Number of columns of the new matrix\r\n   */\r\n  class Matrix extends superCtor {\r\n    static get [Symbol.species]() {\r\n      return this;\r\n    }\r\n\r\n    /**\r\n     * Constructs a Matrix with the chosen dimensions from a 1D array\r\n     * @param {number} newRows - Number of rows\r\n     * @param {number} newColumns - Number of columns\r\n     * @param {Array} newData - A 1D array containing data for the matrix\r\n     * @return {Matrix} - The new matrix\r\n     */\r\n    static from1DArray(newRows, newColumns, newData) {\r\n      var length = newRows * newColumns;\r\n      if (length !== newData.length) {\r\n        throw new RangeError('Data length does not match given dimensions');\r\n      }\r\n      var newMatrix = new this(newRows, newColumns);\r\n      for (var row = 0; row < newRows; row++) {\r\n        for (var column = 0; column < newColumns; column++) {\r\n          newMatrix.set(row, column, newData[row * newColumns + column]);\r\n        }\r\n      }\r\n      return newMatrix;\r\n    }\r\n\r\n    /**\r\n         * Creates a row vector, a matrix with only one row.\r\n         * @param {Array} newData - A 1D array containing data for the vector\r\n         * @return {Matrix} - The new matrix\r\n         */\r\n    static rowVector(newData) {\r\n      var vector = new this(1, newData.length);\r\n      for (var i = 0; i < newData.length; i++) {\r\n        vector.set(0, i, newData[i]);\r\n      }\r\n      return vector;\r\n    }\r\n\r\n    /**\r\n         * Creates a column vector, a matrix with only one column.\r\n         * @param {Array} newData - A 1D array containing data for the vector\r\n         * @return {Matrix} - The new matrix\r\n         */\r\n    static columnVector(newData) {\r\n      var vector = new this(newData.length, 1);\r\n      for (var i = 0; i < newData.length; i++) {\r\n        vector.set(i, 0, newData[i]);\r\n      }\r\n      return vector;\r\n    }\r\n\r\n    /**\r\n         * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).\r\n         * @param {number} rows - Number of rows\r\n         * @param {number} columns - Number of columns\r\n         * @return {Matrix} - The new matrix\r\n         */\r\n    static empty(rows, columns) {\r\n      return new this(rows, columns);\r\n    }\r\n\r\n    /**\r\n         * Creates a matrix with the given dimensions. Values will be set to zero.\r\n         * @param {number} rows - Number of rows\r\n         * @param {number} columns - Number of columns\r\n         * @return {Matrix} - The new matrix\r\n         */\r\n    static zeros(rows, columns) {\r\n      return this.empty(rows, columns).fill(0);\r\n    }\r\n\r\n    /**\r\n         * Creates a matrix with the given dimensions. Values will be set to one.\r\n         * @param {number} rows - Number of rows\r\n         * @param {number} columns - Number of columns\r\n         * @return {Matrix} - The new matrix\r\n         */\r\n    static ones(rows, columns) {\r\n      return this.empty(rows, columns).fill(1);\r\n    }\r\n\r\n    /**\r\n         * Creates a matrix with the given dimensions. Values will be randomly set.\r\n         * @param {number} rows - Number of rows\r\n         * @param {number} columns - Number of columns\r\n         * @param {function} [rng=Math.random] - Random number generator\r\n         * @return {Matrix} The new matrix\r\n         */\r\n    static rand(rows, columns, rng) {\r\n      if (rng === undefined) rng = Math.random;\r\n      var matrix = this.empty(rows, columns);\r\n      for (var i = 0; i < rows; i++) {\r\n        for (var j = 0; j < columns; j++) {\r\n          matrix.set(i, j, rng());\r\n        }\r\n      }\r\n      return matrix;\r\n    }\r\n\r\n    /**\r\n         * Creates a matrix with the given dimensions. Values will be random integers.\r\n         * @param {number} rows - Number of rows\r\n         * @param {number} columns - Number of columns\r\n         * @param {number} [maxValue=1000] - Maximum value\r\n         * @param {function} [rng=Math.random] - Random number generator\r\n         * @return {Matrix} The new matrix\r\n         */\r\n    static randInt(rows, columns, maxValue, rng) {\r\n      if (maxValue === undefined) maxValue = 1000;\r\n      if (rng === undefined) rng = Math.random;\r\n      var matrix = this.empty(rows, columns);\r\n      for (var i = 0; i < rows; i++) {\r\n        for (var j = 0; j < columns; j++) {\r\n          var value = Math.floor(rng() * maxValue);\r\n          matrix.set(i, j, value);\r\n        }\r\n      }\r\n      return matrix;\r\n    }\r\n\r\n    /**\r\n         * Creates an identity matrix with the given dimension. Values of the diagonal will be 1 and others will be 0.\r\n         * @param {number} rows - Number of rows\r\n         * @param {number} [columns=rows] - Number of columns\r\n         * @param {number} [value=1] - Value to fill the diagonal with\r\n         * @return {Matrix} - The new identity matrix\r\n         */\r\n    static eye(rows, columns, value) {\r\n      if (columns === undefined) columns = rows;\r\n      if (value === undefined) value = 1;\r\n      var min = Math.min(rows, columns);\r\n      var matrix = this.zeros(rows, columns);\r\n      for (var i = 0; i < min; i++) {\r\n        matrix.set(i, i, value);\r\n      }\r\n      return matrix;\r\n    }\r\n\r\n    /**\r\n         * Creates a diagonal matrix based on the given array.\r\n         * @param {Array} data - Array containing the data for the diagonal\r\n         * @param {number} [rows] - Number of rows (Default: data.length)\r\n         * @param {number} [columns] - Number of columns (Default: rows)\r\n         * @return {Matrix} - The new diagonal matrix\r\n         */\r\n    static diag(data, rows, columns) {\r\n      var l = data.length;\r\n      if (rows === undefined) rows = l;\r\n      if (columns === undefined) columns = rows;\r\n      var min = Math.min(l, rows, columns);\r\n      var matrix = this.zeros(rows, columns);\r\n      for (var i = 0; i < min; i++) {\r\n        matrix.set(i, i, data[i]);\r\n      }\r\n      return matrix;\r\n    }\r\n\r\n    /**\r\n         * Returns a matrix whose elements are the minimum between matrix1 and matrix2\r\n         * @param {Matrix} matrix1\r\n         * @param {Matrix} matrix2\r\n         * @return {Matrix}\r\n         */\r\n    static min(matrix1, matrix2) {\r\n      matrix1 = this.checkMatrix(matrix1);\r\n      matrix2 = this.checkMatrix(matrix2);\r\n      var rows = matrix1.rows;\r\n      var columns = matrix1.columns;\r\n      var result = new this(rows, columns);\r\n      for (var i = 0; i < rows; i++) {\r\n        for (var j = 0; j < columns; j++) {\r\n          result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n         * Returns a matrix whose elements are the maximum between matrix1 and matrix2\r\n         * @param {Matrix} matrix1\r\n         * @param {Matrix} matrix2\r\n         * @return {Matrix}\r\n         */\r\n    static max(matrix1, matrix2) {\r\n      matrix1 = this.checkMatrix(matrix1);\r\n      matrix2 = this.checkMatrix(matrix2);\r\n      var rows = matrix1.rows;\r\n      var columns = matrix1.columns;\r\n      var result = new this(rows, columns);\r\n      for (var i = 0; i < rows; i++) {\r\n        for (var j = 0; j < columns; j++) {\r\n          result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n         * Check that the provided value is a Matrix and tries to instantiate one if not\r\n         * @param {*} value - The value to check\r\n         * @return {Matrix}\r\n         */\r\n    static checkMatrix(value) {\r\n      return Matrix.isMatrix(value) ? value : new this(value);\r\n    }\r\n\r\n    /**\r\n         * Returns true if the argument is a Matrix, false otherwise\r\n         * @param {*} value - The value to check\r\n         * @return {boolean}\r\n         */\r\n    static isMatrix(value) {\r\n      return (value != null) && (value.klass === 'Matrix');\r\n    }\r\n\r\n    /**\r\n         * @prop {number} size - The number of elements in the matrix.\r\n         */\r\n    get size() {\r\n      return this.rows * this.columns;\r\n    }\r\n\r\n    /**\r\n         * Applies a callback for each element of the matrix. The function is called in the matrix (this) context.\r\n         * @param {function} callback - Function that will be called with two parameters : i (row) and j (column)\r\n         * @return {Matrix} this\r\n         */\r\n    apply(callback) {\r\n      if (typeof callback !== 'function') {\r\n        throw new TypeError('callback must be a function');\r\n      }\r\n      var ii = this.rows;\r\n      var jj = this.columns;\r\n      for (var i = 0; i < ii; i++) {\r\n        for (var j = 0; j < jj; j++) {\r\n          callback.call(this, i, j);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Returns a new 1D array filled row by row with the matrix values\r\n         * @return {Array}\r\n         */\r\n    to1DArray() {\r\n      var array = new Array(this.size);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          array[i * this.columns + j] = this.get(i, j);\r\n        }\r\n      }\r\n      return array;\r\n    }\r\n\r\n    /**\r\n         * Returns a 2D array containing a copy of the data\r\n         * @return {Array}\r\n         */\r\n    to2DArray() {\r\n      var copy = new Array(this.rows);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        copy[i] = new Array(this.columns);\r\n        for (var j = 0; j < this.columns; j++) {\r\n          copy[i][j] = this.get(i, j);\r\n        }\r\n      }\r\n      return copy;\r\n    }\r\n\r\n    /**\r\n         * @return {boolean} true if the matrix has one row\r\n         */\r\n    isRowVector() {\r\n      return this.rows === 1;\r\n    }\r\n\r\n    /**\r\n         * @return {boolean} true if the matrix has one column\r\n         */\r\n    isColumnVector() {\r\n      return this.columns === 1;\r\n    }\r\n\r\n    /**\r\n         * @return {boolean} true if the matrix has one row or one column\r\n         */\r\n    isVector() {\r\n      return (this.rows === 1) || (this.columns === 1);\r\n    }\r\n\r\n    /**\r\n         * @return {boolean} true if the matrix has the same number of rows and columns\r\n         */\r\n    isSquare() {\r\n      return this.rows === this.columns;\r\n    }\r\n\r\n    /**\r\n         * @return {boolean} true if the matrix is square and has the same values on both sides of the diagonal\r\n         */\r\n    isSymmetric() {\r\n      if (this.isSquare()) {\r\n        for (var i = 0; i < this.rows; i++) {\r\n          for (var j = 0; j <= i; j++) {\r\n            if (this.get(i, j) !== this.get(j, i)) {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    /**\r\n          * @return true if the matrix is in echelon form\r\n          */\r\n    isEchelonForm() {\r\n      let i = 0;\r\n      let j = 0;\r\n      let previousColumn = -1;\r\n      let isEchelonForm = true;\r\n      let checked = false;\r\n      while ((i < this.rows) && (isEchelonForm)) {\r\n        j = 0;\r\n        checked = false;\r\n        while ((j < this.columns) && (checked === false)) {\r\n          if (this.get(i, j) === 0) {\r\n            j++;\r\n          } else if ((this.get(i, j) === 1) && (j > previousColumn)) {\r\n            checked = true;\r\n            previousColumn = j;\r\n          } else {\r\n            isEchelonForm = false;\r\n            checked = true;\r\n          }\r\n        }\r\n        i++;\r\n      }\r\n      return isEchelonForm;\r\n    }\r\n\r\n    /**\r\n             * @return true if the matrix is in reduced echelon form\r\n             */\r\n    isReducedEchelonForm() {\r\n      let i = 0;\r\n      let j = 0;\r\n      let previousColumn = -1;\r\n      let isReducedEchelonForm = true;\r\n      let checked = false;\r\n      while ((i < this.rows) && (isReducedEchelonForm)) {\r\n        j = 0;\r\n        checked = false;\r\n        while ((j < this.columns) && (checked === false)) {\r\n          if (this.get(i, j) === 0) {\r\n            j++;\r\n          } else if ((this.get(i, j) === 1) && (j > previousColumn)) {\r\n            checked = true;\r\n            previousColumn = j;\r\n          } else {\r\n            isReducedEchelonForm = false;\r\n            checked = true;\r\n          }\r\n        }\r\n        for (let k = j + 1; k < this.rows; k++) {\r\n          if (this.get(i, k) !== 0) {\r\n            isReducedEchelonForm = false;\r\n          }\r\n        }\r\n        i++;\r\n      }\r\n      return isReducedEchelonForm;\r\n    }\r\n\r\n    /**\r\n         * Sets a given element of the matrix. mat.set(3,4,1) is equivalent to mat[3][4]=1\r\n         * @abstract\r\n         * @param {number} rowIndex - Index of the row\r\n         * @param {number} columnIndex - Index of the column\r\n         * @param {number} value - The new value for the element\r\n         * @return {Matrix} this\r\n         */\r\n    set(rowIndex, columnIndex, value) { // eslint-disable-line no-unused-vars\r\n      throw new Error('set method is unimplemented');\r\n    }\r\n\r\n    /**\r\n         * Returns the given element of the matrix. mat.get(3,4) is equivalent to matrix[3][4]\r\n         * @abstract\r\n         * @param {number} rowIndex - Index of the row\r\n         * @param {number} columnIndex - Index of the column\r\n         * @return {number}\r\n         */\r\n    get(rowIndex, columnIndex) { // eslint-disable-line no-unused-vars\r\n      throw new Error('get method is unimplemented');\r\n    }\r\n\r\n    /**\r\n         * Creates a new matrix that is a repetition of the current matrix. New matrix has rowRep times the number of\r\n         * rows of the matrix, and colRep times the number of columns of the matrix\r\n         * @param {number} rowRep - Number of times the rows should be repeated\r\n         * @param {number} colRep - Number of times the columns should be re\r\n         * @return {Matrix}\r\n         * @example\r\n         * var matrix = new Matrix([[1,2]]);\r\n         * matrix.repeat(2); // [[1,2],[1,2]]\r\n         */\r\n    repeat(rowRep, colRep) {\r\n      rowRep = rowRep || 1;\r\n      colRep = colRep || 1;\r\n      var matrix = new this.constructor[Symbol.species](this.rows * rowRep, this.columns * colRep);\r\n      for (var i = 0; i < rowRep; i++) {\r\n        for (var j = 0; j < colRep; j++) {\r\n          matrix.setSubMatrix(this, this.rows * i, this.columns * j);\r\n        }\r\n      }\r\n      return matrix;\r\n    }\r\n\r\n    /**\r\n         * Fills the matrix with a given value. All elements will be set to this value.\r\n         * @param {number} value - New value\r\n         * @return {Matrix} this\r\n         */\r\n    fill(value) {\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, value);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Negates the matrix. All elements will be multiplied by (-1)\r\n         * @return {Matrix} this\r\n         */\r\n    neg() {\r\n      return this.mulS(-1);\r\n    }\r\n\r\n    /**\r\n         * Returns a new array from the given row index\r\n         * @param {number} index - Row index\r\n         * @return {Array}\r\n         */\r\n    getRow(index) {\r\n      checkRowIndex(this, index);\r\n      var row = new Array(this.columns);\r\n      for (var i = 0; i < this.columns; i++) {\r\n        row[i] = this.get(index, i);\r\n      }\r\n      return row;\r\n    }\r\n\r\n    /**\r\n         * Returns a new row vector from the given row index\r\n         * @param {number} index - Row index\r\n         * @return {Matrix}\r\n         */\r\n    getRowVector(index) {\r\n      return this.constructor.rowVector(this.getRow(index));\r\n    }\r\n\r\n    /**\r\n         * Sets a row at the given index\r\n         * @param {number} index - Row index\r\n         * @param {Array|Matrix} array - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    setRow(index, array) {\r\n      checkRowIndex(this, index);\r\n      array = checkRowVector(this, array);\r\n      for (var i = 0; i < this.columns; i++) {\r\n        this.set(index, i, array[i]);\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Swaps two rows\r\n         * @param {number} row1 - First row index\r\n         * @param {number} row2 - Second row index\r\n         * @return {Matrix} this\r\n         */\r\n    swapRows(row1, row2) {\r\n      checkRowIndex(this, row1);\r\n      checkRowIndex(this, row2);\r\n      for (var i = 0; i < this.columns; i++) {\r\n        var temp = this.get(row1, i);\r\n        this.set(row1, i, this.get(row2, i));\r\n        this.set(row2, i, temp);\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Returns a new array from the given column index\r\n         * @param {number} index - Column index\r\n         * @return {Array}\r\n         */\r\n    getColumn(index) {\r\n      checkColumnIndex(this, index);\r\n      var column = new Array(this.rows);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        column[i] = this.get(i, index);\r\n      }\r\n      return column;\r\n    }\r\n\r\n    /**\r\n         * Returns a new column vector from the given column index\r\n         * @param {number} index - Column index\r\n         * @return {Matrix}\r\n         */\r\n    getColumnVector(index) {\r\n      return this.constructor.columnVector(this.getColumn(index));\r\n    }\r\n\r\n    /**\r\n         * Sets a column at the given index\r\n         * @param {number} index - Column index\r\n         * @param {Array|Matrix} array - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    setColumn(index, array) {\r\n      checkColumnIndex(this, index);\r\n      array = checkColumnVector(this, array);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        this.set(i, index, array[i]);\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Swaps two columns\r\n         * @param {number} column1 - First column index\r\n         * @param {number} column2 - Second column index\r\n         * @return {Matrix} this\r\n         */\r\n    swapColumns(column1, column2) {\r\n      checkColumnIndex(this, column1);\r\n      checkColumnIndex(this, column2);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        var temp = this.get(i, column1);\r\n        this.set(i, column1, this.get(i, column2));\r\n        this.set(i, column2, temp);\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Adds the values of a vector to each row\r\n         * @param {Array|Matrix} vector - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    addRowVector(vector) {\r\n      vector = checkRowVector(this, vector);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, this.get(i, j) + vector[j]);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Subtracts the values of a vector from each row\r\n         * @param {Array|Matrix} vector - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    subRowVector(vector) {\r\n      vector = checkRowVector(this, vector);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, this.get(i, j) - vector[j]);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Multiplies the values of a vector with each row\r\n         * @param {Array|Matrix} vector - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    mulRowVector(vector) {\r\n      vector = checkRowVector(this, vector);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, this.get(i, j) * vector[j]);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Divides the values of each row by those of a vector\r\n         * @param {Array|Matrix} vector - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    divRowVector(vector) {\r\n      vector = checkRowVector(this, vector);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, this.get(i, j) / vector[j]);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Adds the values of a vector to each column\r\n         * @param {Array|Matrix} vector - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    addColumnVector(vector) {\r\n      vector = checkColumnVector(this, vector);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, this.get(i, j) + vector[i]);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Subtracts the values of a vector from each column\r\n         * @param {Array|Matrix} vector - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    subColumnVector(vector) {\r\n      vector = checkColumnVector(this, vector);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, this.get(i, j) - vector[i]);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Multiplies the values of a vector with each column\r\n         * @param {Array|Matrix} vector - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    mulColumnVector(vector) {\r\n      vector = checkColumnVector(this, vector);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, this.get(i, j) * vector[i]);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Divides the values of each column by those of a vector\r\n         * @param {Array|Matrix} vector - Array or vector\r\n         * @return {Matrix} this\r\n         */\r\n    divColumnVector(vector) {\r\n      vector = checkColumnVector(this, vector);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          this.set(i, j, this.get(i, j) / vector[i]);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Multiplies the values of a row with a scalar\r\n         * @param {number} index - Row index\r\n         * @param {number} value\r\n         * @return {Matrix} this\r\n         */\r\n    mulRow(index, value) {\r\n      checkRowIndex(this, index);\r\n      for (var i = 0; i < this.columns; i++) {\r\n        this.set(index, i, this.get(index, i) * value);\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Multiplies the values of a column with a scalar\r\n         * @param {number} index - Column index\r\n         * @param {number} value\r\n         * @return {Matrix} this\r\n         */\r\n    mulColumn(index, value) {\r\n      checkColumnIndex(this, index);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        this.set(i, index, this.get(i, index) * value);\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Returns the maximum value of the matrix\r\n         * @return {number}\r\n         */\r\n    max() {\r\n      var v = this.get(0, 0);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          if (this.get(i, j) > v) {\r\n            v = this.get(i, j);\r\n          }\r\n        }\r\n      }\r\n      return v;\r\n    }\r\n\r\n    /**\r\n         * Returns the index of the maximum value\r\n         * @return {Array}\r\n         */\r\n    maxIndex() {\r\n      var v = this.get(0, 0);\r\n      var idx = [0, 0];\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          if (this.get(i, j) > v) {\r\n            v = this.get(i, j);\r\n            idx[0] = i;\r\n            idx[1] = j;\r\n          }\r\n        }\r\n      }\r\n      return idx;\r\n    }\r\n\r\n    /**\r\n         * Returns the minimum value of the matrix\r\n         * @return {number}\r\n         */\r\n    min() {\r\n      var v = this.get(0, 0);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          if (this.get(i, j) < v) {\r\n            v = this.get(i, j);\r\n          }\r\n        }\r\n      }\r\n      return v;\r\n    }\r\n\r\n    /**\r\n         * Returns the index of the minimum value\r\n         * @return {Array}\r\n         */\r\n    minIndex() {\r\n      var v = this.get(0, 0);\r\n      var idx = [0, 0];\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          if (this.get(i, j) < v) {\r\n            v = this.get(i, j);\r\n            idx[0] = i;\r\n            idx[1] = j;\r\n          }\r\n        }\r\n      }\r\n      return idx;\r\n    }\r\n\r\n    /**\r\n         * Returns the maximum value of one row\r\n         * @param {number} row - Row index\r\n         * @return {number}\r\n         */\r\n    maxRow(row) {\r\n      checkRowIndex(this, row);\r\n      var v = this.get(row, 0);\r\n      for (var i = 1; i < this.columns; i++) {\r\n        if (this.get(row, i) > v) {\r\n          v = this.get(row, i);\r\n        }\r\n      }\r\n      return v;\r\n    }\r\n\r\n    /**\r\n         * Returns the index of the maximum value of one row\r\n         * @param {number} row - Row index\r\n         * @return {Array}\r\n         */\r\n    maxRowIndex(row) {\r\n      checkRowIndex(this, row);\r\n      var v = this.get(row, 0);\r\n      var idx = [row, 0];\r\n      for (var i = 1; i < this.columns; i++) {\r\n        if (this.get(row, i) > v) {\r\n          v = this.get(row, i);\r\n          idx[1] = i;\r\n        }\r\n      }\r\n      return idx;\r\n    }\r\n\r\n    /**\r\n         * Returns the minimum value of one row\r\n         * @param {number} row - Row index\r\n         * @return {number}\r\n         */\r\n    minRow(row) {\r\n      checkRowIndex(this, row);\r\n      var v = this.get(row, 0);\r\n      for (var i = 1; i < this.columns; i++) {\r\n        if (this.get(row, i) < v) {\r\n          v = this.get(row, i);\r\n        }\r\n      }\r\n      return v;\r\n    }\r\n\r\n    /**\r\n         * Returns the index of the maximum value of one row\r\n         * @param {number} row - Row index\r\n         * @return {Array}\r\n         */\r\n    minRowIndex(row) {\r\n      checkRowIndex(this, row);\r\n      var v = this.get(row, 0);\r\n      var idx = [row, 0];\r\n      for (var i = 1; i < this.columns; i++) {\r\n        if (this.get(row, i) < v) {\r\n          v = this.get(row, i);\r\n          idx[1] = i;\r\n        }\r\n      }\r\n      return idx;\r\n    }\r\n\r\n    /**\r\n         * Returns the maximum value of one column\r\n         * @param {number} column - Column index\r\n         * @return {number}\r\n         */\r\n    maxColumn(column) {\r\n      checkColumnIndex(this, column);\r\n      var v = this.get(0, column);\r\n      for (var i = 1; i < this.rows; i++) {\r\n        if (this.get(i, column) > v) {\r\n          v = this.get(i, column);\r\n        }\r\n      }\r\n      return v;\r\n    }\r\n\r\n    /**\r\n         * Returns the index of the maximum value of one column\r\n         * @param {number} column - Column index\r\n         * @return {Array}\r\n         */\r\n    maxColumnIndex(column) {\r\n      checkColumnIndex(this, column);\r\n      var v = this.get(0, column);\r\n      var idx = [0, column];\r\n      for (var i = 1; i < this.rows; i++) {\r\n        if (this.get(i, column) > v) {\r\n          v = this.get(i, column);\r\n          idx[0] = i;\r\n        }\r\n      }\r\n      return idx;\r\n    }\r\n\r\n    /**\r\n         * Returns the minimum value of one column\r\n         * @param {number} column - Column index\r\n         * @return {number}\r\n         */\r\n    minColumn(column) {\r\n      checkColumnIndex(this, column);\r\n      var v = this.get(0, column);\r\n      for (var i = 1; i < this.rows; i++) {\r\n        if (this.get(i, column) < v) {\r\n          v = this.get(i, column);\r\n        }\r\n      }\r\n      return v;\r\n    }\r\n\r\n    /**\r\n         * Returns the index of the minimum value of one column\r\n         * @param {number} column - Column index\r\n         * @return {Array}\r\n         */\r\n    minColumnIndex(column) {\r\n      checkColumnIndex(this, column);\r\n      var v = this.get(0, column);\r\n      var idx = [0, column];\r\n      for (var i = 1; i < this.rows; i++) {\r\n        if (this.get(i, column) < v) {\r\n          v = this.get(i, column);\r\n          idx[0] = i;\r\n        }\r\n      }\r\n      return idx;\r\n    }\r\n\r\n    /**\r\n         * Returns an array containing the diagonal values of the matrix\r\n         * @return {Array}\r\n         */\r\n    diag() {\r\n      var min = Math.min(this.rows, this.columns);\r\n      var diag = new Array(min);\r\n      for (var i = 0; i < min; i++) {\r\n        diag[i] = this.get(i, i);\r\n      }\r\n      return diag;\r\n    }\r\n\r\n    /**\r\n         * Returns the sum by the argument given, if no argument given,\r\n         * it returns the sum of all elements of the matrix.\r\n         * @param {string} by - sum by 'row' or 'column'.\r\n         * @return {Matrix|number}\r\n         */\r\n    sum(by) {\r\n      switch (by) {\r\n        case 'row':\r\n          return sumByRow(this);\r\n        case 'column':\r\n          return sumByColumn(this);\r\n        default:\r\n          return sumAll(this);\r\n      }\r\n    }\r\n\r\n    /**\r\n         * Returns the mean of all elements of the matrix\r\n         * @return {number}\r\n         */\r\n    mean() {\r\n      return this.sum() / this.size;\r\n    }\r\n\r\n    /**\r\n         * Returns the product of all elements of the matrix\r\n         * @return {number}\r\n         */\r\n    prod() {\r\n      var prod = 1;\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          prod *= this.get(i, j);\r\n        }\r\n      }\r\n      return prod;\r\n    }\r\n\r\n    /**\r\n         * Returns the norm of a matrix.\r\n         * @param {string} type - \"frobenius\" (default) or \"max\" return resp. the Frobenius norm and the max norm.\r\n         * @return {number}\r\n         */\r\n    norm(type = 'frobenius') {\r\n      var result = 0;\r\n      if (type === 'max') {\r\n        return this.max();\r\n      } else if (type === 'frobenius') {\r\n        for (var i = 0; i < this.rows; i++) {\r\n          for (var j = 0; j < this.columns; j++) {\r\n            result = result + this.get(i, j) * this.get(i, j);\r\n          }\r\n        }\r\n        return Math.sqrt(result);\r\n      } else {\r\n        throw new RangeError(`unknown norm type: ${type}`);\r\n      }\r\n    }\r\n\r\n    /**\r\n         * Computes the cumulative sum of the matrix elements (in place, row by row)\r\n         * @return {Matrix} this\r\n         */\r\n    cumulativeSum() {\r\n      var sum = 0;\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          sum += this.get(i, j);\r\n          this.set(i, j, sum);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Computes the dot (scalar) product between the matrix and another\r\n         * @param {Matrix} vector2 vector\r\n         * @return {number}\r\n         */\r\n    dot(vector2) {\r\n      if (Matrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\r\n      var vector1 = this.to1DArray();\r\n      if (vector1.length !== vector2.length) {\r\n        throw new RangeError('vectors do not have the same size');\r\n      }\r\n      var dot = 0;\r\n      for (var i = 0; i < vector1.length; i++) {\r\n        dot += vector1[i] * vector2[i];\r\n      }\r\n      return dot;\r\n    }\r\n\r\n    /**\r\n         * Returns the matrix product between this and other\r\n         * @param {Matrix} other\r\n         * @return {Matrix}\r\n         */\r\n    mmul(other) {\r\n      other = this.constructor.checkMatrix(other);\r\n      if (this.columns !== other.rows) {\r\n        // eslint-disable-next-line no-console\r\n        console.warn('Number of columns of left matrix are not equal to number of rows of right matrix.');\r\n      }\r\n\r\n      var m = this.rows;\r\n      var n = this.columns;\r\n      var p = other.columns;\r\n\r\n      var result = new this.constructor[Symbol.species](m, p);\r\n\r\n      var Bcolj = new Array(n);\r\n      for (var j = 0; j < p; j++) {\r\n        for (var k = 0; k < n; k++) {\r\n          Bcolj[k] = other.get(k, j);\r\n        }\r\n\r\n        for (var i = 0; i < m; i++) {\r\n          var s = 0;\r\n          for (k = 0; k < n; k++) {\r\n            s += this.get(i, k) * Bcolj[k];\r\n          }\r\n\r\n          result.set(i, j, s);\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    strassen2x2(other) {\r\n      var result = new this.constructor[Symbol.species](2, 2);\r\n      const a11 = this.get(0, 0);\r\n      const b11 = other.get(0, 0);\r\n      const a12 = this.get(0, 1);\r\n      const b12 = other.get(0, 1);\r\n      const a21 = this.get(1, 0);\r\n      const b21 = other.get(1, 0);\r\n      const a22 = this.get(1, 1);\r\n      const b22 = other.get(1, 1);\r\n\r\n      // Compute intermediate values.\r\n      const m1 = (a11 + a22) * (b11 + b22);\r\n      const m2 = (a21 + a22) * b11;\r\n      const m3 = a11 * (b12 - b22);\r\n      const m4 = a22 * (b21 - b11);\r\n      const m5 = (a11 + a12) * b22;\r\n      const m6 = (a21 - a11) * (b11 + b12);\r\n      const m7 = (a12 - a22) * (b21 + b22);\r\n\r\n      // Combine intermediate values into the output.\r\n      const c00 = m1 + m4 - m5 + m7;\r\n      const c01 = m3 + m5;\r\n      const c10 = m2 + m4;\r\n      const c11 = m1 - m2 + m3 + m6;\r\n\r\n      result.set(0, 0, c00);\r\n      result.set(0, 1, c01);\r\n      result.set(1, 0, c10);\r\n      result.set(1, 1, c11);\r\n      return result;\r\n    }\r\n\r\n    strassen3x3(other) {\r\n      var result = new this.constructor[Symbol.species](3, 3);\r\n\r\n      const a00 = this.get(0, 0);\r\n      const a01 = this.get(0, 1);\r\n      const a02 = this.get(0, 2);\r\n      const a10 = this.get(1, 0);\r\n      const a11 = this.get(1, 1);\r\n      const a12 = this.get(1, 2);\r\n      const a20 = this.get(2, 0);\r\n      const a21 = this.get(2, 1);\r\n      const a22 = this.get(2, 2);\r\n\r\n      const b00 = other.get(0, 0);\r\n      const b01 = other.get(0, 1);\r\n      const b02 = other.get(0, 2);\r\n      const b10 = other.get(1, 0);\r\n      const b11 = other.get(1, 1);\r\n      const b12 = other.get(1, 2);\r\n      const b20 = other.get(2, 0);\r\n      const b21 = other.get(2, 1);\r\n      const b22 = other.get(2, 2);\r\n\r\n      const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\r\n      const m2 = (a00 - a10) * (-b01 + b11);\r\n      const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\r\n      const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\r\n      const m5 = (a10 + a11) * (-b00 + b01);\r\n      const m6 = a00 * b00;\r\n      const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\r\n      const m8 = (-a00 + a20) * (b02 - b12);\r\n      const m9 = (a20 + a21) * (-b00 + b02);\r\n      const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\r\n      const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\r\n      const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\r\n      const m13 = (a02 - a22) * (b11 - b21);\r\n      const m14 = a02 * b20;\r\n      const m15 = (a21 + a22) * (-b20 + b21);\r\n      const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\r\n      const m17 = (a02 - a12) * (b12 - b22);\r\n      const m18 = (a11 + a12) * (-b20 + b22);\r\n      const m19 = a01 * b10;\r\n      const m20 = a12 * b21;\r\n      const m21 = a10 * b02;\r\n      const m22 = a20 * b01;\r\n      const m23 = a22 * b22;\r\n\r\n      const c00 = m6 + m14 + m19;\r\n      const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\r\n      const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\r\n      const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\r\n      const c11 = m2 + m4 + m5 + m6 + m20;\r\n      const c12 = m14 + m16 + m17 + m18 + m21;\r\n      const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\r\n      const c21 = m12 + m13 + m14 + m15 + m22;\r\n      const c22 = m6 + m7 + m8 + m9 + m23;\r\n\r\n      result.set(0, 0, c00);\r\n      result.set(0, 1, c01);\r\n      result.set(0, 2, c02);\r\n      result.set(1, 0, c10);\r\n      result.set(1, 1, c11);\r\n      result.set(1, 2, c12);\r\n      result.set(2, 0, c20);\r\n      result.set(2, 1, c21);\r\n      result.set(2, 2, c22);\r\n      return result;\r\n    }\r\n\r\n    /**\r\n         * Returns the matrix product between x and y. More efficient than mmul(other) only when we multiply squared matrix and when the size of the matrix is > 1000.\r\n         * @param {Matrix} y\r\n         * @return {Matrix}\r\n         */\r\n    mmulStrassen(y) {\r\n      var x = this.clone();\r\n      var r1 = x.rows;\r\n      var c1 = x.columns;\r\n      var r2 = y.rows;\r\n      var c2 = y.columns;\r\n      if (c1 !== r2) {\r\n        // eslint-disable-next-line no-console\r\n        console.warn(`Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`);\r\n      }\r\n\r\n      // Put a matrix into the top left of a matrix of zeros.\r\n      // `rows` and `cols` are the dimensions of the output matrix.\r\n      function embed(mat, rows, cols) {\r\n        var r = mat.rows;\r\n        var c = mat.columns;\r\n        if ((r === rows) && (c === cols)) {\r\n          return mat;\r\n        } else {\r\n          var resultat = Matrix.zeros(rows, cols);\r\n          resultat = resultat.setSubMatrix(mat, 0, 0);\r\n          return resultat;\r\n        }\r\n      }\r\n\r\n\r\n      // Make sure both matrices are the same size.\r\n      // This is exclusively for simplicity:\r\n      // this algorithm can be implemented with matrices of different sizes.\r\n\r\n      var r = Math.max(r1, r2);\r\n      var c = Math.max(c1, c2);\r\n      x = embed(x, r, c);\r\n      y = embed(y, r, c);\r\n\r\n      // Our recursive multiplication function.\r\n      function blockMult(a, b, rows, cols) {\r\n        // For small matrices, resort to naive multiplication.\r\n        if (rows <= 512 || cols <= 512) {\r\n          return a.mmul(b); // a is equivalent to this\r\n        }\r\n\r\n        // Apply dynamic padding.\r\n        if ((rows % 2 === 1) && (cols % 2 === 1)) {\r\n          a = embed(a, rows + 1, cols + 1);\r\n          b = embed(b, rows + 1, cols + 1);\r\n        } else if (rows % 2 === 1) {\r\n          a = embed(a, rows + 1, cols);\r\n          b = embed(b, rows + 1, cols);\r\n        } else if (cols % 2 === 1) {\r\n          a = embed(a, rows, cols + 1);\r\n          b = embed(b, rows, cols + 1);\r\n        }\r\n\r\n        var halfRows = parseInt(a.rows / 2, 10);\r\n        var halfCols = parseInt(a.columns / 2, 10);\r\n        // Subdivide input matrices.\r\n        var a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\r\n        var b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\r\n\r\n        var a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\r\n        var b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\r\n\r\n        var a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\r\n        var b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\r\n\r\n        var a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\r\n        var b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\r\n\r\n        // Compute intermediate values.\r\n        var m1 = blockMult(Matrix.add(a11, a22), Matrix.add(b11, b22), halfRows, halfCols);\r\n        var m2 = blockMult(Matrix.add(a21, a22), b11, halfRows, halfCols);\r\n        var m3 = blockMult(a11, Matrix.sub(b12, b22), halfRows, halfCols);\r\n        var m4 = blockMult(a22, Matrix.sub(b21, b11), halfRows, halfCols);\r\n        var m5 = blockMult(Matrix.add(a11, a12), b22, halfRows, halfCols);\r\n        var m6 = blockMult(Matrix.sub(a21, a11), Matrix.add(b11, b12), halfRows, halfCols);\r\n        var m7 = blockMult(Matrix.sub(a12, a22), Matrix.add(b21, b22), halfRows, halfCols);\r\n\r\n        // Combine intermediate values into the output.\r\n        var c11 = Matrix.add(m1, m4);\r\n        c11.sub(m5);\r\n        c11.add(m7);\r\n        var c12 = Matrix.add(m3, m5);\r\n        var c21 = Matrix.add(m2, m4);\r\n        var c22 = Matrix.sub(m1, m2);\r\n        c22.add(m3);\r\n        c22.add(m6);\r\n\r\n        // Crop output to the desired size (undo dynamic padding).\r\n        var resultat = Matrix.zeros(2 * c11.rows, 2 * c11.columns);\r\n        resultat = resultat.setSubMatrix(c11, 0, 0);\r\n        resultat = resultat.setSubMatrix(c12, c11.rows, 0);\r\n        resultat = resultat.setSubMatrix(c21, 0, c11.columns);\r\n        resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\r\n        return resultat.subMatrix(0, rows - 1, 0, cols - 1);\r\n      }\r\n      return blockMult(x, y, r, c);\r\n    }\r\n\r\n    /**\r\n         * Returns a row-by-row scaled matrix\r\n         * @param {number} [min=0] - Minimum scaled value\r\n         * @param {number} [max=1] - Maximum scaled value\r\n         * @return {Matrix} - The scaled matrix\r\n         */\r\n    scaleRows(min, max) {\r\n      min = min === undefined ? 0 : min;\r\n      max = max === undefined ? 1 : max;\r\n      if (min >= max) {\r\n        throw new RangeError('min should be strictly smaller than max');\r\n      }\r\n      var newMatrix = this.constructor.empty(this.rows, this.columns);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        var scaled = rescale(this.getRow(i), { min, max });\r\n        newMatrix.setRow(i, scaled);\r\n      }\r\n      return newMatrix;\r\n    }\r\n\r\n    /**\r\n         * Returns a new column-by-column scaled matrix\r\n         * @param {number} [min=0] - Minimum scaled value\r\n         * @param {number} [max=1] - Maximum scaled value\r\n         * @return {Matrix} - The new scaled matrix\r\n         * @example\r\n         * var matrix = new Matrix([[1,2],[-1,0]]);\r\n         * var scaledMatrix = matrix.scaleColumns(); // [[1,1],[0,0]]\r\n         */\r\n    scaleColumns(min, max) {\r\n      min = min === undefined ? 0 : min;\r\n      max = max === undefined ? 1 : max;\r\n      if (min >= max) {\r\n        throw new RangeError('min should be strictly smaller than max');\r\n      }\r\n      var newMatrix = this.constructor.empty(this.rows, this.columns);\r\n      for (var i = 0; i < this.columns; i++) {\r\n        var scaled = rescale(this.getColumn(i), {\r\n          min: min,\r\n          max: max\r\n        });\r\n        newMatrix.setColumn(i, scaled);\r\n      }\r\n      return newMatrix;\r\n    }\r\n\r\n\r\n    /**\r\n         * Returns the Kronecker product (also known as tensor product) between this and other\r\n         * See https://en.wikipedia.org/wiki/Kronecker_product\r\n         * @param {Matrix} other\r\n         * @return {Matrix}\r\n         */\r\n    kroneckerProduct(other) {\r\n      other = this.constructor.checkMatrix(other);\r\n\r\n      var m = this.rows;\r\n      var n = this.columns;\r\n      var p = other.rows;\r\n      var q = other.columns;\r\n\r\n      var result = new this.constructor[Symbol.species](m * p, n * q);\r\n      for (var i = 0; i < m; i++) {\r\n        for (var j = 0; j < n; j++) {\r\n          for (var k = 0; k < p; k++) {\r\n            for (var l = 0; l < q; l++) {\r\n              result[p * i + k][q * j + l] = this.get(i, j) * other.get(k, l);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n         * Transposes the matrix and returns a new one containing the result\r\n         * @return {Matrix}\r\n         */\r\n    transpose() {\r\n      var result = new this.constructor[Symbol.species](this.columns, this.rows);\r\n      for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n          result.set(j, i, this.get(i, j));\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n\r\n    /**\r\n         * Sorts the rows (in place)\r\n         * @param {function} compareFunction - usual Array.prototype.sort comparison function\r\n         * @return {Matrix} this\r\n         */\r\n    sortRows(compareFunction) {\r\n      if (compareFunction === undefined) compareFunction = compareNumbers;\r\n      for (var i = 0; i < this.rows; i++) {\r\n        this.setRow(i, this.getRow(i).sort(compareFunction));\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Sorts the columns (in place)\r\n         * @param {function} compareFunction - usual Array.prototype.sort comparison function\r\n         * @return {Matrix} this\r\n         */\r\n    sortColumns(compareFunction) {\r\n      if (compareFunction === undefined) compareFunction = compareNumbers;\r\n      for (var i = 0; i < this.columns; i++) {\r\n        this.setColumn(i, this.getColumn(i).sort(compareFunction));\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Returns a subset of the matrix\r\n         * @param {number} startRow - First row index\r\n         * @param {number} endRow - Last row index\r\n         * @param {number} startColumn - First column index\r\n         * @param {number} endColumn - Last column index\r\n         * @return {Matrix}\r\n         */\r\n    subMatrix(startRow, endRow, startColumn, endColumn) {\r\n      checkRange(this, startRow, endRow, startColumn, endColumn);\r\n      var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, endColumn - startColumn + 1);\r\n      for (var i = startRow; i <= endRow; i++) {\r\n        for (var j = startColumn; j <= endColumn; j++) {\r\n          newMatrix[i - startRow][j - startColumn] = this.get(i, j);\r\n        }\r\n      }\r\n      return newMatrix;\r\n    }\r\n\r\n    /**\r\n         * Returns a subset of the matrix based on an array of row indices\r\n         * @param {Array} indices - Array containing the row indices\r\n         * @param {number} [startColumn = 0] - First column index\r\n         * @param {number} [endColumn = this.columns-1] - Last column index\r\n         * @return {Matrix}\r\n         */\r\n    subMatrixRow(indices, startColumn, endColumn) {\r\n      if (startColumn === undefined) startColumn = 0;\r\n      if (endColumn === undefined) endColumn = this.columns - 1;\r\n      if ((startColumn > endColumn) || (startColumn < 0) || (startColumn >= this.columns) || (endColumn < 0) || (endColumn >= this.columns)) {\r\n        throw new RangeError('Argument out of range');\r\n      }\r\n\r\n      var newMatrix = new this.constructor[Symbol.species](indices.length, endColumn - startColumn + 1);\r\n      for (var i = 0; i < indices.length; i++) {\r\n        for (var j = startColumn; j <= endColumn; j++) {\r\n          if (indices[i] < 0 || indices[i] >= this.rows) {\r\n            throw new RangeError(`Row index out of range: ${indices[i]}`);\r\n          }\r\n          newMatrix.set(i, j - startColumn, this.get(indices[i], j));\r\n        }\r\n      }\r\n      return newMatrix;\r\n    }\r\n\r\n    /**\r\n         * Returns a subset of the matrix based on an array of column indices\r\n         * @param {Array} indices - Array containing the column indices\r\n         * @param {number} [startRow = 0] - First row index\r\n         * @param {number} [endRow = this.rows-1] - Last row index\r\n         * @return {Matrix}\r\n         */\r\n    subMatrixColumn(indices, startRow, endRow) {\r\n      if (startRow === undefined) startRow = 0;\r\n      if (endRow === undefined) endRow = this.rows - 1;\r\n      if ((startRow > endRow) || (startRow < 0) || (startRow >= this.rows) || (endRow < 0) || (endRow >= this.rows)) {\r\n        throw new RangeError('Argument out of range');\r\n      }\r\n\r\n      var newMatrix = new this.constructor[Symbol.species](endRow - startRow + 1, indices.length);\r\n      for (var i = 0; i < indices.length; i++) {\r\n        for (var j = startRow; j <= endRow; j++) {\r\n          if (indices[i] < 0 || indices[i] >= this.columns) {\r\n            throw new RangeError(`Column index out of range: ${indices[i]}`);\r\n          }\r\n          newMatrix.set(j - startRow, i, this.get(j, indices[i]));\r\n        }\r\n      }\r\n      return newMatrix;\r\n    }\r\n\r\n    /**\r\n         * Set a part of the matrix to the given sub-matrix\r\n         * @param {Matrix|Array< Array >} matrix - The source matrix from which to extract values.\r\n         * @param {number} startRow - The index of the first row to set\r\n         * @param {number} startColumn - The index of the first column to set\r\n         * @return {Matrix}\r\n         */\r\n    setSubMatrix(matrix, startRow, startColumn) {\r\n      matrix = this.constructor.checkMatrix(matrix);\r\n      var endRow = startRow + matrix.rows - 1;\r\n      var endColumn = startColumn + matrix.columns - 1;\r\n      checkRange(this, startRow, endRow, startColumn, endColumn);\r\n      for (var i = 0; i < matrix.rows; i++) {\r\n        for (var j = 0; j < matrix.columns; j++) {\r\n          this[startRow + i][startColumn + j] = matrix.get(i, j);\r\n        }\r\n      }\r\n      return this;\r\n    }\r\n\r\n    /**\r\n         * Return a new matrix based on a selection of rows and columns\r\n         * @param {Array<number>} rowIndices - The row indices to select. Order matters and an index can be more than once.\r\n         * @param {Array<number>} columnIndices - The column indices to select. Order matters and an index can be use more than once.\r\n         * @return {Matrix} The new matrix\r\n         */\r\n    selection(rowIndices, columnIndices) {\r\n      var indices = checkIndices(this, rowIndices, columnIndices);\r\n      var newMatrix = new this.constructor[Symbol.species](rowIndices.length, columnIndices.length);\r\n      for (var i = 0; i < indices.row.length; i++) {\r\n        var rowIndex = indices.row[i];\r\n        for (var j = 0; j < indices.column.length; j++) {\r\n          var columnIndex = indices.column[j];\r\n          newMatrix[i][j] = this.get(rowIndex, columnIndex);\r\n        }\r\n      }\r\n      return newMatrix;\r\n    }\r\n\r\n    /**\r\n         * Returns the trace of the matrix (sum of the diagonal elements)\r\n         * @return {number}\r\n         */\r\n    trace() {\r\n      var min = Math.min(this.rows, this.columns);\r\n      var trace = 0;\r\n      for (var i = 0; i < min; i++) {\r\n        trace += this.get(i, i);\r\n      }\r\n      return trace;\r\n    }\r\n\r\n    /*\r\n         Matrix views\r\n         */\r\n\r\n    /**\r\n         * Returns a view of the transposition of the matrix\r\n         * @return {MatrixTransposeView}\r\n         */\r\n    transposeView() {\r\n      return new MatrixTransposeView(this);\r\n    }\r\n\r\n    /**\r\n         * Returns a view of the row vector with the given index\r\n         * @param {number} row - row index of the vector\r\n         * @return {MatrixRowView}\r\n         */\r\n    rowView(row) {\r\n      checkRowIndex(this, row);\r\n      return new MatrixRowView(this, row);\r\n    }\r\n\r\n    /**\r\n         * Returns a view of the column vector with the given index\r\n         * @param {number} column - column index of the vector\r\n         * @return {MatrixColumnView}\r\n         */\r\n    columnView(column) {\r\n      checkColumnIndex(this, column);\r\n      return new MatrixColumnView(this, column);\r\n    }\r\n\r\n    /**\r\n         * Returns a view of the matrix flipped in the row axis\r\n         * @return {MatrixFlipRowView}\r\n         */\r\n    flipRowView() {\r\n      return new MatrixFlipRowView(this);\r\n    }\r\n\r\n    /**\r\n         * Returns a view of the matrix flipped in the column axis\r\n         * @return {MatrixFlipColumnView}\r\n         */\r\n    flipColumnView() {\r\n      return new MatrixFlipColumnView(this);\r\n    }\r\n\r\n    /**\r\n         * Returns a view of a submatrix giving the index boundaries\r\n         * @param {number} startRow - first row index of the submatrix\r\n         * @param {number} endRow - last row index of the submatrix\r\n         * @param {number} startColumn - first column index of the submatrix\r\n         * @param {number} endColumn - last column index of the submatrix\r\n         * @return {MatrixSubView}\r\n         */\r\n    subMatrixView(startRow, endRow, startColumn, endColumn) {\r\n      return new MatrixSubView(this, startRow, endRow, startColumn, endColumn);\r\n    }\r\n\r\n    /**\r\n         * Returns a view of the cross of the row indices and the column indices\r\n         * @example\r\n         * // resulting vector is [[2], [2]]\r\n         * var matrix = new Matrix([[1,2,3], [4,5,6]]).selectionView([0, 0], [1])\r\n         * @param {Array<number>} rowIndices\r\n         * @param {Array<number>} columnIndices\r\n         * @return {MatrixSelectionView}\r\n         */\r\n    selectionView(rowIndices, columnIndices) {\r\n      return new MatrixSelectionView(this, rowIndices, columnIndices);\r\n    }\r\n\r\n    /**\r\n         * Returns a view of the row indices\r\n         * @example\r\n         * // resulting vector is [[1,2,3], [1,2,3]]\r\n         * var matrix = new Matrix([[1,2,3], [4,5,6]]).rowSelectionView([0, 0])\r\n         * @param {Array<number>} rowIndices\r\n         * @return {MatrixRowSelectionView}\r\n         */\r\n    rowSelectionView(rowIndices) {\r\n      return new MatrixRowSelectionView(this, rowIndices);\r\n    }\r\n\r\n    /**\r\n         * Returns a view of the column indices\r\n         * @example\r\n         * // resulting vector is [[2, 2], [5, 5]]\r\n         * var matrix = new Matrix([[1,2,3], [4,5,6]]).columnSelectionView([1, 1])\r\n         * @param {Array<number>} columnIndices\r\n         * @return {MatrixColumnSelectionView}\r\n         */\r\n    columnSelectionView(columnIndices) {\r\n      return new MatrixColumnSelectionView(this, columnIndices);\r\n    }\r\n\r\n\r\n    /**\r\n        * Calculates and returns the determinant of a matrix as a Number\r\n        * @example\r\n        *   new Matrix([[1,2,3], [4,5,6]]).det()\r\n        * @return {number}\r\n        */\r\n    det() {\r\n      if (this.isSquare()) {\r\n        var a, b, c, d;\r\n        if (this.columns === 2) {\r\n          // 2 x 2 matrix\r\n          a = this.get(0, 0);\r\n          b = this.get(0, 1);\r\n          c = this.get(1, 0);\r\n          d = this.get(1, 1);\r\n\r\n          return a * d - (b * c);\r\n        } else if (this.columns === 3) {\r\n          // 3 x 3 matrix\r\n          var subMatrix0, subMatrix1, subMatrix2;\r\n          subMatrix0 = this.selectionView([1, 2], [1, 2]);\r\n          subMatrix1 = this.selectionView([1, 2], [0, 2]);\r\n          subMatrix2 = this.selectionView([1, 2], [0, 1]);\r\n          a = this.get(0, 0);\r\n          b = this.get(0, 1);\r\n          c = this.get(0, 2);\r\n\r\n          return a * subMatrix0.det() - b * subMatrix1.det() + c * subMatrix2.det();\r\n        } else {\r\n          // general purpose determinant using the LU decomposition\r\n          return new LuDecomposition(this).determinant;\r\n        }\r\n      } else {\r\n        throw Error('Determinant can only be calculated for a square matrix.');\r\n      }\r\n    }\r\n\r\n    /**\r\n         * Returns inverse of a matrix if it exists or the pseudoinverse\r\n         * @param {number} threshold - threshold for taking inverse of singular values (default = 1e-15)\r\n         * @return {Matrix} the (pseudo)inverted matrix.\r\n         */\r\n    pseudoInverse(threshold) {\r\n      if (threshold === undefined) threshold = Number.EPSILON;\r\n      var svdSolution = new SvDecomposition(this, { autoTranspose: true });\r\n\r\n      var U = svdSolution.leftSingularVectors;\r\n      var V = svdSolution.rightSingularVectors;\r\n      var s = svdSolution.diagonal;\r\n\r\n      for (var i = 0; i < s.length; i++) {\r\n        if (Math.abs(s[i]) > threshold) {\r\n          s[i] = 1.0 / s[i];\r\n        } else {\r\n          s[i] = 0.0;\r\n        }\r\n      }\r\n\r\n      // convert list to diagonal\r\n      s = this.constructor[Symbol.species].diag(s);\r\n      return V.mmul(s.mmul(U.transposeView()));\r\n    }\r\n\r\n    /**\r\n         * Creates an exact and independent copy of the matrix\r\n         * @return {Matrix}\r\n         */\r\n    clone() {\r\n      var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);\r\n      for (var row = 0; row < this.rows; row++) {\r\n        for (var column = 0; column < this.columns; column++) {\r\n          newMatrix.set(row, column, this.get(row, column));\r\n        }\r\n      }\r\n      return newMatrix;\r\n    }\r\n  }\r\n\r\n  Matrix.prototype.klass = 'Matrix';\r\n\r\n  function compareNumbers(a, b) {\r\n    return a - b;\r\n  }\r\n\r\n  /*\r\n     Synonyms\r\n     */\r\n\r\n  Matrix.random = Matrix.rand;\r\n  Matrix.diagonal = Matrix.diag;\r\n  Matrix.prototype.diagonal = Matrix.prototype.diag;\r\n  Matrix.identity = Matrix.eye;\r\n  Matrix.prototype.negate = Matrix.prototype.neg;\r\n  Matrix.prototype.tensorProduct = Matrix.prototype.kroneckerProduct;\r\n  Matrix.prototype.determinant = Matrix.prototype.det;\r\n\r\n  /*\r\n     Add dynamically instance and static methods for mathematical operations\r\n     */\r\n\r\n  var inplaceOperator = `\r\n(function %name%(value) {\r\n    if (typeof value === 'number') return this.%name%S(value);\r\n    return this.%name%M(value);\r\n})\r\n`;\r\n\r\n  var inplaceOperatorScalar = `\r\n(function %name%S(value) {\r\n    for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n            this.set(i, j, this.get(i, j) %op% value);\r\n        }\r\n    }\r\n    return this;\r\n})\r\n`;\r\n\r\n  var inplaceOperatorMatrix = `\r\n(function %name%M(matrix) {\r\n    matrix = this.constructor.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n        this.columns !== matrix.columns) {\r\n        throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\r\n        }\r\n    }\r\n    return this;\r\n})\r\n`;\r\n\r\n  var staticOperator = `\r\n(function %name%(matrix, value) {\r\n    var newMatrix = new this[Symbol.species](matrix);\r\n    return newMatrix.%name%(value);\r\n})\r\n`;\r\n\r\n  var inplaceMethod = `\r\n(function %name%() {\r\n    for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n            this.set(i, j, %method%(this.get(i, j)));\r\n        }\r\n    }\r\n    return this;\r\n})\r\n`;\r\n\r\n  var staticMethod = `\r\n(function %name%(matrix) {\r\n    var newMatrix = new this[Symbol.species](matrix);\r\n    return newMatrix.%name%();\r\n})\r\n`;\r\n\r\n  var inplaceMethodWithArgs = `\r\n(function %name%(%args%) {\r\n    for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n            this.set(i, j, %method%(this.get(i, j), %args%));\r\n        }\r\n    }\r\n    return this;\r\n})\r\n`;\r\n\r\n  var staticMethodWithArgs = `\r\n(function %name%(matrix, %args%) {\r\n    var newMatrix = new this[Symbol.species](matrix);\r\n    return newMatrix.%name%(%args%);\r\n})\r\n`;\r\n\r\n\r\n  var inplaceMethodWithOneArgScalar = `\r\n(function %name%S(value) {\r\n    for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n            this.set(i, j, %method%(this.get(i, j), value));\r\n        }\r\n    }\r\n    return this;\r\n})\r\n`;\r\n  var inplaceMethodWithOneArgMatrix = `\r\n(function %name%M(matrix) {\r\n    matrix = this.constructor.checkMatrix(matrix);\r\n    if (this.rows !== matrix.rows ||\r\n        this.columns !== matrix.columns) {\r\n        throw new RangeError('Matrices dimensions must be equal');\r\n    }\r\n    for (var i = 0; i < this.rows; i++) {\r\n        for (var j = 0; j < this.columns; j++) {\r\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\r\n        }\r\n    }\r\n    return this;\r\n})\r\n`;\r\n\r\n  var inplaceMethodWithOneArg = `\r\n(function %name%(value) {\r\n    if (typeof value === 'number') return this.%name%S(value);\r\n    return this.%name%M(value);\r\n})\r\n`;\r\n\r\n  var staticMethodWithOneArg = staticMethodWithArgs;\r\n\r\n  var operators = [\r\n    // Arithmetic operators\r\n    ['+', 'add'],\r\n    ['-', 'sub', 'subtract'],\r\n    ['*', 'mul', 'multiply'],\r\n    ['/', 'div', 'divide'],\r\n    ['%', 'mod', 'modulus'],\r\n    // Bitwise operators\r\n    ['&', 'and'],\r\n    ['|', 'or'],\r\n    ['^', 'xor'],\r\n    ['<<', 'leftShift'],\r\n    ['>>', 'signPropagatingRightShift'],\r\n    ['>>>', 'rightShift', 'zeroFillRightShift']\r\n  ];\r\n\r\n  var i;\r\n  var eval2 = eval; // eslint-disable-line no-eval\r\n  for (var operator of operators) {\r\n    var inplaceOp = eval2(fillTemplateFunction(inplaceOperator, { name: operator[1], op: operator[0] }));\r\n    var inplaceOpS = eval2(fillTemplateFunction(inplaceOperatorScalar, { name: `${operator[1]}S`, op: operator[0] }));\r\n    var inplaceOpM = eval2(fillTemplateFunction(inplaceOperatorMatrix, { name: `${operator[1]}M`, op: operator[0] }));\r\n    var staticOp = eval2(fillTemplateFunction(staticOperator, { name: operator[1] }));\r\n    for (i = 1; i < operator.length; i++) {\r\n      Matrix.prototype[operator[i]] = inplaceOp;\r\n      Matrix.prototype[`${operator[i]}S`] = inplaceOpS;\r\n      Matrix.prototype[`${operator[i]}M`] = inplaceOpM;\r\n      Matrix[operator[i]] = staticOp;\r\n    }\r\n  }\r\n\r\n  var methods = [['~', 'not']];\r\n\r\n  [\r\n    'abs', 'acos', 'acosh', 'asin', 'asinh', 'atan', 'atanh', 'cbrt', 'ceil',\r\n    'clz32', 'cos', 'cosh', 'exp', 'expm1', 'floor', 'fround', 'log', 'log1p',\r\n    'log10', 'log2', 'round', 'sign', 'sin', 'sinh', 'sqrt', 'tan', 'tanh', 'trunc'\r\n  ].forEach(function (mathMethod) {\r\n    methods.push([`Math.${mathMethod}`, mathMethod]);\r\n  });\r\n\r\n  for (var method of methods) {\r\n    var inplaceMeth = eval2(fillTemplateFunction(inplaceMethod, { name: method[1], method: method[0] }));\r\n    var staticMeth = eval2(fillTemplateFunction(staticMethod, { name: method[1] }));\r\n    for (i = 1; i < method.length; i++) {\r\n      Matrix.prototype[method[i]] = inplaceMeth;\r\n      Matrix[method[i]] = staticMeth;\r\n    }\r\n  }\r\n\r\n  var methodsWithArgs = [['Math.pow', 1, 'pow']];\r\n\r\n  for (var methodWithArg of methodsWithArgs) {\r\n    var args = 'arg0';\r\n    for (i = 1; i < methodWithArg[1]; i++) {\r\n      args += `, arg${i}`;\r\n    }\r\n    if (methodWithArg[1] !== 1) {\r\n      var inplaceMethWithArgs = eval2(fillTemplateFunction(inplaceMethodWithArgs, {\r\n        name: methodWithArg[2],\r\n        method: methodWithArg[0],\r\n        args: args\r\n      }));\r\n      var staticMethWithArgs = eval2(fillTemplateFunction(staticMethodWithArgs, { name: methodWithArg[2], args: args }));\r\n      for (i = 2; i < methodWithArg.length; i++) {\r\n        Matrix.prototype[methodWithArg[i]] = inplaceMethWithArgs;\r\n        Matrix[methodWithArg[i]] = staticMethWithArgs;\r\n      }\r\n    } else {\r\n      var tmplVar = {\r\n        name: methodWithArg[2],\r\n        args: args,\r\n        method: methodWithArg[0]\r\n      };\r\n      var inplaceMethod2 = eval2(fillTemplateFunction(inplaceMethodWithOneArg, tmplVar));\r\n      var inplaceMethodS = eval2(fillTemplateFunction(inplaceMethodWithOneArgScalar, tmplVar));\r\n      var inplaceMethodM = eval2(fillTemplateFunction(inplaceMethodWithOneArgMatrix, tmplVar));\r\n      var staticMethod2 = eval2(fillTemplateFunction(staticMethodWithOneArg, tmplVar));\r\n      for (i = 2; i < methodWithArg.length; i++) {\r\n        Matrix.prototype[methodWithArg[i]] = inplaceMethod2;\r\n        Matrix.prototype[`${methodWithArg[i]}M`] = inplaceMethodM;\r\n        Matrix.prototype[`${methodWithArg[i]}S`] = inplaceMethodS;\r\n        Matrix[methodWithArg[i]] = staticMethod2;\r\n      }\r\n    }\r\n  }\r\n\r\n  function fillTemplateFunction(template, values) {\r\n    for (var value in values) {\r\n      template = template.replace(new RegExp(`%${value}%`, 'g'), values[value]);\r\n    }\r\n    return template;\r\n  }\r\n\r\n  return Matrix;\r\n}\r\n","import { Matrix, WrapperMatrix2D } from '../index';\r\n\r\n/**\r\n * @class CholeskyDecomposition\r\n * @link https://github.com/lutzroeder/Mapack/blob/master/Source/CholeskyDecomposition.cs\r\n * @param {Matrix} value\r\n */\r\nexport default class CholeskyDecomposition {\r\n  constructor(value) {\r\n    value = WrapperMatrix2D.checkMatrix(value);\r\n    if (!value.isSymmetric()) {\r\n      throw new Error('Matrix is not symmetric');\r\n    }\r\n\r\n    var a = value;\r\n    var dimension = a.rows;\r\n    var l = new Matrix(dimension, dimension);\r\n    var positiveDefinite = true;\r\n    var i, j, k;\r\n\r\n    for (j = 0; j < dimension; j++) {\r\n      var Lrowj = l[j];\r\n      var d = 0;\r\n      for (k = 0; k < j; k++) {\r\n        var Lrowk = l[k];\r\n        var s = 0;\r\n        for (i = 0; i < k; i++) {\r\n          s += Lrowk[i] * Lrowj[i];\r\n        }\r\n        Lrowj[k] = s = (a.get(j, k) - s) / l[k][k];\r\n        d = d + s * s;\r\n      }\r\n\r\n      d = a.get(j, j) - d;\r\n\r\n      positiveDefinite &= d > 0;\r\n      l[j][j] = Math.sqrt(Math.max(d, 0));\r\n      for (k = j + 1; k < dimension; k++) {\r\n        l[j][k] = 0;\r\n      }\r\n    }\r\n\r\n    if (!positiveDefinite) {\r\n      throw new Error('Matrix is not positive definite');\r\n    }\r\n\r\n    this.L = l;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Matrix} value\r\n   * @return {Matrix}\r\n   */\r\n  solve(value) {\r\n    value = WrapperMatrix2D.checkMatrix(value);\r\n\r\n    var l = this.L;\r\n    var dimension = l.rows;\r\n\r\n    if (value.rows !== dimension) {\r\n      throw new Error('Matrix dimensions do not match');\r\n    }\r\n\r\n    var count = value.columns;\r\n    var B = value.clone();\r\n    var i, j, k;\r\n\r\n    for (k = 0; k < dimension; k++) {\r\n      for (j = 0; j < count; j++) {\r\n        for (i = 0; i < k; i++) {\r\n          B[k][j] -= B[i][j] * l[k][i];\r\n        }\r\n        B[k][j] /= l[k][k];\r\n      }\r\n    }\r\n\r\n    for (k = dimension - 1; k >= 0; k--) {\r\n      for (j = 0; j < count; j++) {\r\n        for (i = k + 1; i < dimension; i++) {\r\n          B[k][j] -= B[i][j] * l[i][k];\r\n        }\r\n        B[k][j] /= l[k][k];\r\n      }\r\n    }\r\n\r\n    return B;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get lowerTriangularMatrix() {\r\n    return this.L;\r\n  }\r\n}\r\n","import { Matrix, WrapperMatrix2D } from '../index';\r\n\r\nimport { hypotenuse, getFilled2DArray } from './util';\r\n\r\n/**\r\n * @class EigenvalueDecomposition\r\n * @link https://github.com/lutzroeder/Mapack/blob/master/Source/EigenvalueDecomposition.cs\r\n * @param {Matrix} matrix\r\n * @param {object} [options]\r\n * @param {boolean} [options.assumeSymmetric=false]\r\n */\r\nexport default class EigenvalueDecomposition {\r\n  constructor(matrix, options = {}) {\r\n    const { assumeSymmetric = false } = options;\r\n\r\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\r\n    if (!matrix.isSquare()) {\r\n      throw new Error('Matrix is not a square matrix');\r\n    }\r\n\r\n    var n = matrix.columns;\r\n    var V = getFilled2DArray(n, n, 0);\r\n    var d = new Array(n);\r\n    var e = new Array(n);\r\n    var value = matrix;\r\n    var i, j;\r\n\r\n    var isSymmetric = false;\r\n    if (assumeSymmetric) {\r\n      isSymmetric = true;\r\n    } else {\r\n      isSymmetric = matrix.isSymmetric();\r\n    }\r\n\r\n    if (isSymmetric) {\r\n      for (i = 0; i < n; i++) {\r\n        for (j = 0; j < n; j++) {\r\n          V[i][j] = value.get(i, j);\r\n        }\r\n      }\r\n      tred2(n, e, d, V);\r\n      tql2(n, e, d, V);\r\n    } else {\r\n      var H = getFilled2DArray(n, n, 0);\r\n      var ort = new Array(n);\r\n      for (j = 0; j < n; j++) {\r\n        for (i = 0; i < n; i++) {\r\n          H[i][j] = value.get(i, j);\r\n        }\r\n      }\r\n      orthes(n, H, ort, V);\r\n      hqr2(n, e, d, V, H);\r\n    }\r\n\r\n    this.n = n;\r\n    this.e = e;\r\n    this.d = d;\r\n    this.V = V;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Array<number>}\r\n   */\r\n  get realEigenvalues() {\r\n    return this.d;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Array<number>}\r\n   */\r\n  get imaginaryEigenvalues() {\r\n    return this.e;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get eigenvectorMatrix() {\r\n    if (!Matrix.isMatrix(this.V)) {\r\n      this.V = new Matrix(this.V);\r\n    }\r\n    return this.V;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get diagonalMatrix() {\r\n    var n = this.n;\r\n    var e = this.e;\r\n    var d = this.d;\r\n    var X = new Matrix(n, n);\r\n    var i, j;\r\n    for (i = 0; i < n; i++) {\r\n      for (j = 0; j < n; j++) {\r\n        X[i][j] = 0;\r\n      }\r\n      X[i][i] = d[i];\r\n      if (e[i] > 0) {\r\n        X[i][i + 1] = e[i];\r\n      } else if (e[i] < 0) {\r\n        X[i][i - 1] = e[i];\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n}\r\n\r\nfunction tred2(n, e, d, V) {\r\n  var f, g, h, i, j, k, hh, scale;\r\n\r\n  for (j = 0; j < n; j++) {\r\n    d[j] = V[n - 1][j];\r\n  }\r\n\r\n  for (i = n - 1; i > 0; i--) {\r\n    scale = 0;\r\n    h = 0;\r\n    for (k = 0; k < i; k++) {\r\n      scale = scale + Math.abs(d[k]);\r\n    }\r\n\r\n    if (scale === 0) {\r\n      e[i] = d[i - 1];\r\n      for (j = 0; j < i; j++) {\r\n        d[j] = V[i - 1][j];\r\n        V[i][j] = 0;\r\n        V[j][i] = 0;\r\n      }\r\n    } else {\r\n      for (k = 0; k < i; k++) {\r\n        d[k] /= scale;\r\n        h += d[k] * d[k];\r\n      }\r\n\r\n      f = d[i - 1];\r\n      g = Math.sqrt(h);\r\n      if (f > 0) {\r\n        g = -g;\r\n      }\r\n\r\n      e[i] = scale * g;\r\n      h = h - f * g;\r\n      d[i - 1] = f - g;\r\n      for (j = 0; j < i; j++) {\r\n        e[j] = 0;\r\n      }\r\n\r\n      for (j = 0; j < i; j++) {\r\n        f = d[j];\r\n        V[j][i] = f;\r\n        g = e[j] + V[j][j] * f;\r\n        for (k = j + 1; k <= i - 1; k++) {\r\n          g += V[k][j] * d[k];\r\n          e[k] += V[k][j] * f;\r\n        }\r\n        e[j] = g;\r\n      }\r\n\r\n      f = 0;\r\n      for (j = 0; j < i; j++) {\r\n        e[j] /= h;\r\n        f += e[j] * d[j];\r\n      }\r\n\r\n      hh = f / (h + h);\r\n      for (j = 0; j < i; j++) {\r\n        e[j] -= hh * d[j];\r\n      }\r\n\r\n      for (j = 0; j < i; j++) {\r\n        f = d[j];\r\n        g = e[j];\r\n        for (k = j; k <= i - 1; k++) {\r\n          V[k][j] -= f * e[k] + g * d[k];\r\n        }\r\n        d[j] = V[i - 1][j];\r\n        V[i][j] = 0;\r\n      }\r\n    }\r\n    d[i] = h;\r\n  }\r\n\r\n  for (i = 0; i < n - 1; i++) {\r\n    V[n - 1][i] = V[i][i];\r\n    V[i][i] = 1;\r\n    h = d[i + 1];\r\n    if (h !== 0) {\r\n      for (k = 0; k <= i; k++) {\r\n        d[k] = V[k][i + 1] / h;\r\n      }\r\n\r\n      for (j = 0; j <= i; j++) {\r\n        g = 0;\r\n        for (k = 0; k <= i; k++) {\r\n          g += V[k][i + 1] * V[k][j];\r\n        }\r\n        for (k = 0; k <= i; k++) {\r\n          V[k][j] -= g * d[k];\r\n        }\r\n      }\r\n    }\r\n\r\n    for (k = 0; k <= i; k++) {\r\n      V[k][i + 1] = 0;\r\n    }\r\n  }\r\n\r\n  for (j = 0; j < n; j++) {\r\n    d[j] = V[n - 1][j];\r\n    V[n - 1][j] = 0;\r\n  }\r\n\r\n  V[n - 1][n - 1] = 1;\r\n  e[0] = 0;\r\n}\r\n\r\nfunction tql2(n, e, d, V) {\r\n  var g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;\r\n\r\n  for (i = 1; i < n; i++) {\r\n    e[i - 1] = e[i];\r\n  }\r\n\r\n  e[n - 1] = 0;\r\n\r\n  var f = 0;\r\n  var tst1 = 0;\r\n  var eps = Number.EPSILON;\r\n\r\n  for (l = 0; l < n; l++) {\r\n    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\r\n    m = l;\r\n    while (m < n) {\r\n      if (Math.abs(e[m]) <= eps * tst1) {\r\n        break;\r\n      }\r\n      m++;\r\n    }\r\n\r\n    if (m > l) {\r\n      iter = 0;\r\n      do {\r\n        iter = iter + 1;\r\n\r\n        g = d[l];\r\n        p = (d[l + 1] - g) / (2 * e[l]);\r\n        r = hypotenuse(p, 1);\r\n        if (p < 0) {\r\n          r = -r;\r\n        }\r\n\r\n        d[l] = e[l] / (p + r);\r\n        d[l + 1] = e[l] * (p + r);\r\n        dl1 = d[l + 1];\r\n        h = g - d[l];\r\n        for (i = l + 2; i < n; i++) {\r\n          d[i] -= h;\r\n        }\r\n\r\n        f = f + h;\r\n\r\n        p = d[m];\r\n        c = 1;\r\n        c2 = c;\r\n        c3 = c;\r\n        el1 = e[l + 1];\r\n        s = 0;\r\n        s2 = 0;\r\n        for (i = m - 1; i >= l; i--) {\r\n          c3 = c2;\r\n          c2 = c;\r\n          s2 = s;\r\n          g = c * e[i];\r\n          h = c * p;\r\n          r = hypotenuse(p, e[i]);\r\n          e[i + 1] = s * r;\r\n          s = e[i] / r;\r\n          c = p / r;\r\n          p = c * d[i] - s * g;\r\n          d[i + 1] = h + s * (c * g + s * d[i]);\r\n\r\n          for (k = 0; k < n; k++) {\r\n            h = V[k][i + 1];\r\n            V[k][i + 1] = s * V[k][i] + c * h;\r\n            V[k][i] = c * V[k][i] - s * h;\r\n          }\r\n        }\r\n\r\n        p = -s * s2 * c3 * el1 * e[l] / dl1;\r\n        e[l] = s * p;\r\n        d[l] = c * p;\r\n      } while (Math.abs(e[l]) > eps * tst1);\r\n    }\r\n    d[l] = d[l] + f;\r\n    e[l] = 0;\r\n  }\r\n\r\n  for (i = 0; i < n - 1; i++) {\r\n    k = i;\r\n    p = d[i];\r\n    for (j = i + 1; j < n; j++) {\r\n      if (d[j] < p) {\r\n        k = j;\r\n        p = d[j];\r\n      }\r\n    }\r\n\r\n    if (k !== i) {\r\n      d[k] = d[i];\r\n      d[i] = p;\r\n      for (j = 0; j < n; j++) {\r\n        p = V[j][i];\r\n        V[j][i] = V[j][k];\r\n        V[j][k] = p;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction orthes(n, H, ort, V) {\r\n  var low = 0;\r\n  var high = n - 1;\r\n  var f, g, h, i, j, m;\r\n  var scale;\r\n\r\n  for (m = low + 1; m <= high - 1; m++) {\r\n    scale = 0;\r\n    for (i = m; i <= high; i++) {\r\n      scale = scale + Math.abs(H[i][m - 1]);\r\n    }\r\n\r\n    if (scale !== 0) {\r\n      h = 0;\r\n      for (i = high; i >= m; i--) {\r\n        ort[i] = H[i][m - 1] / scale;\r\n        h += ort[i] * ort[i];\r\n      }\r\n\r\n      g = Math.sqrt(h);\r\n      if (ort[m] > 0) {\r\n        g = -g;\r\n      }\r\n\r\n      h = h - ort[m] * g;\r\n      ort[m] = ort[m] - g;\r\n\r\n      for (j = m; j < n; j++) {\r\n        f = 0;\r\n        for (i = high; i >= m; i--) {\r\n          f += ort[i] * H[i][j];\r\n        }\r\n\r\n        f = f / h;\r\n        for (i = m; i <= high; i++) {\r\n          H[i][j] -= f * ort[i];\r\n        }\r\n      }\r\n\r\n      for (i = 0; i <= high; i++) {\r\n        f = 0;\r\n        for (j = high; j >= m; j--) {\r\n          f += ort[j] * H[i][j];\r\n        }\r\n\r\n        f = f / h;\r\n        for (j = m; j <= high; j++) {\r\n          H[i][j] -= f * ort[j];\r\n        }\r\n      }\r\n\r\n      ort[m] = scale * ort[m];\r\n      H[m][m - 1] = scale * g;\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < n; i++) {\r\n    for (j = 0; j < n; j++) {\r\n      V[i][j] = i === j ? 1 : 0;\r\n    }\r\n  }\r\n\r\n  for (m = high - 1; m >= low + 1; m--) {\r\n    if (H[m][m - 1] !== 0) {\r\n      for (i = m + 1; i <= high; i++) {\r\n        ort[i] = H[i][m - 1];\r\n      }\r\n\r\n      for (j = m; j <= high; j++) {\r\n        g = 0;\r\n        for (i = m; i <= high; i++) {\r\n          g += ort[i] * V[i][j];\r\n        }\r\n\r\n        g = g / ort[m] / H[m][m - 1];\r\n        for (i = m; i <= high; i++) {\r\n          V[i][j] += g * ort[i];\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nfunction hqr2(nn, e, d, V, H) {\r\n  var n = nn - 1;\r\n  var low = 0;\r\n  var high = nn - 1;\r\n  var eps = Number.EPSILON;\r\n  var exshift = 0;\r\n  var norm = 0;\r\n  var p = 0;\r\n  var q = 0;\r\n  var r = 0;\r\n  var s = 0;\r\n  var z = 0;\r\n  var iter = 0;\r\n  var i, j, k, l, m, t, w, x, y;\r\n  var ra, sa, vr, vi;\r\n  var notlast, cdivres;\r\n\r\n  for (i = 0; i < nn; i++) {\r\n    if (i < low || i > high) {\r\n      d[i] = H[i][i];\r\n      e[i] = 0;\r\n    }\r\n\r\n    for (j = Math.max(i - 1, 0); j < nn; j++) {\r\n      norm = norm + Math.abs(H[i][j]);\r\n    }\r\n  }\r\n\r\n  while (n >= low) {\r\n    l = n;\r\n    while (l > low) {\r\n      s = Math.abs(H[l - 1][l - 1]) + Math.abs(H[l][l]);\r\n      if (s === 0) {\r\n        s = norm;\r\n      }\r\n      if (Math.abs(H[l][l - 1]) < eps * s) {\r\n        break;\r\n      }\r\n      l--;\r\n    }\r\n\r\n    if (l === n) {\r\n      H[n][n] = H[n][n] + exshift;\r\n      d[n] = H[n][n];\r\n      e[n] = 0;\r\n      n--;\r\n      iter = 0;\r\n    } else if (l === n - 1) {\r\n      w = H[n][n - 1] * H[n - 1][n];\r\n      p = (H[n - 1][n - 1] - H[n][n]) / 2;\r\n      q = p * p + w;\r\n      z = Math.sqrt(Math.abs(q));\r\n      H[n][n] = H[n][n] + exshift;\r\n      H[n - 1][n - 1] = H[n - 1][n - 1] + exshift;\r\n      x = H[n][n];\r\n\r\n      if (q >= 0) {\r\n        z = p >= 0 ? p + z : p - z;\r\n        d[n - 1] = x + z;\r\n        d[n] = d[n - 1];\r\n        if (z !== 0) {\r\n          d[n] = x - w / z;\r\n        }\r\n        e[n - 1] = 0;\r\n        e[n] = 0;\r\n        x = H[n][n - 1];\r\n        s = Math.abs(x) + Math.abs(z);\r\n        p = x / s;\r\n        q = z / s;\r\n        r = Math.sqrt(p * p + q * q);\r\n        p = p / r;\r\n        q = q / r;\r\n\r\n        for (j = n - 1; j < nn; j++) {\r\n          z = H[n - 1][j];\r\n          H[n - 1][j] = q * z + p * H[n][j];\r\n          H[n][j] = q * H[n][j] - p * z;\r\n        }\r\n\r\n        for (i = 0; i <= n; i++) {\r\n          z = H[i][n - 1];\r\n          H[i][n - 1] = q * z + p * H[i][n];\r\n          H[i][n] = q * H[i][n] - p * z;\r\n        }\r\n\r\n        for (i = low; i <= high; i++) {\r\n          z = V[i][n - 1];\r\n          V[i][n - 1] = q * z + p * V[i][n];\r\n          V[i][n] = q * V[i][n] - p * z;\r\n        }\r\n      } else {\r\n        d[n - 1] = x + p;\r\n        d[n] = x + p;\r\n        e[n - 1] = z;\r\n        e[n] = -z;\r\n      }\r\n\r\n      n = n - 2;\r\n      iter = 0;\r\n    } else {\r\n      x = H[n][n];\r\n      y = 0;\r\n      w = 0;\r\n      if (l < n) {\r\n        y = H[n - 1][n - 1];\r\n        w = H[n][n - 1] * H[n - 1][n];\r\n      }\r\n\r\n      if (iter === 10) {\r\n        exshift += x;\r\n        for (i = low; i <= n; i++) {\r\n          H[i][i] -= x;\r\n        }\r\n        s = Math.abs(H[n][n - 1]) + Math.abs(H[n - 1][n - 2]);\r\n        x = y = 0.75 * s;\r\n        w = -0.4375 * s * s;\r\n      }\r\n\r\n      if (iter === 30) {\r\n        s = (y - x) / 2;\r\n        s = s * s + w;\r\n        if (s > 0) {\r\n          s = Math.sqrt(s);\r\n          if (y < x) {\r\n            s = -s;\r\n          }\r\n          s = x - w / ((y - x) / 2 + s);\r\n          for (i = low; i <= n; i++) {\r\n            H[i][i] -= s;\r\n          }\r\n          exshift += s;\r\n          x = y = w = 0.964;\r\n        }\r\n      }\r\n\r\n      iter = iter + 1;\r\n\r\n      m = n - 2;\r\n      while (m >= l) {\r\n        z = H[m][m];\r\n        r = x - z;\r\n        s = y - z;\r\n        p = (r * s - w) / H[m + 1][m] + H[m][m + 1];\r\n        q = H[m + 1][m + 1] - z - r - s;\r\n        r = H[m + 2][m + 1];\r\n        s = Math.abs(p) + Math.abs(q) + Math.abs(r);\r\n        p = p / s;\r\n        q = q / s;\r\n        r = r / s;\r\n        if (m === l) {\r\n          break;\r\n        }\r\n        if (\r\n          Math.abs(H[m][m - 1]) * (Math.abs(q) + Math.abs(r)) <\r\n          eps *\r\n            (Math.abs(p) *\r\n              (Math.abs(H[m - 1][m - 1]) +\r\n                Math.abs(z) +\r\n                Math.abs(H[m + 1][m + 1])))\r\n        ) {\r\n          break;\r\n        }\r\n        m--;\r\n      }\r\n\r\n      for (i = m + 2; i <= n; i++) {\r\n        H[i][i - 2] = 0;\r\n        if (i > m + 2) {\r\n          H[i][i - 3] = 0;\r\n        }\r\n      }\r\n\r\n      for (k = m; k <= n - 1; k++) {\r\n        notlast = k !== n - 1;\r\n        if (k !== m) {\r\n          p = H[k][k - 1];\r\n          q = H[k + 1][k - 1];\r\n          r = notlast ? H[k + 2][k - 1] : 0;\r\n          x = Math.abs(p) + Math.abs(q) + Math.abs(r);\r\n          if (x !== 0) {\r\n            p = p / x;\r\n            q = q / x;\r\n            r = r / x;\r\n          }\r\n        }\r\n\r\n        if (x === 0) {\r\n          break;\r\n        }\r\n\r\n        s = Math.sqrt(p * p + q * q + r * r);\r\n        if (p < 0) {\r\n          s = -s;\r\n        }\r\n\r\n        if (s !== 0) {\r\n          if (k !== m) {\r\n            H[k][k - 1] = -s * x;\r\n          } else if (l !== m) {\r\n            H[k][k - 1] = -H[k][k - 1];\r\n          }\r\n\r\n          p = p + s;\r\n          x = p / s;\r\n          y = q / s;\r\n          z = r / s;\r\n          q = q / p;\r\n          r = r / p;\r\n\r\n          for (j = k; j < nn; j++) {\r\n            p = H[k][j] + q * H[k + 1][j];\r\n            if (notlast) {\r\n              p = p + r * H[k + 2][j];\r\n              H[k + 2][j] = H[k + 2][j] - p * z;\r\n            }\r\n\r\n            H[k][j] = H[k][j] - p * x;\r\n            H[k + 1][j] = H[k + 1][j] - p * y;\r\n          }\r\n\r\n          for (i = 0; i <= Math.min(n, k + 3); i++) {\r\n            p = x * H[i][k] + y * H[i][k + 1];\r\n            if (notlast) {\r\n              p = p + z * H[i][k + 2];\r\n              H[i][k + 2] = H[i][k + 2] - p * r;\r\n            }\r\n\r\n            H[i][k] = H[i][k] - p;\r\n            H[i][k + 1] = H[i][k + 1] - p * q;\r\n          }\r\n\r\n          for (i = low; i <= high; i++) {\r\n            p = x * V[i][k] + y * V[i][k + 1];\r\n            if (notlast) {\r\n              p = p + z * V[i][k + 2];\r\n              V[i][k + 2] = V[i][k + 2] - p * r;\r\n            }\r\n\r\n            V[i][k] = V[i][k] - p;\r\n            V[i][k + 1] = V[i][k + 1] - p * q;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  if (norm === 0) {\r\n    return;\r\n  }\r\n\r\n  for (n = nn - 1; n >= 0; n--) {\r\n    p = d[n];\r\n    q = e[n];\r\n\r\n    if (q === 0) {\r\n      l = n;\r\n      H[n][n] = 1;\r\n      for (i = n - 1; i >= 0; i--) {\r\n        w = H[i][i] - p;\r\n        r = 0;\r\n        for (j = l; j <= n; j++) {\r\n          r = r + H[i][j] * H[j][n];\r\n        }\r\n\r\n        if (e[i] < 0) {\r\n          z = w;\r\n          s = r;\r\n        } else {\r\n          l = i;\r\n          if (e[i] === 0) {\r\n            H[i][n] = w !== 0 ? -r / w : -r / (eps * norm);\r\n          } else {\r\n            x = H[i][i + 1];\r\n            y = H[i + 1][i];\r\n            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\r\n            t = (x * s - z * r) / q;\r\n            H[i][n] = t;\r\n            H[i + 1][n] =\r\n              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z;\r\n          }\r\n\r\n          t = Math.abs(H[i][n]);\r\n          if (eps * t * t > 1) {\r\n            for (j = i; j <= n; j++) {\r\n              H[j][n] = H[j][n] / t;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } else if (q < 0) {\r\n      l = n - 1;\r\n\r\n      if (Math.abs(H[n][n - 1]) > Math.abs(H[n - 1][n])) {\r\n        H[n - 1][n - 1] = q / H[n][n - 1];\r\n        H[n - 1][n] = -(H[n][n] - p) / H[n][n - 1];\r\n      } else {\r\n        cdivres = cdiv(0, -H[n - 1][n], H[n - 1][n - 1] - p, q);\r\n        H[n - 1][n - 1] = cdivres[0];\r\n        H[n - 1][n] = cdivres[1];\r\n      }\r\n\r\n      H[n][n - 1] = 0;\r\n      H[n][n] = 1;\r\n      for (i = n - 2; i >= 0; i--) {\r\n        ra = 0;\r\n        sa = 0;\r\n        for (j = l; j <= n; j++) {\r\n          ra = ra + H[i][j] * H[j][n - 1];\r\n          sa = sa + H[i][j] * H[j][n];\r\n        }\r\n\r\n        w = H[i][i] - p;\r\n\r\n        if (e[i] < 0) {\r\n          z = w;\r\n          r = ra;\r\n          s = sa;\r\n        } else {\r\n          l = i;\r\n          if (e[i] === 0) {\r\n            cdivres = cdiv(-ra, -sa, w, q);\r\n            H[i][n - 1] = cdivres[0];\r\n            H[i][n] = cdivres[1];\r\n          } else {\r\n            x = H[i][i + 1];\r\n            y = H[i + 1][i];\r\n            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\r\n            vi = (d[i] - p) * 2 * q;\r\n            if (vr === 0 && vi === 0) {\r\n              vr =\r\n                eps *\r\n                norm *\r\n                (Math.abs(w) +\r\n                  Math.abs(q) +\r\n                  Math.abs(x) +\r\n                  Math.abs(y) +\r\n                  Math.abs(z));\r\n            }\r\n            cdivres = cdiv(\r\n              x * r - z * ra + q * sa,\r\n              x * s - z * sa - q * ra,\r\n              vr,\r\n              vi\r\n            );\r\n            H[i][n - 1] = cdivres[0];\r\n            H[i][n] = cdivres[1];\r\n            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {\r\n              H[i + 1][n - 1] = (-ra - w * H[i][n - 1] + q * H[i][n]) / x;\r\n              H[i + 1][n] = (-sa - w * H[i][n] - q * H[i][n - 1]) / x;\r\n            } else {\r\n              cdivres = cdiv(-r - y * H[i][n - 1], -s - y * H[i][n], z, q);\r\n              H[i + 1][n - 1] = cdivres[0];\r\n              H[i + 1][n] = cdivres[1];\r\n            }\r\n          }\r\n\r\n          t = Math.max(Math.abs(H[i][n - 1]), Math.abs(H[i][n]));\r\n          if (eps * t * t > 1) {\r\n            for (j = i; j <= n; j++) {\r\n              H[j][n - 1] = H[j][n - 1] / t;\r\n              H[j][n] = H[j][n] / t;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  for (i = 0; i < nn; i++) {\r\n    if (i < low || i > high) {\r\n      for (j = i; j < nn; j++) {\r\n        V[i][j] = H[i][j];\r\n      }\r\n    }\r\n  }\r\n\r\n  for (j = nn - 1; j >= low; j--) {\r\n    for (i = low; i <= high; i++) {\r\n      z = 0;\r\n      for (k = low; k <= Math.min(j, high); k++) {\r\n        z = z + V[i][k] * H[k][j];\r\n      }\r\n      V[i][j] = z;\r\n    }\r\n  }\r\n}\r\n\r\nfunction cdiv(xr, xi, yr, yi) {\r\n  var r, d;\r\n  if (Math.abs(yr) > Math.abs(yi)) {\r\n    r = yi / yr;\r\n    d = yr + r * yi;\r\n    return [(xr + r * xi) / d, (xi - r * xr) / d];\r\n  } else {\r\n    r = yr / yi;\r\n    d = yi + r * yr;\r\n    return [(r * xr + xi) / d, (r * xi - xr) / d];\r\n  }\r\n}\r\n","import { Matrix, WrapperMatrix2D } from '../index';\r\n\r\n/**\r\n * @class LuDecomposition\r\n * @link https://github.com/lutzroeder/Mapack/blob/master/Source/LuDecomposition.cs\r\n * @param {Matrix} matrix\r\n */\r\nexport default class LuDecomposition {\r\n  constructor(matrix) {\r\n    matrix = WrapperMatrix2D.checkMatrix(matrix);\r\n\r\n    var lu = matrix.clone();\r\n    var rows = lu.rows;\r\n    var columns = lu.columns;\r\n    var pivotVector = new Array(rows);\r\n    var pivotSign = 1;\r\n    var i, j, k, p, s, t, v;\r\n    var LUcolj, kmax;\r\n\r\n    for (i = 0; i < rows; i++) {\r\n      pivotVector[i] = i;\r\n    }\r\n\r\n    LUcolj = new Array(rows);\r\n\r\n    for (j = 0; j < columns; j++) {\r\n      for (i = 0; i < rows; i++) {\r\n        LUcolj[i] = lu.get(i, j);\r\n      }\r\n\r\n      for (i = 0; i < rows; i++) {\r\n        kmax = Math.min(i, j);\r\n        s = 0;\r\n        for (k = 0; k < kmax; k++) {\r\n          s += lu.get(i, k) * LUcolj[k];\r\n        }\r\n        LUcolj[i] -= s;\r\n        lu.set(i, j, LUcolj[i]);\r\n      }\r\n\r\n      p = j;\r\n      for (i = j + 1; i < rows; i++) {\r\n        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {\r\n          p = i;\r\n        }\r\n      }\r\n\r\n      if (p !== j) {\r\n        for (k = 0; k < columns; k++) {\r\n          t = lu.get(p, k);\r\n          lu.set(p, k, lu.get(j, k));\r\n          lu.set(j, k, t);\r\n        }\r\n\r\n        v = pivotVector[p];\r\n        pivotVector[p] = pivotVector[j];\r\n        pivotVector[j] = v;\r\n\r\n        pivotSign = -pivotSign;\r\n      }\r\n\r\n      if (j < rows && lu.get(j, j) !== 0) {\r\n        for (i = j + 1; i < rows; i++) {\r\n          lu.set(i, j, lu.get(i, j) / lu.get(j, j));\r\n        }\r\n      }\r\n    }\r\n\r\n    this.LU = lu;\r\n    this.pivotVector = pivotVector;\r\n    this.pivotSign = pivotSign;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  isSingular() {\r\n    var data = this.LU;\r\n    var col = data.columns;\r\n    for (var j = 0; j < col; j++) {\r\n      if (data[j][j] === 0) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Matrix} value\r\n   * @return {Matrix}\r\n   */\r\n  solve(value) {\r\n    value = Matrix.checkMatrix(value);\r\n\r\n    var lu = this.LU;\r\n    var rows = lu.rows;\r\n\r\n    if (rows !== value.rows) {\r\n      throw new Error('Invalid matrix dimensions');\r\n    }\r\n    if (this.isSingular()) {\r\n      throw new Error('LU matrix is singular');\r\n    }\r\n\r\n    var count = value.columns;\r\n    var X = value.subMatrixRow(this.pivotVector, 0, count - 1);\r\n    var columns = lu.columns;\r\n    var i, j, k;\r\n\r\n    for (k = 0; k < columns; k++) {\r\n      for (i = k + 1; i < columns; i++) {\r\n        for (j = 0; j < count; j++) {\r\n          X[i][j] -= X[k][j] * lu[i][k];\r\n        }\r\n      }\r\n    }\r\n    for (k = columns - 1; k >= 0; k--) {\r\n      for (j = 0; j < count; j++) {\r\n        X[k][j] /= lu[k][k];\r\n      }\r\n      for (i = 0; i < k; i++) {\r\n        for (j = 0; j < count; j++) {\r\n          X[i][j] -= X[k][j] * lu[i][k];\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {number}\r\n   */\r\n  get determinant() {\r\n    var data = this.LU;\r\n    if (!data.isSquare()) {\r\n      throw new Error('Matrix must be square');\r\n    }\r\n    var determinant = this.pivotSign;\r\n    var col = data.columns;\r\n    for (var j = 0; j < col; j++) {\r\n      determinant *= data[j][j];\r\n    }\r\n    return determinant;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get lowerTriangularMatrix() {\r\n    var data = this.LU;\r\n    var rows = data.rows;\r\n    var columns = data.columns;\r\n    var X = new Matrix(rows, columns);\r\n    for (var i = 0; i < rows; i++) {\r\n      for (var j = 0; j < columns; j++) {\r\n        if (i > j) {\r\n          X[i][j] = data[i][j];\r\n        } else if (i === j) {\r\n          X[i][j] = 1;\r\n        } else {\r\n          X[i][j] = 0;\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get upperTriangularMatrix() {\r\n    var data = this.LU;\r\n    var rows = data.rows;\r\n    var columns = data.columns;\r\n    var X = new Matrix(rows, columns);\r\n    for (var i = 0; i < rows; i++) {\r\n      for (var j = 0; j < columns; j++) {\r\n        if (i <= j) {\r\n          X[i][j] = data[i][j];\r\n        } else {\r\n          X[i][j] = 0;\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Array<number>}\r\n   */\r\n  get pivotPermutationVector() {\r\n    return this.pivotVector.slice();\r\n  }\r\n}\r\n","import { Matrix, WrapperMatrix2D } from '../index';\r\n\r\nimport { hypotenuse } from './util';\r\n\r\n/**\r\n * @class QrDecomposition\r\n * @link https://github.com/lutzroeder/Mapack/blob/master/Source/QrDecomposition.cs\r\n * @param {Matrix} value\r\n */\r\nexport default class QrDecomposition {\r\n  constructor(value) {\r\n    value = WrapperMatrix2D.checkMatrix(value);\r\n\r\n    var qr = value.clone();\r\n    var m = value.rows;\r\n    var n = value.columns;\r\n    var rdiag = new Array(n);\r\n    var i, j, k, s;\r\n\r\n    for (k = 0; k < n; k++) {\r\n      var nrm = 0;\r\n      for (i = k; i < m; i++) {\r\n        nrm = hypotenuse(nrm, qr.get(i, k));\r\n      }\r\n      if (nrm !== 0) {\r\n        if (qr.get(k, k) < 0) {\r\n          nrm = -nrm;\r\n        }\r\n        for (i = k; i < m; i++) {\r\n          qr.set(i, k, qr.get(i, k) / nrm);\r\n        }\r\n        qr.set(k, k, qr.get(k, k) + 1);\r\n        for (j = k + 1; j < n; j++) {\r\n          s = 0;\r\n          for (i = k; i < m; i++) {\r\n            s += qr.get(i, k) * qr.get(i, j);\r\n          }\r\n          s = -s / qr.get(k, k);\r\n          for (i = k; i < m; i++) {\r\n            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));\r\n          }\r\n        }\r\n      }\r\n      rdiag[k] = -nrm;\r\n    }\r\n\r\n    this.QR = qr;\r\n    this.Rdiag = rdiag;\r\n  }\r\n\r\n  /**\r\n   * Solve a problem of least square (Ax=b) by using the QR decomposition. Useful when A is rectangular, but not working when A is singular.\r\n   * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :\r\n   * var qr = QrDecomposition(A);\r\n   * var x = qr.solve(b);\r\n   * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)\r\n   * @return {Matrix} - The vector x\r\n   */\r\n  solve(value) {\r\n    value = Matrix.checkMatrix(value);\r\n\r\n    var qr = this.QR;\r\n    var m = qr.rows;\r\n\r\n    if (value.rows !== m) {\r\n      throw new Error('Matrix row dimensions must agree');\r\n    }\r\n    if (!this.isFullRank()) {\r\n      throw new Error('Matrix is rank deficient');\r\n    }\r\n\r\n    var count = value.columns;\r\n    var X = value.clone();\r\n    var n = qr.columns;\r\n    var i, j, k, s;\r\n\r\n    for (k = 0; k < n; k++) {\r\n      for (j = 0; j < count; j++) {\r\n        s = 0;\r\n        for (i = k; i < m; i++) {\r\n          s += qr[i][k] * X[i][j];\r\n        }\r\n        s = -s / qr[k][k];\r\n        for (i = k; i < m; i++) {\r\n          X[i][j] += s * qr[i][k];\r\n        }\r\n      }\r\n    }\r\n    for (k = n - 1; k >= 0; k--) {\r\n      for (j = 0; j < count; j++) {\r\n        X[k][j] /= this.Rdiag[k];\r\n      }\r\n      for (i = 0; i < k; i++) {\r\n        for (j = 0; j < count; j++) {\r\n          X[i][j] -= X[k][j] * qr[i][k];\r\n        }\r\n      }\r\n    }\r\n\r\n    return X.subMatrix(0, n - 1, 0, count - 1);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {boolean}\r\n   */\r\n  isFullRank() {\r\n    var columns = this.QR.columns;\r\n    for (var i = 0; i < columns; i++) {\r\n      if (this.Rdiag[i] === 0) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get upperTriangularMatrix() {\r\n    var qr = this.QR;\r\n    var n = qr.columns;\r\n    var X = new Matrix(n, n);\r\n    var i, j;\r\n    for (i = 0; i < n; i++) {\r\n      for (j = 0; j < n; j++) {\r\n        if (i < j) {\r\n          X[i][j] = qr[i][j];\r\n        } else if (i === j) {\r\n          X[i][j] = this.Rdiag[i];\r\n        } else {\r\n          X[i][j] = 0;\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get orthogonalMatrix() {\r\n    var qr = this.QR;\r\n    var rows = qr.rows;\r\n    var columns = qr.columns;\r\n    var X = new Matrix(rows, columns);\r\n    var i, j, k, s;\r\n\r\n    for (k = columns - 1; k >= 0; k--) {\r\n      for (i = 0; i < rows; i++) {\r\n        X[i][k] = 0;\r\n      }\r\n      X[k][k] = 1;\r\n      for (j = k; j < columns; j++) {\r\n        if (qr[k][k] !== 0) {\r\n          s = 0;\r\n          for (i = k; i < rows; i++) {\r\n            s += qr[i][k] * X[i][j];\r\n          }\r\n\r\n          s = -s / qr[k][k];\r\n\r\n          for (i = k; i < rows; i++) {\r\n            X[i][j] += s * qr[i][k];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return X;\r\n  }\r\n}\r\n","import { Matrix, WrapperMatrix2D } from '../index';\r\n\r\nimport { hypotenuse, getFilled2DArray } from './util';\r\n\r\n/**\r\n * @class SingularValueDecomposition\r\n * @see https://github.com/accord-net/framework/blob/development/Sources/Accord.Math/Decompositions/SingularValueDecomposition.cs\r\n * @param {Matrix} value\r\n * @param {object} [options]\r\n * @param {boolean} [options.computeLeftSingularVectors=true]\r\n * @param {boolean} [options.computeRightSingularVectors=true]\r\n * @param {boolean} [options.autoTranspose=false]\r\n */\r\nexport default class SingularValueDecomposition {\r\n  constructor(value, options = {}) {\r\n    value = WrapperMatrix2D.checkMatrix(value);\r\n\r\n    var m = value.rows;\r\n    var n = value.columns;\r\n\r\n    const {\r\n      computeLeftSingularVectors = true,\r\n      computeRightSingularVectors = true,\r\n      autoTranspose = false\r\n    } = options;\r\n\r\n    var wantu = Boolean(computeLeftSingularVectors);\r\n    var wantv = Boolean(computeRightSingularVectors);\r\n\r\n    var swapped = false;\r\n    var a;\r\n    if (m < n) {\r\n      if (!autoTranspose) {\r\n        a = value.clone();\r\n        // eslint-disable-next-line no-console\r\n        console.warn(\r\n          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose'\r\n        );\r\n      } else {\r\n        a = value.transpose();\r\n        m = a.rows;\r\n        n = a.columns;\r\n        swapped = true;\r\n        var aux = wantu;\r\n        wantu = wantv;\r\n        wantv = aux;\r\n      }\r\n    } else {\r\n      a = value.clone();\r\n    }\r\n\r\n    var nu = Math.min(m, n);\r\n    var ni = Math.min(m + 1, n);\r\n    var s = new Array(ni);\r\n    var U = getFilled2DArray(m, nu, 0);\r\n    var V = getFilled2DArray(n, n, 0);\r\n\r\n    var e = new Array(n);\r\n    var work = new Array(m);\r\n\r\n    var si = new Array(ni);\r\n    for (let i = 0; i < ni; i++) si[i] = i;\r\n\r\n    var nct = Math.min(m - 1, n);\r\n    var nrt = Math.max(0, Math.min(n - 2, m));\r\n    var mrc = Math.max(nct, nrt);\r\n\r\n    for (let k = 0; k < mrc; k++) {\r\n      if (k < nct) {\r\n        s[k] = 0;\r\n        for (let i = k; i < m; i++) {\r\n          s[k] = hypotenuse(s[k], a[i][k]);\r\n        }\r\n        if (s[k] !== 0) {\r\n          if (a[k][k] < 0) {\r\n            s[k] = -s[k];\r\n          }\r\n          for (let i = k; i < m; i++) {\r\n            a[i][k] /= s[k];\r\n          }\r\n          a[k][k] += 1;\r\n        }\r\n        s[k] = -s[k];\r\n      }\r\n\r\n      for (let j = k + 1; j < n; j++) {\r\n        if (k < nct && s[k] !== 0) {\r\n          let t = 0;\r\n          for (let i = k; i < m; i++) {\r\n            t += a[i][k] * a[i][j];\r\n          }\r\n          t = -t / a[k][k];\r\n          for (let i = k; i < m; i++) {\r\n            a[i][j] += t * a[i][k];\r\n          }\r\n        }\r\n        e[j] = a[k][j];\r\n      }\r\n\r\n      if (wantu && k < nct) {\r\n        for (let i = k; i < m; i++) {\r\n          U[i][k] = a[i][k];\r\n        }\r\n      }\r\n\r\n      if (k < nrt) {\r\n        e[k] = 0;\r\n        for (let i = k + 1; i < n; i++) {\r\n          e[k] = hypotenuse(e[k], e[i]);\r\n        }\r\n        if (e[k] !== 0) {\r\n          if (e[k + 1] < 0) {\r\n            e[k] = 0 - e[k];\r\n          }\r\n          for (let i = k + 1; i < n; i++) {\r\n            e[i] /= e[k];\r\n          }\r\n          e[k + 1] += 1;\r\n        }\r\n        e[k] = -e[k];\r\n        if (k + 1 < m && e[k] !== 0) {\r\n          for (let i = k + 1; i < m; i++) {\r\n            work[i] = 0;\r\n          }\r\n          for (let i = k + 1; i < m; i++) {\r\n            for (let j = k + 1; j < n; j++) {\r\n              work[i] += e[j] * a[i][j];\r\n            }\r\n          }\r\n          for (let j = k + 1; j < n; j++) {\r\n            let t = -e[j] / e[k + 1];\r\n            for (let i = k + 1; i < m; i++) {\r\n              a[i][j] += t * work[i];\r\n            }\r\n          }\r\n        }\r\n        if (wantv) {\r\n          for (let i = k + 1; i < n; i++) {\r\n            V[i][k] = e[i];\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    let p = Math.min(n, m + 1);\r\n    if (nct < n) {\r\n      s[nct] = a[nct][nct];\r\n    }\r\n    if (m < p) {\r\n      s[p - 1] = 0;\r\n    }\r\n    if (nrt + 1 < p) {\r\n      e[nrt] = a[nrt][p - 1];\r\n    }\r\n    e[p - 1] = 0;\r\n\r\n    if (wantu) {\r\n      for (let j = nct; j < nu; j++) {\r\n        for (let i = 0; i < m; i++) {\r\n          U[i][j] = 0;\r\n        }\r\n        U[j][j] = 1;\r\n      }\r\n      for (let k = nct - 1; k >= 0; k--) {\r\n        if (s[k] !== 0) {\r\n          for (let j = k + 1; j < nu; j++) {\r\n            let t = 0;\r\n            for (let i = k; i < m; i++) {\r\n              t += U[i][k] * U[i][j];\r\n            }\r\n            t = -t / U[k][k];\r\n            for (let i = k; i < m; i++) {\r\n              U[i][j] += t * U[i][k];\r\n            }\r\n          }\r\n          for (let i = k; i < m; i++) {\r\n            U[i][k] = -U[i][k];\r\n          }\r\n          U[k][k] = 1 + U[k][k];\r\n          for (let i = 0; i < k - 1; i++) {\r\n            U[i][k] = 0;\r\n          }\r\n        } else {\r\n          for (let i = 0; i < m; i++) {\r\n            U[i][k] = 0;\r\n          }\r\n          U[k][k] = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (wantv) {\r\n      for (let k = n - 1; k >= 0; k--) {\r\n        if (k < nrt && e[k] !== 0) {\r\n          for (let j = k + 1; j < n; j++) {\r\n            let t = 0;\r\n            for (let i = k + 1; i < n; i++) {\r\n              t += V[i][k] * V[i][j];\r\n            }\r\n            t = -t / V[k + 1][k];\r\n            for (let i = k + 1; i < n; i++) {\r\n              V[i][j] += t * V[i][k];\r\n            }\r\n          }\r\n        }\r\n        for (let i = 0; i < n; i++) {\r\n          V[i][k] = 0;\r\n        }\r\n        V[k][k] = 1;\r\n      }\r\n    }\r\n\r\n    var pp = p - 1;\r\n    var iter = 0;\r\n    var eps = Number.EPSILON;\r\n    while (p > 0) {\r\n      let k, kase;\r\n      for (k = p - 2; k >= -1; k--) {\r\n        if (k === -1) {\r\n          break;\r\n        }\r\n        const alpha =\r\n          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));\r\n        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {\r\n          e[k] = 0;\r\n          break;\r\n        }\r\n      }\r\n      if (k === p - 2) {\r\n        kase = 4;\r\n      } else {\r\n        let ks;\r\n        for (ks = p - 1; ks >= k; ks--) {\r\n          if (ks === k) {\r\n            break;\r\n          }\r\n          let t =\r\n            (ks !== p ? Math.abs(e[ks]) : 0) +\r\n            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);\r\n          if (Math.abs(s[ks]) <= eps * t) {\r\n            s[ks] = 0;\r\n            break;\r\n          }\r\n        }\r\n        if (ks === k) {\r\n          kase = 3;\r\n        } else if (ks === p - 1) {\r\n          kase = 1;\r\n        } else {\r\n          kase = 2;\r\n          k = ks;\r\n        }\r\n      }\r\n\r\n      k++;\r\n\r\n      switch (kase) {\r\n        case 1: {\r\n          let f = e[p - 2];\r\n          e[p - 2] = 0;\r\n          for (let j = p - 2; j >= k; j--) {\r\n            let t = hypotenuse(s[j], f);\r\n            let cs = s[j] / t;\r\n            let sn = f / t;\r\n            s[j] = t;\r\n            if (j !== k) {\r\n              f = -sn * e[j - 1];\r\n              e[j - 1] = cs * e[j - 1];\r\n            }\r\n            if (wantv) {\r\n              for (let i = 0; i < n; i++) {\r\n                t = cs * V[i][j] + sn * V[i][p - 1];\r\n                V[i][p - 1] = -sn * V[i][j] + cs * V[i][p - 1];\r\n                V[i][j] = t;\r\n              }\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case 2: {\r\n          let f = e[k - 1];\r\n          e[k - 1] = 0;\r\n          for (let j = k; j < p; j++) {\r\n            let t = hypotenuse(s[j], f);\r\n            let cs = s[j] / t;\r\n            let sn = f / t;\r\n            s[j] = t;\r\n            f = -sn * e[j];\r\n            e[j] = cs * e[j];\r\n            if (wantu) {\r\n              for (let i = 0; i < m; i++) {\r\n                t = cs * U[i][j] + sn * U[i][k - 1];\r\n                U[i][k - 1] = -sn * U[i][j] + cs * U[i][k - 1];\r\n                U[i][j] = t;\r\n              }\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case 3: {\r\n          const scale = Math.max(\r\n            Math.abs(s[p - 1]),\r\n            Math.abs(s[p - 2]),\r\n            Math.abs(e[p - 2]),\r\n            Math.abs(s[k]),\r\n            Math.abs(e[k])\r\n          );\r\n          const sp = s[p - 1] / scale;\r\n          const spm1 = s[p - 2] / scale;\r\n          const epm1 = e[p - 2] / scale;\r\n          const sk = s[k] / scale;\r\n          const ek = e[k] / scale;\r\n          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;\r\n          const c = sp * epm1 * (sp * epm1);\r\n          let shift = 0;\r\n          if (b !== 0 || c !== 0) {\r\n            if (b < 0) {\r\n              shift = 0 - Math.sqrt(b * b + c);\r\n            } else {\r\n              shift = Math.sqrt(b * b + c);\r\n            }\r\n            shift = c / (b + shift);\r\n          }\r\n          let f = (sk + sp) * (sk - sp) + shift;\r\n          let g = sk * ek;\r\n          for (let j = k; j < p - 1; j++) {\r\n            let t = hypotenuse(f, g);\r\n            if (t === 0) t = Number.MIN_VALUE;\r\n            let cs = f / t;\r\n            let sn = g / t;\r\n            if (j !== k) {\r\n              e[j - 1] = t;\r\n            }\r\n            f = cs * s[j] + sn * e[j];\r\n            e[j] = cs * e[j] - sn * s[j];\r\n            g = sn * s[j + 1];\r\n            s[j + 1] = cs * s[j + 1];\r\n            if (wantv) {\r\n              for (let i = 0; i < n; i++) {\r\n                t = cs * V[i][j] + sn * V[i][j + 1];\r\n                V[i][j + 1] = -sn * V[i][j] + cs * V[i][j + 1];\r\n                V[i][j] = t;\r\n              }\r\n            }\r\n            t = hypotenuse(f, g);\r\n            if (t === 0) t = Number.MIN_VALUE;\r\n            cs = f / t;\r\n            sn = g / t;\r\n            s[j] = t;\r\n            f = cs * e[j] + sn * s[j + 1];\r\n            s[j + 1] = -sn * e[j] + cs * s[j + 1];\r\n            g = sn * e[j + 1];\r\n            e[j + 1] = cs * e[j + 1];\r\n            if (wantu && j < m - 1) {\r\n              for (let i = 0; i < m; i++) {\r\n                t = cs * U[i][j] + sn * U[i][j + 1];\r\n                U[i][j + 1] = -sn * U[i][j] + cs * U[i][j + 1];\r\n                U[i][j] = t;\r\n              }\r\n            }\r\n          }\r\n          e[p - 2] = f;\r\n          iter = iter + 1;\r\n          break;\r\n        }\r\n        case 4: {\r\n          if (s[k] <= 0) {\r\n            s[k] = s[k] < 0 ? -s[k] : 0;\r\n            if (wantv) {\r\n              for (let i = 0; i <= pp; i++) {\r\n                V[i][k] = -V[i][k];\r\n              }\r\n            }\r\n          }\r\n          while (k < pp) {\r\n            if (s[k] >= s[k + 1]) {\r\n              break;\r\n            }\r\n            let t = s[k];\r\n            s[k] = s[k + 1];\r\n            s[k + 1] = t;\r\n            if (wantv && k < n - 1) {\r\n              for (let i = 0; i < n; i++) {\r\n                t = V[i][k + 1];\r\n                V[i][k + 1] = V[i][k];\r\n                V[i][k] = t;\r\n              }\r\n            }\r\n            if (wantu && k < m - 1) {\r\n              for (let i = 0; i < m; i++) {\r\n                t = U[i][k + 1];\r\n                U[i][k + 1] = U[i][k];\r\n                U[i][k] = t;\r\n              }\r\n            }\r\n            k++;\r\n          }\r\n          iter = 0;\r\n          p--;\r\n          break;\r\n        }\r\n        // no default\r\n      }\r\n    }\r\n\r\n    if (swapped) {\r\n      var tmp = V;\r\n      V = U;\r\n      U = tmp;\r\n    }\r\n\r\n    this.m = m;\r\n    this.n = n;\r\n    this.s = s;\r\n    this.U = U;\r\n    this.V = V;\r\n  }\r\n\r\n  /**\r\n   * Solve a problem of least square (Ax=b) by using the SVD. Useful when A is singular. When A is not singular, it would be better to use qr.solve(value).\r\n   * Example : We search to approximate x, with A matrix shape m*n, x vector size n, b vector size m (m > n). We will use :\r\n   * var svd = SingularValueDecomposition(A);\r\n   * var x = svd.solve(b);\r\n   * @param {Matrix} value - Matrix 1D which is the vector b (in the equation Ax = b)\r\n   * @return {Matrix} - The vector x\r\n   */\r\n  solve(value) {\r\n    var Y = value;\r\n    var e = this.threshold;\r\n    var scols = this.s.length;\r\n    var Ls = Matrix.zeros(scols, scols);\r\n\r\n    for (let i = 0; i < scols; i++) {\r\n      if (Math.abs(this.s[i]) <= e) {\r\n        Ls[i][i] = 0;\r\n      } else {\r\n        Ls[i][i] = 1 / this.s[i];\r\n      }\r\n    }\r\n\r\n    var U = this.U;\r\n    var V = this.rightSingularVectors;\r\n\r\n    var VL = V.mmul(Ls);\r\n    var vrows = V.rows;\r\n    var urows = U.length;\r\n    var VLU = Matrix.zeros(vrows, urows);\r\n\r\n    for (let i = 0; i < vrows; i++) {\r\n      for (let j = 0; j < urows; j++) {\r\n        let sum = 0;\r\n        for (let k = 0; k < scols; k++) {\r\n          sum += VL[i][k] * U[j][k];\r\n        }\r\n        VLU[i][j] = sum;\r\n      }\r\n    }\r\n\r\n    return VLU.mmul(Y);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {Array<number>} value\r\n   * @return {Matrix}\r\n   */\r\n  solveForDiagonal(value) {\r\n    return this.solve(Matrix.diag(value));\r\n  }\r\n\r\n  /**\r\n   * Get the inverse of the matrix. We compute the inverse of a matrix using SVD when this matrix is singular or ill-conditioned. Example :\r\n   * var svd = SingularValueDecomposition(A);\r\n   * var inverseA = svd.inverse();\r\n   * @return {Matrix} - The approximation of the inverse of the matrix\r\n   */\r\n  inverse() {\r\n    var V = this.V;\r\n    var e = this.threshold;\r\n    var vrows = V.length;\r\n    var vcols = V[0].length;\r\n    var X = new Matrix(vrows, this.s.length);\r\n\r\n    for (let i = 0; i < vrows; i++) {\r\n      for (let j = 0; j < vcols; j++) {\r\n        if (Math.abs(this.s[j]) > e) {\r\n          X[i][j] = V[i][j] / this.s[j];\r\n        } else {\r\n          X[i][j] = 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    var U = this.U;\r\n\r\n    var urows = U.length;\r\n    var ucols = U[0].length;\r\n    var Y = new Matrix(vrows, urows);\r\n\r\n    for (let i = 0; i < vrows; i++) {\r\n      for (let j = 0; j < urows; j++) {\r\n        let sum = 0;\r\n        for (let k = 0; k < ucols; k++) {\r\n          sum += X[i][k] * U[j][k];\r\n        }\r\n        Y[i][j] = sum;\r\n      }\r\n    }\r\n\r\n    return Y;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {number}\r\n   */\r\n  get condition() {\r\n    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {number}\r\n   */\r\n  get norm2() {\r\n    return this.s[0];\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {number}\r\n   */\r\n  get rank() {\r\n    var tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;\r\n    var r = 0;\r\n    var s = this.s;\r\n    for (var i = 0, ii = s.length; i < ii; i++) {\r\n      if (s[i] > tol) {\r\n        r++;\r\n      }\r\n    }\r\n    return r;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Array<number>}\r\n   */\r\n  get diagonal() {\r\n    return this.s;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {number}\r\n   */\r\n  get threshold() {\r\n    return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get leftSingularVectors() {\r\n    if (!Matrix.isMatrix(this.U)) {\r\n      this.U = new Matrix(this.U);\r\n    }\r\n    return this.U;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get rightSingularVectors() {\r\n    if (!Matrix.isMatrix(this.V)) {\r\n      this.V = new Matrix(this.V);\r\n    }\r\n    return this.V;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @return {Matrix}\r\n   */\r\n  get diagonalMatrix() {\r\n    return Matrix.diag(this.s);\r\n  }\r\n}\r\n","export function hypotenuse(a, b) {\r\n  var r = 0;\r\n  if (Math.abs(a) > Math.abs(b)) {\r\n    r = b / a;\r\n    return Math.abs(a) * Math.sqrt(1 + r * r);\r\n  }\r\n  if (b !== 0) {\r\n    r = a / b;\r\n    return Math.abs(b) * Math.sqrt(1 + r * r);\r\n  }\r\n  return 0;\r\n}\r\n\r\nexport function getFilled2DArray(rows, columns, value) {\r\n  var array = new Array(rows);\r\n  for (var i = 0; i < rows; i++) {\r\n    array[i] = new Array(columns);\r\n    for (var j = 0; j < columns; j++) {\r\n      array[i][j] = value;\r\n    }\r\n  }\r\n  return array;\r\n}\r\n","import LuDecomposition from './dc/lu';\r\nimport QrDecomposition from './dc/qr';\r\nimport SingularValueDecomposition from './dc/svd';\r\n\r\nimport { Matrix, WrapperMatrix2D } from './index';\r\n\r\n/**\r\n * Computes the inverse of a Matrix\r\n * @param {Matrix} matrix\r\n * @param {boolean} [useSVD=false]\r\n * @return {Matrix}\r\n */\r\nexport function inverse(matrix, useSVD = false) {\r\n  matrix = WrapperMatrix2D.checkMatrix(matrix);\r\n  if (useSVD) {\r\n    return new SingularValueDecomposition(matrix).inverse();\r\n  } else {\r\n    return solve(matrix, Matrix.eye(matrix.rows));\r\n  }\r\n}\r\n\r\n/**\r\n *\r\n * @param {Matrix} leftHandSide\r\n * @param {Matrix} rightHandSide\r\n * @param {boolean} [useSVD = false]\r\n * @return {Matrix}\r\n */\r\nexport function solve(leftHandSide, rightHandSide, useSVD = false) {\r\n  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);\r\n  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);\r\n  if (useSVD) {\r\n    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);\r\n  } else {\r\n    return leftHandSide.isSquare()\r\n      ? new LuDecomposition(leftHandSide).solve(rightHandSide)\r\n      : new QrDecomposition(leftHandSide).solve(rightHandSide);\r\n  }\r\n}\r\n","export { default, default as Matrix } from './matrix';\r\nexport { default as abstractMatrix } from './abstractMatrix';\r\n\r\nexport { wrap } from './wrap/wrap';\r\nexport { default as WrapperMatrix2D } from './wrap/WrapperMatrix2D';\r\nexport { default as WrapperMatrix1D } from './wrap/WrapperMatrix1D';\r\n\r\nexport { solve, inverse } from './decompositions';\r\nexport { linearDependencies } from './linearDependencies';\r\nexport {\r\n  default as SingularValueDecomposition,\r\n  default as SVD\r\n} from './dc/svd.js';\r\nexport {\r\n  default as EigenvalueDecomposition,\r\n  default as EVD\r\n} from './dc/evd.js';\r\nexport {\r\n  default as CholeskyDecomposition,\r\n  default as CHO\r\n} from './dc/cholesky.js';\r\nexport { default as LuDecomposition, default as LU } from './dc/lu.js';\r\nexport { default as QrDecomposition, default as QR } from './dc/qr.js';\r\n","import max from 'ml-array-max';\r\n\r\nimport Matrix from './matrix';\r\nimport SingularValueDecomposition from './dc/svd';\r\n\r\n// function used by rowsDependencies\r\nfunction xrange(n, exception) {\r\n  var range = [];\r\n  for (var i = 0; i < n; i++) {\r\n    if (i !== exception) {\r\n      range.push(i);\r\n    }\r\n  }\r\n  return range;\r\n}\r\n\r\n// function used by rowsDependencies\r\nfunction dependenciesOneRow(\r\n  error,\r\n  matrix,\r\n  index,\r\n  thresholdValue = 10e-10,\r\n  thresholdError = 10e-10\r\n) {\r\n  if (error > thresholdError) {\r\n    return new Array(matrix.rows + 1).fill(0);\r\n  } else {\r\n    var returnArray = matrix.addRow(index, [0]);\r\n    for (var i = 0; i < returnArray.rows; i++) {\r\n      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {\r\n        returnArray.set(i, 0, 0);\r\n      }\r\n    }\r\n    return returnArray.to1DArray();\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a matrix which represents the dependencies between rows.\r\n * If a row is a linear combination of others rows, the result will be a row with the coefficients of this combination.\r\n * For example : for A = [[2, 0, 0, 1], [0, 1, 6, 0], [0, 3, 0, 1], [0, 0, 1, 0], [0, 1, 2, 0]], the result will be [[0, 0, 0, 0, 0], [0, 0, 0, 4, 1], [0, 0, 0, 0, 0], [0, 0.25, 0, 0, -0.25], [0, 1, 0, -4, 0]]\r\n * @param {Matrix} matrix\r\n * @param {Object} [options] includes thresholdValue and thresholdError.\r\n * @param {number} [options.thresholdValue = 10e-10] If an absolute value is inferior to this threshold, it will equals zero.\r\n * @param {number} [options.thresholdError = 10e-10] If the error is inferior to that threshold, the linear combination found is accepted and the row is dependent from other rows.\r\n * @return {Matrix} the matrix which represents the dependencies between rows.\r\n */\r\n\r\nexport function linearDependencies(matrix, options = {}) {\r\n  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;\r\n\r\n  var n = matrix.rows;\r\n  var results = new Matrix(n, n);\r\n\r\n  for (var i = 0; i < n; i++) {\r\n    var b = Matrix.columnVector(matrix.getRow(i));\r\n    var Abis = matrix.subMatrixRow(xrange(n, i)).transposeView();\r\n    var svd = new SingularValueDecomposition(Abis);\r\n    var x = svd.solve(b);\r\n    var error = max(\r\n      Matrix.sub(b, Abis.mmul(x))\r\n        .abs()\r\n        .to1DArray()\r\n    );\r\n    results.setRow(\r\n      i,\r\n      dependenciesOneRow(error, x, i, thresholdValue, thresholdError)\r\n    );\r\n  }\r\n  return results;\r\n}\r\n","import AbstractMatrix from './abstractMatrix';\r\nimport {\r\n  checkColumnIndex,\r\n  checkColumnVector,\r\n  checkRowIndex,\r\n  checkRowVector\r\n} from './util';\r\n\r\nexport default class Matrix extends AbstractMatrix(Array) {\r\n  constructor(nRows, nColumns) {\r\n    var i;\r\n    if (arguments.length === 1 && typeof nRows === 'number') {\r\n      return new Array(nRows);\r\n    }\r\n    if (Matrix.isMatrix(nRows)) {\r\n      return nRows.clone();\r\n    } else if (Number.isInteger(nRows) && nRows > 0) {\r\n      // Create an empty matrix\r\n      super(nRows);\r\n      if (Number.isInteger(nColumns) && nColumns > 0) {\r\n        for (i = 0; i < nRows; i++) {\r\n          this[i] = new Array(nColumns);\r\n        }\r\n      } else {\r\n        throw new TypeError('nColumns must be a positive integer');\r\n      }\r\n    } else if (Array.isArray(nRows)) {\r\n      // Copy the values from the 2D array\r\n      const matrix = nRows;\r\n      nRows = matrix.length;\r\n      nColumns = matrix[0].length;\r\n      if (typeof nColumns !== 'number' || nColumns === 0) {\r\n        throw new TypeError(\r\n          'Data must be a 2D array with at least one element'\r\n        );\r\n      }\r\n      super(nRows);\r\n      for (i = 0; i < nRows; i++) {\r\n        if (matrix[i].length !== nColumns) {\r\n          throw new RangeError('Inconsistent array dimensions');\r\n        }\r\n        this[i] = [].concat(matrix[i]);\r\n      }\r\n    } else {\r\n      throw new TypeError(\r\n        'First argument must be a positive number or an array'\r\n      );\r\n    }\r\n    this.rows = nRows;\r\n    this.columns = nColumns;\r\n    return this;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this[rowIndex][columnIndex] = value;\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this[rowIndex][columnIndex];\r\n  }\r\n\r\n  /**\r\n   * Removes a row from the given index\r\n   * @param {number} index - Row index\r\n   * @return {Matrix} this\r\n   */\r\n  removeRow(index) {\r\n    checkRowIndex(this, index);\r\n    if (this.rows === 1) {\r\n      throw new RangeError('A matrix cannot have less than one row');\r\n    }\r\n    this.splice(index, 1);\r\n    this.rows -= 1;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a row at the given index\r\n   * @param {number} [index = this.rows] - Row index\r\n   * @param {Array|Matrix} array - Array or vector\r\n   * @return {Matrix} this\r\n   */\r\n  addRow(index, array) {\r\n    if (array === undefined) {\r\n      array = index;\r\n      index = this.rows;\r\n    }\r\n    checkRowIndex(this, index, true);\r\n    array = checkRowVector(this, array, true);\r\n    this.splice(index, 0, array);\r\n    this.rows += 1;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Removes a column from the given index\r\n   * @param {number} index - Column index\r\n   * @return {Matrix} this\r\n   */\r\n  removeColumn(index) {\r\n    checkColumnIndex(this, index);\r\n    if (this.columns === 1) {\r\n      throw new RangeError('A matrix cannot have less than one column');\r\n    }\r\n    for (var i = 0; i < this.rows; i++) {\r\n      this[i].splice(index, 1);\r\n    }\r\n    this.columns -= 1;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Adds a column at the given index\r\n   * @param {number} [index = this.columns] - Column index\r\n   * @param {Array|Matrix} array - Array or vector\r\n   * @return {Matrix} this\r\n   */\r\n  addColumn(index, array) {\r\n    if (typeof array === 'undefined') {\r\n      array = index;\r\n      index = this.columns;\r\n    }\r\n    checkColumnIndex(this, index, true);\r\n    array = checkColumnVector(this, array);\r\n    for (var i = 0; i < this.rows; i++) {\r\n      this[i].splice(index, 0, array[i]);\r\n    }\r\n    this.columns += 1;\r\n    return this;\r\n  }\r\n}\r\n","import Matrix from './matrix';\r\n\r\n/**\r\n * @private\r\n * Check that a row index is not out of bounds\r\n * @param {Matrix} matrix\r\n * @param {number} index\r\n * @param {boolean} [outer]\r\n */\r\nexport function checkRowIndex(matrix, index, outer) {\r\n  var max = outer ? matrix.rows : matrix.rows - 1;\r\n  if (index < 0 || index > max) {\r\n    throw new RangeError('Row index out of range');\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * Check that a column index is not out of bounds\r\n * @param {Matrix} matrix\r\n * @param {number} index\r\n * @param {boolean} [outer]\r\n */\r\nexport function checkColumnIndex(matrix, index, outer) {\r\n  var max = outer ? matrix.columns : matrix.columns - 1;\r\n  if (index < 0 || index > max) {\r\n    throw new RangeError('Column index out of range');\r\n  }\r\n}\r\n\r\n/**\r\n * @private\r\n * Check that the provided vector is an array with the right length\r\n * @param {Matrix} matrix\r\n * @param {Array|Matrix} vector\r\n * @return {Array}\r\n * @throws {RangeError}\r\n */\r\nexport function checkRowVector(matrix, vector) {\r\n  if (vector.to1DArray) {\r\n    vector = vector.to1DArray();\r\n  }\r\n  if (vector.length !== matrix.columns) {\r\n    throw new RangeError(\r\n      'vector size must be the same as the number of columns'\r\n    );\r\n  }\r\n  return vector;\r\n}\r\n\r\n/**\r\n * @private\r\n * Check that the provided vector is an array with the right length\r\n * @param {Matrix} matrix\r\n * @param {Array|Matrix} vector\r\n * @return {Array}\r\n * @throws {RangeError}\r\n */\r\nexport function checkColumnVector(matrix, vector) {\r\n  if (vector.to1DArray) {\r\n    vector = vector.to1DArray();\r\n  }\r\n  if (vector.length !== matrix.rows) {\r\n    throw new RangeError('vector size must be the same as the number of rows');\r\n  }\r\n  return vector;\r\n}\r\n\r\nexport function checkIndices(matrix, rowIndices, columnIndices) {\r\n  return {\r\n    row: checkRowIndices(matrix, rowIndices),\r\n    column: checkColumnIndices(matrix, columnIndices)\r\n  };\r\n}\r\n\r\nexport function checkRowIndices(matrix, rowIndices) {\r\n  if (typeof rowIndices !== 'object') {\r\n    throw new TypeError('unexpected type for row indices');\r\n  }\r\n\r\n  var rowOut = rowIndices.some((r) => {\r\n    return r < 0 || r >= matrix.rows;\r\n  });\r\n\r\n  if (rowOut) {\r\n    throw new RangeError('row indices are out of range');\r\n  }\r\n\r\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\r\n\r\n  return rowIndices;\r\n}\r\n\r\nexport function checkColumnIndices(matrix, columnIndices) {\r\n  if (typeof columnIndices !== 'object') {\r\n    throw new TypeError('unexpected type for column indices');\r\n  }\r\n\r\n  var columnOut = columnIndices.some((c) => {\r\n    return c < 0 || c >= matrix.columns;\r\n  });\r\n\r\n  if (columnOut) {\r\n    throw new RangeError('column indices are out of range');\r\n  }\r\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\r\n\r\n  return columnIndices;\r\n}\r\n\r\nexport function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\r\n  if (arguments.length !== 5) {\r\n    throw new RangeError('expected 4 arguments');\r\n  }\r\n  checkNumber('startRow', startRow);\r\n  checkNumber('endRow', endRow);\r\n  checkNumber('startColumn', startColumn);\r\n  checkNumber('endColumn', endColumn);\r\n  if (\r\n    startRow > endRow ||\r\n    startColumn > endColumn ||\r\n    startRow < 0 ||\r\n    startRow >= matrix.rows ||\r\n    endRow < 0 ||\r\n    endRow >= matrix.rows ||\r\n    startColumn < 0 ||\r\n    startColumn >= matrix.columns ||\r\n    endColumn < 0 ||\r\n    endColumn >= matrix.columns\r\n  ) {\r\n    throw new RangeError('Submatrix indices are out of range');\r\n  }\r\n}\r\n\r\nexport function getRange(from, to) {\r\n  var arr = new Array(to - from + 1);\r\n  for (var i = 0; i < arr.length; i++) {\r\n    arr[i] = from + i;\r\n  }\r\n  return arr;\r\n}\r\n\r\nexport function sumByRow(matrix) {\r\n  var sum = Matrix.zeros(matrix.rows, 1);\r\n  for (var i = 0; i < matrix.rows; ++i) {\r\n    for (var j = 0; j < matrix.columns; ++j) {\r\n      sum.set(i, 0, sum.get(i, 0) + matrix.get(i, j));\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\nexport function sumByColumn(matrix) {\r\n  var sum = Matrix.zeros(1, matrix.columns);\r\n  for (var i = 0; i < matrix.rows; ++i) {\r\n    for (var j = 0; j < matrix.columns; ++j) {\r\n      sum.set(0, j, sum.get(0, j) + matrix.get(i, j));\r\n    }\r\n  }\r\n  return sum;\r\n}\r\n\r\nexport function sumAll(matrix) {\r\n  var v = 0;\r\n  for (var i = 0; i < matrix.rows; i++) {\r\n    for (var j = 0; j < matrix.columns; j++) {\r\n      v += matrix.get(i, j);\r\n    }\r\n  }\r\n  return v;\r\n}\r\n\r\nfunction checkNumber(name, value) {\r\n  if (typeof value !== 'number') {\r\n    throw new TypeError(`${name} must be a number`);\r\n  }\r\n}\r\n","import AbstractMatrix from '../abstractMatrix';\r\nimport Matrix from '../matrix';\r\n\r\nexport default class BaseView extends AbstractMatrix() {\r\n  constructor(matrix, rows, columns) {\r\n    super();\r\n    this.matrix = matrix;\r\n    this.rows = rows;\r\n    this.columns = columns;\r\n  }\r\n\r\n  static get [Symbol.species]() {\r\n    return Matrix;\r\n  }\r\n}\r\n","import BaseView from './base';\r\n\r\nexport default class MatrixColumnView extends BaseView {\r\n  constructor(matrix, column) {\r\n    super(matrix, matrix.rows, 1);\r\n    this.column = column;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(rowIndex, this.column, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex) {\r\n    return this.matrix.get(rowIndex, this.column);\r\n  }\r\n}\r\n","import { checkColumnIndices } from '../util';\r\n\r\nimport BaseView from './base';\r\n\r\nexport default class MatrixColumnSelectionView extends BaseView {\r\n  constructor(matrix, columnIndices) {\r\n    columnIndices = checkColumnIndices(matrix, columnIndices);\r\n    super(matrix, matrix.rows, columnIndices.length);\r\n    this.columnIndices = columnIndices;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);\r\n  }\r\n}\r\n","import BaseView from './base';\r\n\r\nexport default class MatrixFlipColumnView extends BaseView {\r\n  constructor(matrix) {\r\n    super(matrix, matrix.rows, matrix.columns);\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);\r\n  }\r\n}\r\n","import BaseView from './base';\r\n\r\nexport default class MatrixFlipRowView extends BaseView {\r\n  constructor(matrix) {\r\n    super(matrix, matrix.rows, matrix.columns);\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);\r\n  }\r\n}\r\n","import BaseView from './base';\r\n\r\nexport default class MatrixRowView extends BaseView {\r\n  constructor(matrix, row) {\r\n    super(matrix, 1, matrix.columns);\r\n    this.row = row;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(this.row, columnIndex, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(this.row, columnIndex);\r\n  }\r\n}\r\n","import { checkRowIndices } from '../util';\r\n\r\nimport BaseView from './base';\r\n\r\nexport default class MatrixRowSelectionView extends BaseView {\r\n  constructor(matrix, rowIndices) {\r\n    rowIndices = checkRowIndices(matrix, rowIndices);\r\n    super(matrix, rowIndices.length, matrix.columns);\r\n    this.rowIndices = rowIndices;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);\r\n  }\r\n}\r\n","import { checkIndices } from '../util';\r\n\r\nimport BaseView from './base';\r\n\r\nexport default class MatrixSelectionView extends BaseView {\r\n  constructor(matrix, rowIndices, columnIndices) {\r\n    var indices = checkIndices(matrix, rowIndices, columnIndices);\r\n    super(matrix, indices.row.length, indices.column.length);\r\n    this.rowIndices = indices.row;\r\n    this.columnIndices = indices.column;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(\r\n      this.rowIndices[rowIndex],\r\n      this.columnIndices[columnIndex],\r\n      value\r\n    );\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(\r\n      this.rowIndices[rowIndex],\r\n      this.columnIndices[columnIndex]\r\n    );\r\n  }\r\n}\r\n","import { checkRange } from '../util';\r\n\r\nimport BaseView from './base';\r\n\r\nexport default class MatrixSubView extends BaseView {\r\n  constructor(matrix, startRow, endRow, startColumn, endColumn) {\r\n    checkRange(matrix, startRow, endRow, startColumn, endColumn);\r\n    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);\r\n    this.startRow = startRow;\r\n    this.startColumn = startColumn;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(\r\n      this.startRow + rowIndex,\r\n      this.startColumn + columnIndex,\r\n      value\r\n    );\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(\r\n      this.startRow + rowIndex,\r\n      this.startColumn + columnIndex\r\n    );\r\n  }\r\n}\r\n","import BaseView from './base';\r\n\r\nexport default class MatrixTransposeView extends BaseView {\r\n  constructor(matrix) {\r\n    super(matrix, matrix.columns, matrix.rows);\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.matrix.set(columnIndex, rowIndex, value);\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.matrix.get(columnIndex, rowIndex);\r\n  }\r\n}\r\n","import AbstractMatrix from '../abstractMatrix';\r\nimport Matrix from '../matrix';\r\n\r\nexport default class WrapperMatrix1D extends AbstractMatrix() {\r\n  /**\r\n   * @class WrapperMatrix1D\r\n   * @param {Array<number>} data\r\n   * @param {object} [options]\r\n   * @param {object} [options.rows = 1]\r\n   */\r\n  constructor(data, options = {}) {\r\n    const { rows = 1 } = options;\r\n\r\n    if (data.length % rows !== 0) {\r\n      throw new Error('the data length is not divisible by the number of rows');\r\n    }\r\n    super();\r\n    this.rows = rows;\r\n    this.columns = data.length / rows;\r\n    this.data = data;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    var index = this._calculateIndex(rowIndex, columnIndex);\r\n    this.data[index] = value;\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    var index = this._calculateIndex(rowIndex, columnIndex);\r\n    return this.data[index];\r\n  }\r\n\r\n  _calculateIndex(row, column) {\r\n    return row * this.columns + column;\r\n  }\r\n\r\n  static get [Symbol.species]() {\r\n    return Matrix;\r\n  }\r\n}\r\n","import AbstractMatrix from '../abstractMatrix';\r\nimport Matrix from '../matrix';\r\n\r\nexport default class WrapperMatrix2D extends AbstractMatrix() {\r\n  /**\r\n   * @class WrapperMatrix2D\r\n   * @param {Array<Array<number>>} data\r\n   */\r\n  constructor(data) {\r\n    super();\r\n    this.data = data;\r\n    this.rows = data.length;\r\n    this.columns = data[0].length;\r\n  }\r\n\r\n  set(rowIndex, columnIndex, value) {\r\n    this.data[rowIndex][columnIndex] = value;\r\n    return this;\r\n  }\r\n\r\n  get(rowIndex, columnIndex) {\r\n    return this.data[rowIndex][columnIndex];\r\n  }\r\n\r\n  static get [Symbol.species]() {\r\n    return Matrix;\r\n  }\r\n}\r\n","import WrapperMatrix1D from './WrapperMatrix1D';\r\nimport WrapperMatrix2D from './WrapperMatrix2D';\r\n\r\n/**\r\n * @param {Array<Array<number>>|Array<number>} array\r\n * @param {object} [options]\r\n * @param {object} [options.rows = 1]\r\n * @return {WrapperMatrix1D|WrapperMatrix2D}\r\n */\r\nexport function wrap(array, options) {\r\n  if (Array.isArray(array)) {\r\n    if (array[0] && Array.isArray(array[0])) {\r\n      return new WrapperMatrix2D(array);\r\n    } else {\r\n      return new WrapperMatrix1D(array, options);\r\n    }\r\n  } else {\r\n    throw new Error('the argument is not an array');\r\n  }\r\n}\r\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.smallestFlagged = exports.deheapSort = exports.buildCandidates = exports.uncheckedHeapPush = exports.heapPush = exports.rejectionSample = exports.makeHeap = void 0;\r\nconst utils = require(\"./utils\");\r\n/**\r\n *  Constructor for the heap objects. The heaps are used\r\n * for approximate nearest neighbor search, maintaining a list of potential\r\n * neighbors sorted by their distance. We also flag if potential neighbors\r\n * are newly added to the list or not. Internally this is stored as\r\n * a single array; the first axis determines whether we are looking at the\r\n * array of candidate indices, the array of distances, or the flag array for\r\n * whether elements are new or not. Each of these arrays are of shape\r\n * (``nPoints``, ``size``)\r\n */\r\nfunction makeHeap(nPoints, size) {\r\n    const makeArrays = (fillValue) => {\r\n        return utils.empty(nPoints).map(() => {\r\n            return utils.filled(size, fillValue);\r\n        });\r\n    };\r\n    const heap = [];\r\n    heap.push(makeArrays(-1));\r\n    heap.push(makeArrays(Infinity));\r\n    heap.push(makeArrays(0));\r\n    return heap;\r\n}\r\nexports.makeHeap = makeHeap;\r\n/**\r\n * Generate n_samples many integers from 0 to pool_size such that no\r\n * integer is selected twice. The duplication constraint is achieved via\r\n * rejection sampling.\r\n */\r\nfunction rejectionSample(nSamples, poolSize, random) {\r\n    const result = utils.zeros(nSamples);\r\n    for (let i = 0; i < nSamples; i++) {\r\n        let rejectSample = true;\r\n        let j = 0;\r\n        while (rejectSample) {\r\n            j = utils.tauRandInt(poolSize, random);\r\n            let broken = false;\r\n            for (let k = 0; k < i; k++) {\r\n                if (j === result[k]) {\r\n                    broken = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!broken)\r\n                rejectSample = false;\r\n        }\r\n        result[i] = j;\r\n    }\r\n    return result;\r\n}\r\nexports.rejectionSample = rejectionSample;\r\n/**\r\n * Push a new element onto the heap. The heap stores potential neighbors\r\n * for each data point. The ``row`` parameter determines which data point we\r\n * are addressing, the ``weight`` determines the distance (for heap sorting),\r\n * the ``index`` is the element to add, and the flag determines whether this\r\n * is to be considered a new addition.\r\n */\r\nfunction heapPush(heap, row, weight, index, flag) {\r\n    row = Math.floor(row);\r\n    const indices = heap[0][row];\r\n    const weights = heap[1][row];\r\n    const isNew = heap[2][row];\r\n    if (weight >= weights[0]) {\r\n        return 0;\r\n    }\r\n    // Break if we already have this element.\r\n    for (let i = 0; i < indices.length; i++) {\r\n        if (index === indices[i]) {\r\n            return 0;\r\n        }\r\n    }\r\n    return uncheckedHeapPush(heap, row, weight, index, flag);\r\n}\r\nexports.heapPush = heapPush;\r\n/**\r\n * Push a new element onto the heap. The heap stores potential neighbors\r\n * for each data point. The ``row`` parameter determines which data point we\r\n * are addressing, the ``weight`` determines the distance (for heap sorting),\r\n * the ``index`` is the element to add, and the flag determines whether this\r\n * is to be considered a new addition.\r\n */\r\nfunction uncheckedHeapPush(heap, row, weight, index, flag) {\r\n    const indices = heap[0][row];\r\n    const weights = heap[1][row];\r\n    const isNew = heap[2][row];\r\n    if (weight >= weights[0]) {\r\n        return 0;\r\n    }\r\n    // Insert val at position zero\r\n    weights[0] = weight;\r\n    indices[0] = index;\r\n    isNew[0] = flag;\r\n    // Descend the heap, swapping values until the max heap criterion is met\r\n    let i = 0;\r\n    let iSwap = 0;\r\n    while (true) {\r\n        const ic1 = 2 * i + 1;\r\n        const ic2 = ic1 + 1;\r\n        const heapShape2 = heap[0][0].length;\r\n        if (ic1 >= heapShape2) {\r\n            break;\r\n        }\r\n        else if (ic2 >= heapShape2) {\r\n            if (weights[ic1] > weight) {\r\n                iSwap = ic1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        else if (weights[ic1] >= weights[ic2]) {\r\n            if (weight < weights[ic1]) {\r\n                iSwap = ic1;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        else {\r\n            if (weight < weights[ic2]) {\r\n                iSwap = ic2;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        weights[i] = weights[iSwap];\r\n        indices[i] = indices[iSwap];\r\n        isNew[i] = isNew[iSwap];\r\n        i = iSwap;\r\n    }\r\n    weights[i] = weight;\r\n    indices[i] = index;\r\n    isNew[i] = flag;\r\n    return 1;\r\n}\r\nexports.uncheckedHeapPush = uncheckedHeapPush;\r\n/**\r\n * Build a heap of candidate neighbors for nearest neighbor descent. For\r\n * each vertex the candidate neighbors are any current neighbors, and any\r\n * vertices that have the vertex as one of their nearest neighbors.\r\n */\r\nfunction buildCandidates(currentGraph, nVertices, nNeighbors, maxCandidates, random) {\r\n    const candidateNeighbors = makeHeap(nVertices, maxCandidates);\r\n    for (let i = 0; i < nVertices; i++) {\r\n        for (let j = 0; j < nNeighbors; j++) {\r\n            if (currentGraph[0][i][j] < 0) {\r\n                continue;\r\n            }\r\n            const idx = currentGraph[0][i][j];\r\n            const isn = currentGraph[2][i][j];\r\n            const d = utils.tauRand(random);\r\n            heapPush(candidateNeighbors, i, d, idx, isn);\r\n            heapPush(candidateNeighbors, idx, d, i, isn);\r\n            currentGraph[2][i][j] = 0;\r\n        }\r\n    }\r\n    return candidateNeighbors;\r\n}\r\nexports.buildCandidates = buildCandidates;\r\n/**\r\n * Given an array of heaps (of indices and weights), unpack the heap\r\n * out to give and array of sorted lists of indices and weights by increasing\r\n * weight. This is effectively just the second half of heap sort (the first\r\n * half not being required since we already have the data in a heap).\r\n */\r\nfunction deheapSort(heap) {\r\n    const indices = heap[0];\r\n    const weights = heap[1];\r\n    for (let i = 0; i < indices.length; i++) {\r\n        const indHeap = indices[i];\r\n        const distHeap = weights[i];\r\n        for (let j = 0; j < indHeap.length - 1; j++) {\r\n            const indHeapIndex = indHeap.length - j - 1;\r\n            const distHeapIndex = distHeap.length - j - 1;\r\n            const temp1 = indHeap[0];\r\n            indHeap[0] = indHeap[indHeapIndex];\r\n            indHeap[indHeapIndex] = temp1;\r\n            const temp2 = distHeap[0];\r\n            distHeap[0] = distHeap[distHeapIndex];\r\n            distHeap[distHeapIndex] = temp2;\r\n            siftDown(distHeap, indHeap, distHeapIndex, 0);\r\n        }\r\n    }\r\n    return { indices, weights };\r\n}\r\nexports.deheapSort = deheapSort;\r\n/**\r\n * Restore the heap property for a heap with an out of place element\r\n * at position ``elt``. This works with a heap pair where heap1 carries\r\n * the weights and heap2 holds the corresponding elements.\r\n */\r\nfunction siftDown(heap1, heap2, ceiling, elt) {\r\n    while (elt * 2 + 1 < ceiling) {\r\n        const leftChild = elt * 2 + 1;\r\n        const rightChild = leftChild + 1;\r\n        let swap = elt;\r\n        if (heap1[swap] < heap1[leftChild]) {\r\n            swap = leftChild;\r\n        }\r\n        if (rightChild < ceiling && heap1[swap] < heap1[rightChild]) {\r\n            swap = rightChild;\r\n        }\r\n        if (swap === elt) {\r\n            break;\r\n        }\r\n        else {\r\n            const temp1 = heap1[elt];\r\n            heap1[elt] = heap1[swap];\r\n            heap1[swap] = temp1;\r\n            const temp2 = heap2[elt];\r\n            heap2[elt] = heap2[swap];\r\n            heap2[swap] = temp2;\r\n            elt = swap;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Search the heap for the smallest element that is still flagged.\r\n */\r\nfunction smallestFlagged(heap, row) {\r\n    const ind = heap[0][row];\r\n    const dist = heap[1][row];\r\n    const flag = heap[2][row];\r\n    let minDist = Infinity;\r\n    let resultIndex = -1;\r\n    for (let i = 0; i > ind.length; i++) {\r\n        if (flag[i] === 1 && dist[i] < minDist) {\r\n            minDist = dist[i];\r\n            resultIndex = i;\r\n        }\r\n    }\r\n    if (resultIndex >= 0) {\r\n        flag[resultIndex] = 0;\r\n        return Math.floor(ind[resultIndex]);\r\n    }\r\n    else {\r\n        return -1;\r\n    }\r\n}\r\nexports.smallestFlagged = smallestFlagged;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar umap_1 = require(\"./umap\");\r\nObject.defineProperty(exports, \"UMAP\", { enumerable: true, get: function () { return umap_1.UMAP; } });\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.getCSR = exports.normalize = exports.eliminateZeros = exports.multiplyScalar = exports.maximum = exports.subtract = exports.add = exports.pairwiseMultiply = exports.identity = exports.transpose = exports.SparseMatrix = void 0;\r\nconst utils = require(\"./utils\");\r\n/**\r\n * Internal 2-dimensional sparse matrix class\r\n */\r\nclass SparseMatrix {\r\n    constructor(rows, cols, values, dims) {\r\n        this.entries = new Map();\r\n        this.nRows = 0;\r\n        this.nCols = 0;\r\n        if (rows.length !== cols.length || rows.length !== values.length) {\r\n            throw new Error('rows, cols and values arrays must all have the same length');\r\n        }\r\n        // TODO: Assert that dims are legit.\r\n        this.nRows = dims[0];\r\n        this.nCols = dims[1];\r\n        for (let i = 0; i < values.length; i++) {\r\n            const row = rows[i];\r\n            const col = cols[i];\r\n            this.checkDims(row, col);\r\n            const key = this.makeKey(row, col);\r\n            this.entries.set(key, { value: values[i], row, col });\r\n        }\r\n    }\r\n    makeKey(row, col) {\r\n        return `${row}:${col}`;\r\n    }\r\n    checkDims(row, col) {\r\n        const withinBounds = row < this.nRows && col < this.nCols;\r\n        if (!withinBounds) {\r\n            throw new Error('row and/or col specified outside of matrix dimensions');\r\n        }\r\n    }\r\n    set(row, col, value) {\r\n        this.checkDims(row, col);\r\n        const key = this.makeKey(row, col);\r\n        if (!this.entries.has(key)) {\r\n            this.entries.set(key, { value, row, col });\r\n        }\r\n        else {\r\n            this.entries.get(key).value = value;\r\n        }\r\n    }\r\n    get(row, col, defaultValue = 0) {\r\n        this.checkDims(row, col);\r\n        const key = this.makeKey(row, col);\r\n        if (this.entries.has(key)) {\r\n            return this.entries.get(key).value;\r\n        }\r\n        else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n    getAll(ordered = true) {\r\n        const rowColValues = [];\r\n        this.entries.forEach(value => {\r\n            rowColValues.push(value);\r\n        });\r\n        if (ordered) {\r\n            // Ordering the result isn't required for processing but it does make it easier to write tests\r\n            rowColValues.sort((a, b) => {\r\n                if (a.row === b.row) {\r\n                    return a.col - b.col;\r\n                }\r\n                else {\r\n                    return a.row - b.row;\r\n                }\r\n            });\r\n        }\r\n        return rowColValues;\r\n    }\r\n    getDims() {\r\n        return [this.nRows, this.nCols];\r\n    }\r\n    getRows() {\r\n        return Array.from(this.entries, ([key, value]) => value.row);\r\n    }\r\n    getCols() {\r\n        return Array.from(this.entries, ([key, value]) => value.col);\r\n    }\r\n    getValues() {\r\n        return Array.from(this.entries, ([key, value]) => value.value);\r\n    }\r\n    forEach(fn) {\r\n        this.entries.forEach(value => fn(value.value, value.row, value.col));\r\n    }\r\n    map(fn) {\r\n        let vals = [];\r\n        this.entries.forEach(value => {\r\n            vals.push(fn(value.value, value.row, value.col));\r\n        });\r\n        const dims = [this.nRows, this.nCols];\r\n        return new SparseMatrix(this.getRows(), this.getCols(), vals, dims);\r\n    }\r\n    toArray() {\r\n        const rows = utils.empty(this.nRows);\r\n        const output = rows.map(() => {\r\n            return utils.zeros(this.nCols);\r\n        });\r\n        this.entries.forEach(value => {\r\n            output[value.row][value.col] = value.value;\r\n        });\r\n        return output;\r\n    }\r\n}\r\nexports.SparseMatrix = SparseMatrix;\r\n/**\r\n * Transpose a sparse matrix\r\n */\r\nfunction transpose(matrix) {\r\n    const cols = [];\r\n    const rows = [];\r\n    const vals = [];\r\n    matrix.forEach((value, row, col) => {\r\n        cols.push(row);\r\n        rows.push(col);\r\n        vals.push(value);\r\n    });\r\n    const dims = [matrix.nCols, matrix.nRows];\r\n    return new SparseMatrix(rows, cols, vals, dims);\r\n}\r\nexports.transpose = transpose;\r\n/**\r\n * Construct a sparse identity matrix\r\n */\r\nfunction identity(size) {\r\n    const [rows] = size;\r\n    const matrix = new SparseMatrix([], [], [], size);\r\n    for (let i = 0; i < rows; i++) {\r\n        matrix.set(i, i, 1);\r\n    }\r\n    return matrix;\r\n}\r\nexports.identity = identity;\r\n/**\r\n * Element-wise multiplication of two matrices\r\n */\r\nfunction pairwiseMultiply(a, b) {\r\n    return elementWise(a, b, (x, y) => x * y);\r\n}\r\nexports.pairwiseMultiply = pairwiseMultiply;\r\n/**\r\n * Element-wise addition of two matrices\r\n */\r\nfunction add(a, b) {\r\n    return elementWise(a, b, (x, y) => x + y);\r\n}\r\nexports.add = add;\r\n/**\r\n * Element-wise subtraction of two matrices\r\n */\r\nfunction subtract(a, b) {\r\n    return elementWise(a, b, (x, y) => x - y);\r\n}\r\nexports.subtract = subtract;\r\n/**\r\n * Element-wise maximum of two matrices\r\n */\r\nfunction maximum(a, b) {\r\n    return elementWise(a, b, (x, y) => (x > y ? x : y));\r\n}\r\nexports.maximum = maximum;\r\n/**\r\n * Scalar multiplication of two matrices\r\n */\r\nfunction multiplyScalar(a, scalar) {\r\n    return a.map((value) => {\r\n        return value * scalar;\r\n    });\r\n}\r\nexports.multiplyScalar = multiplyScalar;\r\n/**\r\n * Returns a new matrix with zero entries removed.\r\n */\r\nfunction eliminateZeros(m) {\r\n    const zeroIndices = new Set();\r\n    const values = m.getValues();\r\n    const rows = m.getRows();\r\n    const cols = m.getCols();\r\n    for (let i = 0; i < values.length; i++) {\r\n        if (values[i] === 0) {\r\n            zeroIndices.add(i);\r\n        }\r\n    }\r\n    const removeByZeroIndex = (_, index) => !zeroIndices.has(index);\r\n    const nextValues = values.filter(removeByZeroIndex);\r\n    const nextRows = rows.filter(removeByZeroIndex);\r\n    const nextCols = cols.filter(removeByZeroIndex);\r\n    return new SparseMatrix(nextRows, nextCols, nextValues, m.getDims());\r\n}\r\nexports.eliminateZeros = eliminateZeros;\r\n/**\r\n * Normalization of a sparse matrix.\r\n */\r\nfunction normalize(m, normType = \"l2\" /* l2 */) {\r\n    const normFn = normFns[normType];\r\n    const colsByRow = new Map();\r\n    m.forEach((_, row, col) => {\r\n        const cols = colsByRow.get(row) || [];\r\n        cols.push(col);\r\n        colsByRow.set(row, cols);\r\n    });\r\n    const nextMatrix = new SparseMatrix([], [], [], m.getDims());\r\n    for (let row of colsByRow.keys()) {\r\n        const cols = colsByRow.get(row).sort();\r\n        const vals = cols.map(col => m.get(row, col));\r\n        const norm = normFn(vals);\r\n        for (let i = 0; i < norm.length; i++) {\r\n            nextMatrix.set(row, cols[i], norm[i]);\r\n        }\r\n    }\r\n    return nextMatrix;\r\n}\r\nexports.normalize = normalize;\r\nconst normFns = {\r\n    [\"max\" /* max */]: (xs) => {\r\n        let max = -Infinity;\r\n        for (let i = 0; i < xs.length; i++) {\r\n            max = xs[i] > max ? xs[i] : max;\r\n        }\r\n        return xs.map(x => x / max);\r\n    },\r\n    [\"l1\" /* l1 */]: (xs) => {\r\n        let sum = 0;\r\n        for (let i = 0; i < xs.length; i++) {\r\n            sum += xs[i];\r\n        }\r\n        return xs.map(x => x / sum);\r\n    },\r\n    [\"l2\" /* l2 */]: (xs) => {\r\n        let sum = 0;\r\n        for (let i = 0; i < xs.length; i++) {\r\n            sum += Math.pow(xs[i], 2);\r\n        }\r\n        return xs.map(x => Math.sqrt(Math.pow(x, 2) / sum));\r\n    },\r\n};\r\n/**\r\n * Helper function for element-wise operations.\r\n */\r\nfunction elementWise(a, b, op) {\r\n    const visited = new Set();\r\n    const rows = [];\r\n    const cols = [];\r\n    const vals = [];\r\n    const operate = (row, col) => {\r\n        rows.push(row);\r\n        cols.push(col);\r\n        const nextValue = op(a.get(row, col), b.get(row, col));\r\n        vals.push(nextValue);\r\n    };\r\n    const valuesA = a.getValues();\r\n    const rowsA = a.getRows();\r\n    const colsA = a.getCols();\r\n    for (let i = 0; i < valuesA.length; i++) {\r\n        const row = rowsA[i];\r\n        const col = colsA[i];\r\n        const key = `${row}:${col}`;\r\n        visited.add(key);\r\n        operate(row, col);\r\n    }\r\n    const valuesB = b.getValues();\r\n    const rowsB = b.getRows();\r\n    const colsB = b.getCols();\r\n    for (let i = 0; i < valuesB.length; i++) {\r\n        const row = rowsB[i];\r\n        const col = colsB[i];\r\n        const key = `${row}:${col}`;\r\n        if (visited.has(key))\r\n            continue;\r\n        operate(row, col);\r\n    }\r\n    const dims = [a.nRows, a.nCols];\r\n    return new SparseMatrix(rows, cols, vals, dims);\r\n}\r\n/**\r\n * Helper function for getting data, indices, and inptr arrays from a sparse\r\n * matrix to follow csr matrix conventions. Super inefficient (and kind of\r\n * defeats the purpose of this convention) but a lot of the ported python tree\r\n * search logic depends on this data format.\r\n */\r\nfunction getCSR(x) {\r\n    const entries = [];\r\n    x.forEach((value, row, col) => {\r\n        entries.push({ value, row, col });\r\n    });\r\n    entries.sort((a, b) => {\r\n        if (a.row === b.row) {\r\n            return a.col - b.col;\r\n        }\r\n        else {\r\n            return a.row - b.row;\r\n        }\r\n    });\r\n    const indices = [];\r\n    const values = [];\r\n    const indptr = [];\r\n    let currentRow = -1;\r\n    for (let i = 0; i < entries.length; i++) {\r\n        const { row, col, value } = entries[i];\r\n        if (row !== currentRow) {\r\n            currentRow = row;\r\n            indptr.push(i);\r\n        }\r\n        indices.push(col);\r\n        values.push(value);\r\n    }\r\n    return { indices, values, indptr };\r\n}\r\nexports.getCSR = getCSR;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.initializeSearch = exports.makeInitializedNNSearch = exports.makeInitializations = exports.makeNNDescent = void 0;\r\n/**\r\n * This is a JavaScript reimplementation of UMAP (original license below), from\r\n * the python implementation found at https://github.com/lmcinnes/umap.\r\n *\r\n * @author andycoenen@google.com (Andy Coenen)\r\n */\r\n/**\r\n * @license\r\n * BSD 3-Clause License\r\n *\r\n * Copyright (c) 2017, Leland McInnes\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * * Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from\r\n *   this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nconst heap = require(\"./heap\");\r\nconst matrix = require(\"./matrix\");\r\nconst tree = require(\"./tree\");\r\nconst utils = require(\"./utils\");\r\n/**\r\n * Create a version of nearest neighbor descent.\r\n */\r\nfunction makeNNDescent(distanceFn, random) {\r\n    return function nNDescent(data, leafArray, nNeighbors, nIters = 10, maxCandidates = 50, delta = 0.001, rho = 0.5, rpTreeInit = true) {\r\n        const nVertices = data.length;\r\n        const currentGraph = heap.makeHeap(data.length, nNeighbors);\r\n        for (let i = 0; i < data.length; i++) {\r\n            const indices = heap.rejectionSample(nNeighbors, data.length, random);\r\n            for (let j = 0; j < indices.length; j++) {\r\n                const d = distanceFn(data[i], data[indices[j]]);\r\n                heap.heapPush(currentGraph, i, d, indices[j], 1);\r\n                heap.heapPush(currentGraph, indices[j], d, i, 1);\r\n            }\r\n        }\r\n        if (rpTreeInit) {\r\n            for (let n = 0; n < leafArray.length; n++) {\r\n                for (let i = 0; i < leafArray[n].length; i++) {\r\n                    if (leafArray[n][i] < 0) {\r\n                        break;\r\n                    }\r\n                    for (let j = i + 1; j < leafArray[n].length; j++) {\r\n                        if (leafArray[n][j] < 0) {\r\n                            break;\r\n                        }\r\n                        const d = distanceFn(data[leafArray[n][i]], data[leafArray[n][j]]);\r\n                        heap.heapPush(currentGraph, leafArray[n][i], d, leafArray[n][j], 1);\r\n                        heap.heapPush(currentGraph, leafArray[n][j], d, leafArray[n][i], 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (let n = 0; n < nIters; n++) {\r\n            const candidateNeighbors = heap.buildCandidates(currentGraph, nVertices, nNeighbors, maxCandidates, random);\r\n            let c = 0;\r\n            for (let i = 0; i < nVertices; i++) {\r\n                for (let j = 0; j < maxCandidates; j++) {\r\n                    let p = Math.floor(candidateNeighbors[0][i][j]);\r\n                    if (p < 0 || utils.tauRand(random) < rho) {\r\n                        continue;\r\n                    }\r\n                    for (let k = 0; k < maxCandidates; k++) {\r\n                        const q = Math.floor(candidateNeighbors[0][i][k]);\r\n                        const cj = candidateNeighbors[2][i][j];\r\n                        const ck = candidateNeighbors[2][i][k];\r\n                        if (q < 0 || (!cj && !ck)) {\r\n                            continue;\r\n                        }\r\n                        const d = distanceFn(data[p], data[q]);\r\n                        c += heap.heapPush(currentGraph, p, d, q, 1);\r\n                        c += heap.heapPush(currentGraph, q, d, p, 1);\r\n                    }\r\n                }\r\n            }\r\n            if (c <= delta * nNeighbors * data.length) {\r\n                break;\r\n            }\r\n        }\r\n        const sorted = heap.deheapSort(currentGraph);\r\n        return sorted;\r\n    };\r\n}\r\nexports.makeNNDescent = makeNNDescent;\r\nfunction makeInitializations(distanceFn) {\r\n    function initFromRandom(nNeighbors, data, queryPoints, _heap, random) {\r\n        for (let i = 0; i < queryPoints.length; i++) {\r\n            const indices = utils.rejectionSample(nNeighbors, data.length, random);\r\n            for (let j = 0; j < indices.length; j++) {\r\n                if (indices[j] < 0) {\r\n                    continue;\r\n                }\r\n                const d = distanceFn(data[indices[j]], queryPoints[i]);\r\n                heap.heapPush(_heap, i, d, indices[j], 1);\r\n            }\r\n        }\r\n    }\r\n    function initFromTree(_tree, data, queryPoints, _heap, random) {\r\n        for (let i = 0; i < queryPoints.length; i++) {\r\n            const indices = tree.searchFlatTree(queryPoints[i], _tree, random);\r\n            for (let j = 0; j < indices.length; j++) {\r\n                if (indices[j] < 0) {\r\n                    return;\r\n                }\r\n                const d = distanceFn(data[indices[j]], queryPoints[i]);\r\n                heap.heapPush(_heap, i, d, indices[j], 1);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    return { initFromRandom, initFromTree };\r\n}\r\nexports.makeInitializations = makeInitializations;\r\nfunction makeInitializedNNSearch(distanceFn) {\r\n    return function nnSearchFn(data, graph, initialization, queryPoints) {\r\n        const { indices, indptr } = matrix.getCSR(graph);\r\n        for (let i = 0; i < queryPoints.length; i++) {\r\n            const tried = new Set(initialization[0][i]);\r\n            while (true) {\r\n                // Find smallest flagged vertex\r\n                const vertex = heap.smallestFlagged(initialization, i);\r\n                if (vertex === -1) {\r\n                    break;\r\n                }\r\n                const candidates = indices.slice(indptr[vertex], indptr[vertex + 1]);\r\n                for (const candidate of candidates) {\r\n                    if (candidate === vertex ||\r\n                        candidate === -1 ||\r\n                        tried.has(candidate)) {\r\n                        continue;\r\n                    }\r\n                    const d = distanceFn(data[candidate], queryPoints[i]);\r\n                    heap.uncheckedHeapPush(initialization, i, d, candidate, 1);\r\n                    tried.add(candidate);\r\n                }\r\n            }\r\n        }\r\n        return initialization;\r\n    };\r\n}\r\nexports.makeInitializedNNSearch = makeInitializedNNSearch;\r\nfunction initializeSearch(forest, data, queryPoints, nNeighbors, initFromRandom, initFromTree, random) {\r\n    const results = heap.makeHeap(queryPoints.length, nNeighbors);\r\n    initFromRandom(nNeighbors, data, queryPoints, results, random);\r\n    if (forest) {\r\n        for (let tree of forest) {\r\n            initFromTree(tree, data, queryPoints, results, random);\r\n        }\r\n    }\r\n    return results;\r\n}\r\nexports.initializeSearch = initializeSearch;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.searchFlatTree = exports.makeLeafArray = exports.makeForest = exports.FlatTree = void 0;\r\n/**\r\n * This is a JavaScript reimplementation of UMAP (original license below), from\r\n * the python implementation found at https://github.com/lmcinnes/umap.\r\n *\r\n * @author andycoenen@google.com (Andy Coenen)\r\n */\r\n/**\r\n * @license\r\n * BSD 3-Clause License\r\n *\r\n * Copyright (c) 2017, Leland McInnes\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * * Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from\r\n *   this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nconst utils = require(\"./utils\");\r\nclass FlatTree {\r\n    constructor(hyperplanes, offsets, children, indices) {\r\n        this.hyperplanes = hyperplanes;\r\n        this.offsets = offsets;\r\n        this.children = children;\r\n        this.indices = indices;\r\n    }\r\n}\r\nexports.FlatTree = FlatTree;\r\n/**\r\n * Build a random projection forest with ``nTrees``.\r\n */\r\nfunction makeForest(data, nNeighbors, nTrees, random) {\r\n    const leafSize = Math.max(10, nNeighbors);\r\n    const trees = utils\r\n        .range(nTrees)\r\n        .map((_, i) => makeTree(data, leafSize, i, random));\r\n    const forest = trees.map(tree => flattenTree(tree, leafSize));\r\n    return forest;\r\n}\r\nexports.makeForest = makeForest;\r\n/**\r\n * Construct a random projection tree based on ``data`` with leaves\r\n * of size at most ``leafSize``\r\n */\r\nfunction makeTree(data, leafSize = 30, n, random) {\r\n    const indices = utils.range(data.length);\r\n    const tree = makeEuclideanTree(data, indices, leafSize, n, random);\r\n    return tree;\r\n}\r\nfunction makeEuclideanTree(data, indices, leafSize = 30, q, random) {\r\n    if (indices.length > leafSize) {\r\n        const splitResults = euclideanRandomProjectionSplit(data, indices, random);\r\n        const { indicesLeft, indicesRight, hyperplane, offset } = splitResults;\r\n        const leftChild = makeEuclideanTree(data, indicesLeft, leafSize, q + 1, random);\r\n        const rightChild = makeEuclideanTree(data, indicesRight, leafSize, q + 1, random);\r\n        const node = { leftChild, rightChild, isLeaf: false, hyperplane, offset };\r\n        return node;\r\n    }\r\n    else {\r\n        const node = { indices, isLeaf: true };\r\n        return node;\r\n    }\r\n}\r\n/**\r\n * Given a set of ``indices`` for data points from ``data``, create\r\n * a random hyperplane to split the data, returning two arrays indices\r\n * that fall on either side of the hyperplane. This is the basis for a\r\n * random projection tree, which simply uses this splitting recursively.\r\n * This particular split uses euclidean distance to determine the hyperplane\r\n * and which side each data sample falls on.\r\n */\r\nfunction euclideanRandomProjectionSplit(data, indices, random) {\r\n    const dim = data[0].length;\r\n    // Select two random points, set the hyperplane between them\r\n    let leftIndex = utils.tauRandInt(indices.length, random);\r\n    let rightIndex = utils.tauRandInt(indices.length, random);\r\n    rightIndex += leftIndex === rightIndex ? 1 : 0;\r\n    rightIndex = rightIndex % indices.length;\r\n    const left = indices[leftIndex];\r\n    const right = indices[rightIndex];\r\n    // Compute the normal vector to the hyperplane (the vector between the two\r\n    // points) and the offset from the origin\r\n    let hyperplaneOffset = 0;\r\n    const hyperplaneVector = utils.zeros(dim);\r\n    for (let i = 0; i < hyperplaneVector.length; i++) {\r\n        hyperplaneVector[i] = data[left][i] - data[right][i];\r\n        hyperplaneOffset -=\r\n            (hyperplaneVector[i] * (data[left][i] + data[right][i])) / 2.0;\r\n    }\r\n    // For each point compute the margin (project into normal vector)\r\n    // If we are on lower side of the hyperplane put in one pile, otherwise\r\n    // put it in the other pile (if we hit hyperplane on the nose, flip a coin)\r\n    let nLeft = 0;\r\n    let nRight = 0;\r\n    const side = utils.zeros(indices.length);\r\n    for (let i = 0; i < indices.length; i++) {\r\n        let margin = hyperplaneOffset;\r\n        for (let d = 0; d < dim; d++) {\r\n            margin += hyperplaneVector[d] * data[indices[i]][d];\r\n        }\r\n        if (margin === 0) {\r\n            side[i] = utils.tauRandInt(2, random);\r\n            if (side[i] === 0) {\r\n                nLeft += 1;\r\n            }\r\n            else {\r\n                nRight += 1;\r\n            }\r\n        }\r\n        else if (margin > 0) {\r\n            side[i] = 0;\r\n            nLeft += 1;\r\n        }\r\n        else {\r\n            side[i] = 1;\r\n            nRight += 1;\r\n        }\r\n    }\r\n    // Now that we have the counts, allocate arrays\r\n    const indicesLeft = utils.zeros(nLeft);\r\n    const indicesRight = utils.zeros(nRight);\r\n    // Populate the arrays with indices according to which side they fell on\r\n    nLeft = 0;\r\n    nRight = 0;\r\n    for (let i in utils.range(side.length)) {\r\n        if (side[i] === 0) {\r\n            indicesLeft[nLeft] = indices[i];\r\n            nLeft += 1;\r\n        }\r\n        else {\r\n            indicesRight[nRight] = indices[i];\r\n            nRight += 1;\r\n        }\r\n    }\r\n    return {\r\n        indicesLeft,\r\n        indicesRight,\r\n        hyperplane: hyperplaneVector,\r\n        offset: hyperplaneOffset,\r\n    };\r\n}\r\nfunction flattenTree(tree, leafSize) {\r\n    const nNodes = numNodes(tree);\r\n    const nLeaves = numLeaves(tree);\r\n    // TODO: Verify that sparse code is not relevant...\r\n    const hyperplanes = utils\r\n        .range(nNodes)\r\n        .map(() => utils.zeros(tree.hyperplane ? tree.hyperplane.length : 0));\r\n    const offsets = utils.zeros(nNodes);\r\n    const children = utils.range(nNodes).map(() => [-1, -1]);\r\n    const indices = utils\r\n        .range(nLeaves)\r\n        .map(() => utils.range(leafSize).map(() => -1));\r\n    recursiveFlatten(tree, hyperplanes, offsets, children, indices, 0, 0);\r\n    return new FlatTree(hyperplanes, offsets, children, indices);\r\n}\r\nfunction recursiveFlatten(tree, hyperplanes, offsets, children, indices, nodeNum, leafNum) {\r\n    if (tree.isLeaf) {\r\n        children[nodeNum][0] = -leafNum;\r\n        // TODO: Triple check this operation corresponds to\r\n        // indices[leafNum : tree.indices.shape[0]] = tree.indices\r\n        indices[leafNum].splice(0, tree.indices.length, ...tree.indices);\r\n        leafNum += 1;\r\n        return { nodeNum, leafNum };\r\n    }\r\n    else {\r\n        hyperplanes[nodeNum] = tree.hyperplane;\r\n        offsets[nodeNum] = tree.offset;\r\n        children[nodeNum][0] = nodeNum + 1;\r\n        const oldNodeNum = nodeNum;\r\n        let res = recursiveFlatten(tree.leftChild, hyperplanes, offsets, children, indices, nodeNum + 1, leafNum);\r\n        nodeNum = res.nodeNum;\r\n        leafNum = res.leafNum;\r\n        children[oldNodeNum][1] = nodeNum + 1;\r\n        res = recursiveFlatten(tree.rightChild, hyperplanes, offsets, children, indices, nodeNum + 1, leafNum);\r\n        return { nodeNum: res.nodeNum, leafNum: res.leafNum };\r\n    }\r\n}\r\nfunction numNodes(tree) {\r\n    if (tree.isLeaf) {\r\n        return 1;\r\n    }\r\n    else {\r\n        return 1 + numNodes(tree.leftChild) + numNodes(tree.rightChild);\r\n    }\r\n}\r\nfunction numLeaves(tree) {\r\n    if (tree.isLeaf) {\r\n        return 1;\r\n    }\r\n    else {\r\n        return numLeaves(tree.leftChild) + numLeaves(tree.rightChild);\r\n    }\r\n}\r\n/**\r\n * Generate an array of sets of candidate nearest neighbors by\r\n * constructing a random projection forest and taking the leaves of all the\r\n * trees. Any given tree has leaves that are a set of potential nearest\r\n * neighbors. Given enough trees the set of all such leaves gives a good\r\n * likelihood of getting a good set of nearest neighbors in composite. Since\r\n * such a random projection forest is inexpensive to compute, this can be a\r\n * useful means of seeding other nearest neighbor algorithms.\r\n */\r\nfunction makeLeafArray(rpForest) {\r\n    if (rpForest.length > 0) {\r\n        const output = [];\r\n        for (let tree of rpForest) {\r\n            output.push(...tree.indices);\r\n        }\r\n        return output;\r\n    }\r\n    else {\r\n        return [[-1]];\r\n    }\r\n}\r\nexports.makeLeafArray = makeLeafArray;\r\n/**\r\n * Selects the side of the tree to search during flat tree search.\r\n */\r\nfunction selectSide(hyperplane, offset, point, random) {\r\n    let margin = offset;\r\n    for (let d = 0; d < point.length; d++) {\r\n        margin += hyperplane[d] * point[d];\r\n    }\r\n    if (margin === 0) {\r\n        const side = utils.tauRandInt(2, random);\r\n        return side;\r\n    }\r\n    else if (margin > 0) {\r\n        return 0;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\n/**\r\n * Searches a flattened rp-tree for a point.\r\n */\r\nfunction searchFlatTree(point, tree, random) {\r\n    let node = 0;\r\n    while (tree.children[node][0] > 0) {\r\n        const side = selectSide(tree.hyperplanes[node], tree.offsets[node], point, random);\r\n        if (side === 0) {\r\n            node = tree.children[node][0];\r\n        }\r\n        else {\r\n            node = tree.children[node][1];\r\n        }\r\n    }\r\n    const index = -1 * tree.children[node][0];\r\n    return tree.indices[index];\r\n}\r\nexports.searchFlatTree = searchFlatTree;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.initTransform = exports.resetLocalConnectivity = exports.fastIntersection = exports.findABParams = exports.cosine = exports.euclidean = exports.UMAP = void 0;\r\n/**\r\n * This is a JavaScript reimplementation of UMAP (original license below), from\r\n * the python implementation found at https://github.com/lmcinnes/umap.\r\n *\r\n * @author andycoenen@google.com (Andy Coenen)\r\n */\r\n/**\r\n * @license\r\n * BSD 3-Clause License\r\n *\r\n * Copyright (c) 2017, Leland McInnes\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *\r\n * * Redistributions of source code must retain the above copyright notice, this\r\n *   list of conditions and the following disclaimer.\r\n *\r\n * * Redistributions in binary form must reproduce the above copyright notice,\r\n *   this list of conditions and the following disclaimer in the documentation\r\n *   and/or other materials provided with the distribution.\r\n *\r\n * * Neither the name of the copyright holder nor the names of its\r\n *   contributors may be used to endorse or promote products derived from\r\n *   this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nconst heap = require(\"./heap\");\r\nconst matrix = require(\"./matrix\");\r\nconst nnDescent = require(\"./nn_descent\");\r\nconst tree = require(\"./tree\");\r\nconst utils = require(\"./utils\");\r\nconst ml_levenberg_marquardt_1 = require(\"ml-levenberg-marquardt\");\r\nconst SMOOTH_K_TOLERANCE = 1e-5;\r\nconst MIN_K_DIST_SCALE = 1e-3;\r\n/**\r\n * UMAP projection system, based on the python implementation from McInnes, L,\r\n * Healy, J, UMAP: Uniform Manifold Approximation and Projection for Dimension\r\n * Reduction (https://github.com/lmcinnes/umap).\r\n *\r\n * This implementation differs in a few regards:\r\n * a) The initialization of the embedding for optimization is not computed using\r\n *    a spectral method, rather it is initialized randomly. This avoids some\r\n *    computationally intensive matrix eigen computations that aren't easily\r\n *    ported to JavaScript.\r\n * b) A lot of \"extra\" functionality has been omitted from this implementation,\r\n *    most notably a great deal of alternate distance functions.\r\n *\r\n * This implementation provides three methods of reducing dimensionality:\r\n * 1) fit: fit the data synchronously\r\n * 2) fitAsync: fit the data asynchronously, with a callback function provided\r\n *      that is invoked on each optimization step.\r\n * 3) initializeFit / step: manually initialize the algorithm then explictly\r\n *      step through each epoch of the SGD optimization\r\n */\r\nclass UMAP {\r\n    constructor(params = {}) {\r\n        this.learningRate = 1.0;\r\n        this.localConnectivity = 1.0;\r\n        this.minDist = 0.1;\r\n        this.nComponents = 2;\r\n        this.nEpochs = 0;\r\n        this.nNeighbors = 15;\r\n        this.negativeSampleRate = 5;\r\n        this.random = Math.random;\r\n        this.repulsionStrength = 1.0;\r\n        this.setOpMixRatio = 1.0;\r\n        this.spread = 1.0;\r\n        this.transformQueueSize = 4.0;\r\n        // Supervised projection params\r\n        this.targetMetric = \"categorical\" /* categorical */;\r\n        this.targetWeight = 0.5;\r\n        this.targetNNeighbors = this.nNeighbors;\r\n        this.distanceFn = euclidean;\r\n        this.isInitialized = false;\r\n        this.rpForest = [];\r\n        // Projected embedding\r\n        this.embedding = [];\r\n        this.optimizationState = new OptimizationState();\r\n        const setParam = (key) => {\r\n            if (params[key] !== undefined)\r\n                this[key] = params[key];\r\n        };\r\n        setParam('distanceFn');\r\n        setParam('learningRate');\r\n        setParam('localConnectivity');\r\n        setParam('minDist');\r\n        setParam('nComponents');\r\n        setParam('nEpochs');\r\n        setParam('nNeighbors');\r\n        setParam('negativeSampleRate');\r\n        setParam('random');\r\n        setParam('repulsionStrength');\r\n        setParam('setOpMixRatio');\r\n        setParam('spread');\r\n        setParam('transformQueueSize');\r\n    }\r\n    /**\r\n     * Fit the data to a projected embedding space synchronously.\r\n     */\r\n    fit(X, initialEmbedding) {\r\n        this.initializeFit(X, initialEmbedding);\r\n        this.optimizeLayout();\r\n        return this.embedding;\r\n    }\r\n    /**\r\n     * Fit the data to a projected embedding space asynchronously, with a callback\r\n     * function invoked on every epoch of optimization.\r\n     */\r\n    fitAsync(X, initialEmbedding, callback = () => true) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.initializeFit(X, initialEmbedding);\r\n            yield this.optimizeLayoutAsync(callback);\r\n            return this.embedding;\r\n        });\r\n    }\r\n    /**\r\n     * Initializes parameters needed for supervised projection.\r\n     */\r\n    setSupervisedProjection(Y, params = {}) {\r\n        this.Y = Y;\r\n        this.targetMetric = params.targetMetric || this.targetMetric;\r\n        this.targetWeight = params.targetWeight || this.targetWeight;\r\n        this.targetNNeighbors = params.targetNNeighbors || this.targetNNeighbors;\r\n    }\r\n    /**\r\n     * Initializes umap with precomputed KNN indices and distances.\r\n     */\r\n    setPrecomputedKNN(knnIndices, knnDistances) {\r\n        this.knnIndices = knnIndices;\r\n        this.knnDistances = knnDistances;\r\n    }\r\n    /**\r\n     * Initializes fit by computing KNN and a fuzzy simplicial set, as well as\r\n     * initializing the projected embeddings. Sets the optimization state ahead\r\n     * of optimization steps. Returns the number of epochs to be used for the\r\n     * SGD optimization.\r\n     */\r\n    initializeFit(X, initialEmbedding) {\r\n        if (X.length <= this.nNeighbors) {\r\n            throw new Error(`Not enough data points (${X.length}) to create nNeighbors: ${this.nNeighbors}.  Add more data points or adjust the configuration.`);\r\n        }\r\n        // We don't need to reinitialize if we've already initialized for this data.\r\n        if (this.X === X && this.isInitialized) {\r\n            return this.getNEpochs();\r\n        }\r\n        this.X = X;\r\n        if (!this.knnIndices && !this.knnDistances) {\r\n            const knnResults = this.nearestNeighbors(X);\r\n            this.knnIndices = knnResults.knnIndices;\r\n            this.knnDistances = knnResults.knnDistances;\r\n        }\r\n        this.graph = this.fuzzySimplicialSet(X, this.nNeighbors, this.setOpMixRatio);\r\n        // Set up the search graph for subsequent transformation.\r\n        this.makeSearchFns();\r\n        this.searchGraph = this.makeSearchGraph(X);\r\n        // Check if supervised projection, then adjust the graph.\r\n        this.processGraphForSupervisedProjection();\r\n        const { head, tail, epochsPerSample, } = this.initializeSimplicialSetEmbedding(initialEmbedding);\r\n        // Set the optimization routine state\r\n        this.optimizationState.head = head;\r\n        this.optimizationState.tail = tail;\r\n        this.optimizationState.epochsPerSample = epochsPerSample;\r\n        // Now, initialize the optimization steps\r\n        this.initializeOptimization();\r\n        this.prepareForOptimizationLoop();\r\n        this.isInitialized = true;\r\n        return this.getNEpochs();\r\n    }\r\n    makeSearchFns() {\r\n        const { initFromTree, initFromRandom } = nnDescent.makeInitializations(this.distanceFn);\r\n        this.initFromTree = initFromTree;\r\n        this.initFromRandom = initFromRandom;\r\n        this.search = nnDescent.makeInitializedNNSearch(this.distanceFn);\r\n    }\r\n    makeSearchGraph(X) {\r\n        const knnIndices = this.knnIndices;\r\n        const knnDistances = this.knnDistances;\r\n        const dims = [X.length, X.length];\r\n        const searchGraph = new matrix.SparseMatrix([], [], [], dims);\r\n        for (let i = 0; i < knnIndices.length; i++) {\r\n            const knn = knnIndices[i];\r\n            const distances = knnDistances[i];\r\n            for (let j = 0; j < knn.length; j++) {\r\n                const neighbor = knn[j];\r\n                const distance = distances[j];\r\n                if (distance > 0) {\r\n                    searchGraph.set(i, neighbor, distance);\r\n                }\r\n            }\r\n        }\r\n        const transpose = matrix.transpose(searchGraph);\r\n        return matrix.maximum(searchGraph, transpose);\r\n    }\r\n    /**\r\n     * Transforms data to the existing embedding space.\r\n     */\r\n    transform(toTransform) {\r\n        // Use the previous rawData\r\n        const rawData = this.X;\r\n        if (rawData === undefined || rawData.length === 0) {\r\n            throw new Error('No data has been fit.');\r\n        }\r\n        let nNeighbors = Math.floor(this.nNeighbors * this.transformQueueSize);\r\n        nNeighbors = Math.min(rawData.length, nNeighbors);\r\n        const init = nnDescent.initializeSearch(this.rpForest, rawData, toTransform, nNeighbors, this.initFromRandom, this.initFromTree, this.random);\r\n        const result = this.search(rawData, this.searchGraph, init, toTransform);\r\n        let { indices, weights: distances } = heap.deheapSort(result);\r\n        indices = indices.map(x => x.slice(0, this.nNeighbors));\r\n        distances = distances.map(x => x.slice(0, this.nNeighbors));\r\n        const adjustedLocalConnectivity = Math.max(0, this.localConnectivity - 1);\r\n        const { sigmas, rhos } = this.smoothKNNDistance(distances, this.nNeighbors, adjustedLocalConnectivity);\r\n        const { rows, cols, vals } = this.computeMembershipStrengths(indices, distances, sigmas, rhos);\r\n        const size = [toTransform.length, rawData.length];\r\n        let graph = new matrix.SparseMatrix(rows, cols, vals, size);\r\n        // This was a very specially constructed graph with constant degree.\r\n        // That lets us do fancy unpacking by reshaping the csr matrix indices\r\n        // and data. Doing so relies on the constant degree assumption!\r\n        const normed = matrix.normalize(graph, \"l1\" /* l1 */);\r\n        const csrMatrix = matrix.getCSR(normed);\r\n        const nPoints = toTransform.length;\r\n        const eIndices = utils.reshape2d(csrMatrix.indices, nPoints, this.nNeighbors);\r\n        const eWeights = utils.reshape2d(csrMatrix.values, nPoints, this.nNeighbors);\r\n        const embedding = initTransform(eIndices, eWeights, this.embedding);\r\n        const nEpochs = this.nEpochs\r\n            ? this.nEpochs / 3\r\n            : graph.nRows <= 10000\r\n                ? 100\r\n                : 30;\r\n        const graphMax = graph\r\n            .getValues()\r\n            .reduce((max, val) => (val > max ? val : max), 0);\r\n        graph = graph.map(value => (value < graphMax / nEpochs ? 0 : value));\r\n        graph = matrix.eliminateZeros(graph);\r\n        const epochsPerSample = this.makeEpochsPerSample(graph.getValues(), nEpochs);\r\n        const head = graph.getRows();\r\n        const tail = graph.getCols();\r\n        // Initialize optimization slightly differently than the fit method.\r\n        this.assignOptimizationStateParameters({\r\n            headEmbedding: embedding,\r\n            tailEmbedding: this.embedding,\r\n            head,\r\n            tail,\r\n            currentEpoch: 0,\r\n            nEpochs,\r\n            nVertices: graph.getDims()[1],\r\n            epochsPerSample,\r\n        });\r\n        this.prepareForOptimizationLoop();\r\n        return this.optimizeLayout();\r\n    }\r\n    /**\r\n     * Checks if we're using supervised projection, then process the graph\r\n     * accordingly.\r\n     */\r\n    processGraphForSupervisedProjection() {\r\n        const { Y, X } = this;\r\n        if (Y) {\r\n            if (Y.length !== X.length) {\r\n                throw new Error('Length of X and y must be equal');\r\n            }\r\n            if (this.targetMetric === \"categorical\" /* categorical */) {\r\n                const lt = this.targetWeight < 1.0;\r\n                const farDist = lt ? 2.5 * (1.0 / (1.0 - this.targetWeight)) : 1.0e12;\r\n                this.graph = this.categoricalSimplicialSetIntersection(this.graph, Y, farDist);\r\n            }\r\n            // TODO (andycoenen@): add non-categorical supervised embeddings.\r\n        }\r\n    }\r\n    /**\r\n     * Manually step through the optimization process one epoch at a time.\r\n     */\r\n    step() {\r\n        const { currentEpoch } = this.optimizationState;\r\n        if (currentEpoch < this.getNEpochs()) {\r\n            this.optimizeLayoutStep(currentEpoch);\r\n        }\r\n        return this.optimizationState.currentEpoch;\r\n    }\r\n    /**\r\n     * Returns the computed projected embedding.\r\n     */\r\n    getEmbedding() {\r\n        return this.embedding;\r\n    }\r\n    /**\r\n     * Compute the ``nNeighbors`` nearest points for each data point in ``X``\r\n     * This may be exact, but more likely is approximated via nearest neighbor\r\n     * descent.\r\n     */\r\n    nearestNeighbors(X) {\r\n        const { distanceFn, nNeighbors } = this;\r\n        const log2 = (n) => Math.log(n) / Math.log(2);\r\n        const metricNNDescent = nnDescent.makeNNDescent(distanceFn, this.random);\r\n        // Handle python3 rounding down from 0.5 discrpancy\r\n        const round = (n) => {\r\n            return n === 0.5 ? 0 : Math.round(n);\r\n        };\r\n        const nTrees = 5 + Math.floor(round(Math.pow(X.length, 0.5) / 20.0));\r\n        const nIters = Math.max(5, Math.floor(Math.round(log2(X.length))));\r\n        this.rpForest = tree.makeForest(X, nNeighbors, nTrees, this.random);\r\n        const leafArray = tree.makeLeafArray(this.rpForest);\r\n        const { indices, weights } = metricNNDescent(X, leafArray, nNeighbors, nIters);\r\n        return { knnIndices: indices, knnDistances: weights };\r\n    }\r\n    /**\r\n     * Given a set of data X, a neighborhood size, and a measure of distance\r\n     * compute the fuzzy simplicial set (here represented as a fuzzy graph in\r\n     * the form of a sparse matrix) associated to the data. This is done by\r\n     * locally approximating geodesic distance at each point, creating a fuzzy\r\n     * simplicial set for each such point, and then combining all the local\r\n     * fuzzy simplicial sets into a global one via a fuzzy union.\r\n     */\r\n    fuzzySimplicialSet(X, nNeighbors, setOpMixRatio = 1.0) {\r\n        const { knnIndices = [], knnDistances = [], localConnectivity } = this;\r\n        const { sigmas, rhos } = this.smoothKNNDistance(knnDistances, nNeighbors, localConnectivity);\r\n        const { rows, cols, vals } = this.computeMembershipStrengths(knnIndices, knnDistances, sigmas, rhos);\r\n        const size = [X.length, X.length];\r\n        const sparseMatrix = new matrix.SparseMatrix(rows, cols, vals, size);\r\n        const transpose = matrix.transpose(sparseMatrix);\r\n        const prodMatrix = matrix.pairwiseMultiply(sparseMatrix, transpose);\r\n        const a = matrix.subtract(matrix.add(sparseMatrix, transpose), prodMatrix);\r\n        const b = matrix.multiplyScalar(a, setOpMixRatio);\r\n        const c = matrix.multiplyScalar(prodMatrix, 1.0 - setOpMixRatio);\r\n        const result = matrix.add(b, c);\r\n        return result;\r\n    }\r\n    /**\r\n     * Combine a fuzzy simplicial set with another fuzzy simplicial set\r\n     * generated from categorical data using categorical distances. The target\r\n     * data is assumed to be categorical label data (a vector of labels),\r\n     * and this will update the fuzzy simplicial set to respect that label data.\r\n     */\r\n    categoricalSimplicialSetIntersection(simplicialSet, target, farDist, unknownDist = 1.0) {\r\n        let intersection = fastIntersection(simplicialSet, target, unknownDist, farDist);\r\n        intersection = matrix.eliminateZeros(intersection);\r\n        return resetLocalConnectivity(intersection);\r\n    }\r\n    /**\r\n     * Compute a continuous version of the distance to the kth nearest\r\n     * neighbor. That is, this is similar to knn-distance but allows continuous\r\n     * k values rather than requiring an integral k. In esscence we are simply\r\n     * computing the distance such that the cardinality of fuzzy set we generate\r\n     * is k.\r\n     */\r\n    smoothKNNDistance(distances, k, localConnectivity = 1.0, nIter = 64, bandwidth = 1.0) {\r\n        const target = (Math.log(k) / Math.log(2)) * bandwidth;\r\n        const rho = utils.zeros(distances.length);\r\n        const result = utils.zeros(distances.length);\r\n        for (let i = 0; i < distances.length; i++) {\r\n            let lo = 0.0;\r\n            let hi = Infinity;\r\n            let mid = 1.0;\r\n            // TODO: This is very inefficient, but will do for now. FIXME\r\n            const ithDistances = distances[i];\r\n            const nonZeroDists = ithDistances.filter(d => d > 0.0);\r\n            if (nonZeroDists.length >= localConnectivity) {\r\n                let index = Math.floor(localConnectivity);\r\n                let interpolation = localConnectivity - index;\r\n                if (index > 0) {\r\n                    rho[i] = nonZeroDists[index - 1];\r\n                    if (interpolation > SMOOTH_K_TOLERANCE) {\r\n                        rho[i] +=\r\n                            interpolation * (nonZeroDists[index] - nonZeroDists[index - 1]);\r\n                    }\r\n                }\r\n                else {\r\n                    rho[i] = interpolation * nonZeroDists[0];\r\n                }\r\n            }\r\n            else if (nonZeroDists.length > 0) {\r\n                rho[i] = utils.max(nonZeroDists);\r\n            }\r\n            for (let n = 0; n < nIter; n++) {\r\n                let psum = 0.0;\r\n                for (let j = 1; j < distances[i].length; j++) {\r\n                    const d = distances[i][j] - rho[i];\r\n                    if (d > 0) {\r\n                        psum += Math.exp(-(d / mid));\r\n                    }\r\n                    else {\r\n                        psum += 1.0;\r\n                    }\r\n                }\r\n                if (Math.abs(psum - target) < SMOOTH_K_TOLERANCE) {\r\n                    break;\r\n                }\r\n                if (psum > target) {\r\n                    hi = mid;\r\n                    mid = (lo + hi) / 2.0;\r\n                }\r\n                else {\r\n                    lo = mid;\r\n                    if (hi === Infinity) {\r\n                        mid *= 2;\r\n                    }\r\n                    else {\r\n                        mid = (lo + hi) / 2.0;\r\n                    }\r\n                }\r\n            }\r\n            result[i] = mid;\r\n            // TODO: This is very inefficient, but will do for now. FIXME\r\n            if (rho[i] > 0.0) {\r\n                const meanIthDistances = utils.mean(ithDistances);\r\n                if (result[i] < MIN_K_DIST_SCALE * meanIthDistances) {\r\n                    result[i] = MIN_K_DIST_SCALE * meanIthDistances;\r\n                }\r\n            }\r\n            else {\r\n                const meanDistances = utils.mean(distances.map(utils.mean));\r\n                if (result[i] < MIN_K_DIST_SCALE * meanDistances) {\r\n                    result[i] = MIN_K_DIST_SCALE * meanDistances;\r\n                }\r\n            }\r\n        }\r\n        return { sigmas: result, rhos: rho };\r\n    }\r\n    /**\r\n     * Construct the membership strength data for the 1-skeleton of each local\r\n     * fuzzy simplicial set -- this is formed as a sparse matrix where each row is\r\n     * a local fuzzy simplicial set, with a membership strength for the\r\n     * 1-simplex to each other data point.\r\n     */\r\n    computeMembershipStrengths(knnIndices, knnDistances, sigmas, rhos) {\r\n        const nSamples = knnIndices.length;\r\n        const nNeighbors = knnIndices[0].length;\r\n        const rows = utils.zeros(nSamples * nNeighbors);\r\n        const cols = utils.zeros(nSamples * nNeighbors);\r\n        const vals = utils.zeros(nSamples * nNeighbors);\r\n        for (let i = 0; i < nSamples; i++) {\r\n            for (let j = 0; j < nNeighbors; j++) {\r\n                let val = 0;\r\n                if (knnIndices[i][j] === -1) {\r\n                    continue; // We didn't get the full knn for i\r\n                }\r\n                if (knnIndices[i][j] === i) {\r\n                    val = 0.0;\r\n                }\r\n                else if (knnDistances[i][j] - rhos[i] <= 0.0) {\r\n                    val = 1.0;\r\n                }\r\n                else {\r\n                    val = Math.exp(-((knnDistances[i][j] - rhos[i]) / sigmas[i]));\r\n                }\r\n                rows[i * nNeighbors + j] = i;\r\n                cols[i * nNeighbors + j] = knnIndices[i][j];\r\n                vals[i * nNeighbors + j] = val;\r\n            }\r\n        }\r\n        return { rows, cols, vals };\r\n    }\r\n    /**\r\n     * Initialize a fuzzy simplicial set embedding, using a specified\r\n     * initialisation method and then minimizing the fuzzy set cross entropy\r\n     * between the 1-skeletons of the high and low dimensional fuzzy simplicial\r\n     * sets.\r\n     */\r\n    initializeSimplicialSetEmbedding(initialEmbedding) {\r\n        const nEpochs = this.getNEpochs();\r\n        const { nComponents } = this;\r\n        const graphValues = this.graph.getValues();\r\n        let graphMax = 0;\r\n        for (let i = 0; i < graphValues.length; i++) {\r\n            const value = graphValues[i];\r\n            if (graphMax < graphValues[i]) {\r\n                graphMax = value;\r\n            }\r\n        }\r\n        const graph = this.graph.map(value => {\r\n            if (value < graphMax / nEpochs) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return value;\r\n            }\r\n        });\r\n        // We're not computing the spectral initialization in this implementation\r\n        // until we determine a better eigenvalue/eigenvector computation\r\n        // approach\r\n        if (initialEmbedding) {\r\n            this.embedding = initialEmbedding;\r\n        }\r\n        else {\r\n            this.embedding = utils.zeros(graph.nRows).map(() => {\r\n                return utils.zeros(nComponents).map(() => {\r\n                    return utils.tauRand(this.random) * 20 + -10; // Random from -10 to 10\r\n                });\r\n            });\r\n        }\r\n        // Get graph data in ordered way...\r\n        const weights = [];\r\n        const head = [];\r\n        const tail = [];\r\n        const rowColValues = graph.getAll();\r\n        for (let i = 0; i < rowColValues.length; i++) {\r\n            const entry = rowColValues[i];\r\n            if (entry.value) {\r\n                weights.push(entry.value);\r\n                tail.push(entry.row);\r\n                head.push(entry.col);\r\n            }\r\n        }\r\n        const epochsPerSample = this.makeEpochsPerSample(weights, nEpochs);\r\n        return { head, tail, epochsPerSample };\r\n    }\r\n    /**\r\n     * Given a set of weights and number of epochs generate the number of\r\n     * epochs per sample for each weight.\r\n     */\r\n    makeEpochsPerSample(weights, nEpochs) {\r\n        const result = utils.filled(weights.length, -1.0);\r\n        const max = utils.max(weights);\r\n        const nSamples = weights.map(w => (w / max) * nEpochs);\r\n        nSamples.forEach((n, i) => {\r\n            if (n > 0)\r\n                result[i] = nEpochs / nSamples[i];\r\n        });\r\n        return result;\r\n    }\r\n    /**\r\n     * Assigns optimization state parameters from a partial optimization state.\r\n     */\r\n    assignOptimizationStateParameters(state) {\r\n        Object.assign(this.optimizationState, state);\r\n    }\r\n    /**\r\n     * Sets a few optimization state parameters that are necessary before entering\r\n     * the optimization step loop.\r\n     */\r\n    prepareForOptimizationLoop() {\r\n        // Hyperparameters\r\n        const { repulsionStrength, learningRate, negativeSampleRate } = this;\r\n        const { epochsPerSample, headEmbedding, tailEmbedding, } = this.optimizationState;\r\n        const dim = headEmbedding[0].length;\r\n        const moveOther = headEmbedding.length === tailEmbedding.length;\r\n        const epochsPerNegativeSample = epochsPerSample.map(e => e / negativeSampleRate);\r\n        const epochOfNextNegativeSample = [...epochsPerNegativeSample];\r\n        const epochOfNextSample = [...epochsPerSample];\r\n        this.assignOptimizationStateParameters({\r\n            epochOfNextSample,\r\n            epochOfNextNegativeSample,\r\n            epochsPerNegativeSample,\r\n            moveOther,\r\n            initialAlpha: learningRate,\r\n            alpha: learningRate,\r\n            gamma: repulsionStrength,\r\n            dim,\r\n        });\r\n    }\r\n    /**\r\n     * Initializes optimization state for stepwise optimization.\r\n     */\r\n    initializeOptimization() {\r\n        // Algorithm state\r\n        const headEmbedding = this.embedding;\r\n        const tailEmbedding = this.embedding;\r\n        // Initialized in initializeSimplicialSetEmbedding()\r\n        const { head, tail, epochsPerSample } = this.optimizationState;\r\n        const nEpochs = this.getNEpochs();\r\n        const nVertices = this.graph.nCols;\r\n        const { a, b } = findABParams(this.spread, this.minDist);\r\n        this.assignOptimizationStateParameters({\r\n            headEmbedding,\r\n            tailEmbedding,\r\n            head,\r\n            tail,\r\n            epochsPerSample,\r\n            a,\r\n            b,\r\n            nEpochs,\r\n            nVertices,\r\n        });\r\n    }\r\n    /**\r\n     * Improve an embedding using stochastic gradient descent to minimize the\r\n     * fuzzy set cross entropy between the 1-skeletons of the high dimensional\r\n     * and low dimensional fuzzy simplicial sets. In practice this is done by\r\n     * sampling edges based on their membership strength (with the (1-p) terms\r\n     * coming from negative sampling similar to word2vec).\r\n     */\r\n    optimizeLayoutStep(n) {\r\n        const { optimizationState } = this;\r\n        const { head, tail, headEmbedding, tailEmbedding, epochsPerSample, epochOfNextSample, epochOfNextNegativeSample, epochsPerNegativeSample, moveOther, initialAlpha, alpha, gamma, a, b, dim, nEpochs, nVertices, } = optimizationState;\r\n        const clipValue = 4.0;\r\n        for (let i = 0; i < epochsPerSample.length; i++) {\r\n            if (epochOfNextSample[i] > n) {\r\n                continue;\r\n            }\r\n            const j = head[i];\r\n            const k = tail[i];\r\n            const current = headEmbedding[j];\r\n            const other = tailEmbedding[k];\r\n            const distSquared = rDist(current, other);\r\n            let gradCoeff = 0;\r\n            if (distSquared > 0) {\r\n                gradCoeff = -2.0 * a * b * Math.pow(distSquared, b - 1.0);\r\n                gradCoeff /= a * Math.pow(distSquared, b) + 1.0;\r\n            }\r\n            for (let d = 0; d < dim; d++) {\r\n                const gradD = clip(gradCoeff * (current[d] - other[d]), clipValue);\r\n                current[d] += gradD * alpha;\r\n                if (moveOther) {\r\n                    other[d] += -gradD * alpha;\r\n                }\r\n            }\r\n            epochOfNextSample[i] += epochsPerSample[i];\r\n            const nNegSamples = Math.floor((n - epochOfNextNegativeSample[i]) / epochsPerNegativeSample[i]);\r\n            for (let p = 0; p < nNegSamples; p++) {\r\n                const k = utils.tauRandInt(nVertices, this.random);\r\n                const other = tailEmbedding[k];\r\n                const distSquared = rDist(current, other);\r\n                let gradCoeff = 0.0;\r\n                if (distSquared > 0.0) {\r\n                    gradCoeff = 2.0 * gamma * b;\r\n                    gradCoeff /=\r\n                        (0.001 + distSquared) * (a * Math.pow(distSquared, b) + 1);\r\n                }\r\n                else if (j === k) {\r\n                    continue;\r\n                }\r\n                for (let d = 0; d < dim; d++) {\r\n                    let gradD = 4.0;\r\n                    if (gradCoeff > 0.0) {\r\n                        gradD = clip(gradCoeff * (current[d] - other[d]), clipValue);\r\n                    }\r\n                    current[d] += gradD * alpha;\r\n                }\r\n            }\r\n            epochOfNextNegativeSample[i] += nNegSamples * epochsPerNegativeSample[i];\r\n        }\r\n        optimizationState.alpha = initialAlpha * (1.0 - n / nEpochs);\r\n        optimizationState.currentEpoch += 1;\r\n        return headEmbedding;\r\n    }\r\n    /**\r\n     * Improve an embedding using stochastic gradient descent to minimize the\r\n     * fuzzy set cross entropy between the 1-skeletons of the high dimensional\r\n     * and low dimensional fuzzy simplicial sets. In practice this is done by\r\n     * sampling edges based on their membership strength (with the (1-p) terms\r\n     * coming from negative sampling similar to word2vec).\r\n     */\r\n    optimizeLayoutAsync(epochCallback = () => true) {\r\n        return new Promise((resolve, reject) => {\r\n            const step = () => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    const { nEpochs, currentEpoch } = this.optimizationState;\r\n                    this.embedding = this.optimizeLayoutStep(currentEpoch);\r\n                    const epochCompleted = this.optimizationState.currentEpoch;\r\n                    const shouldStop = epochCallback(epochCompleted) === false;\r\n                    const isFinished = epochCompleted === nEpochs;\r\n                    if (!shouldStop && !isFinished) {\r\n                        setTimeout(() => step(), 0);\r\n                    }\r\n                    else {\r\n                        return resolve(isFinished);\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    reject(err);\r\n                }\r\n            });\r\n            setTimeout(() => step(), 0);\r\n        });\r\n    }\r\n    /**\r\n     * Improve an embedding using stochastic gradient descent to minimize the\r\n     * fuzzy set cross entropy between the 1-skeletons of the high dimensional\r\n     * and low dimensional fuzzy simplicial sets. In practice this is done by\r\n     * sampling edges based on their membership strength (with the (1-p) terms\r\n     * coming from negative sampling similar to word2vec).\r\n     */\r\n    optimizeLayout(epochCallback = () => true) {\r\n        let isFinished = false;\r\n        let embedding = [];\r\n        while (!isFinished) {\r\n            const { nEpochs, currentEpoch } = this.optimizationState;\r\n            embedding = this.optimizeLayoutStep(currentEpoch);\r\n            const epochCompleted = this.optimizationState.currentEpoch;\r\n            const shouldStop = epochCallback(epochCompleted) === false;\r\n            isFinished = epochCompleted === nEpochs || shouldStop;\r\n        }\r\n        return embedding;\r\n    }\r\n    /**\r\n     * Gets the number of epochs for optimizing the projection.\r\n     * NOTE: This heuristic differs from the python version\r\n     */\r\n    getNEpochs() {\r\n        const graph = this.graph;\r\n        if (this.nEpochs > 0) {\r\n            return this.nEpochs;\r\n        }\r\n        const length = graph.nRows;\r\n        if (length <= 2500) {\r\n            return 500;\r\n        }\r\n        else if (length <= 5000) {\r\n            return 400;\r\n        }\r\n        else if (length <= 7500) {\r\n            return 300;\r\n        }\r\n        else {\r\n            return 200;\r\n        }\r\n    }\r\n}\r\nexports.UMAP = UMAP;\r\nfunction euclidean(x, y) {\r\n    let result = 0;\r\n    for (let i = 0; i < x.length; i++) {\r\n        result += Math.pow((x[i] - y[i]), 2);\r\n    }\r\n    return Math.sqrt(result);\r\n}\r\nexports.euclidean = euclidean;\r\nfunction cosine(x, y) {\r\n    let result = 0.0;\r\n    let normX = 0.0;\r\n    let normY = 0.0;\r\n    for (let i = 0; i < x.length; i++) {\r\n        result += x[i] * y[i];\r\n        normX += Math.pow(x[i], 2);\r\n        normY += Math.pow(y[i], 2);\r\n    }\r\n    if (normX === 0 && normY === 0) {\r\n        return 0;\r\n    }\r\n    else if (normX === 0 || normY === 0) {\r\n        return 1.0;\r\n    }\r\n    else {\r\n        return 1.0 - result / Math.sqrt(normX * normY);\r\n    }\r\n}\r\nexports.cosine = cosine;\r\n/**\r\n * An interface representing the optimization state tracked between steps of\r\n * the SGD optimization\r\n */\r\nclass OptimizationState {\r\n    constructor() {\r\n        this.currentEpoch = 0;\r\n        // Data tracked during optimization steps.\r\n        this.headEmbedding = [];\r\n        this.tailEmbedding = [];\r\n        this.head = [];\r\n        this.tail = [];\r\n        this.epochsPerSample = [];\r\n        this.epochOfNextSample = [];\r\n        this.epochOfNextNegativeSample = [];\r\n        this.epochsPerNegativeSample = [];\r\n        this.moveOther = true;\r\n        this.initialAlpha = 1.0;\r\n        this.alpha = 1.0;\r\n        this.gamma = 1.0;\r\n        this.a = 1.5769434603113077;\r\n        this.b = 0.8950608779109733;\r\n        this.dim = 2;\r\n        this.nEpochs = 500;\r\n        this.nVertices = 0;\r\n    }\r\n}\r\n/**\r\n * Standard clamping of a value into a fixed range\r\n */\r\nfunction clip(x, clipValue) {\r\n    if (x > clipValue)\r\n        return clipValue;\r\n    else if (x < -clipValue)\r\n        return -clipValue;\r\n    else\r\n        return x;\r\n}\r\n/**\r\n * Reduced Euclidean distance.\r\n */\r\nfunction rDist(x, y) {\r\n    let result = 0.0;\r\n    for (let i = 0; i < x.length; i++) {\r\n        result += Math.pow(x[i] - y[i], 2);\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Fit a, b params for the differentiable curve used in lower\r\n * dimensional fuzzy simplicial complex construction. We want the\r\n * smooth curve (from a pre-defined family with simple gradient) that\r\n * best matches an offset exponential decay.\r\n */\r\nfunction findABParams(spread, minDist) {\r\n    const curve = ([a, b]) => (x) => {\r\n        return 1.0 / (1.0 + a * Math.pow(x, (2 * b)));\r\n    };\r\n    const xv = utils\r\n        .linear(0, spread * 3, 300)\r\n        .map(val => (val < minDist ? 1.0 : val));\r\n    const yv = utils.zeros(xv.length).map((val, index) => {\r\n        const gte = xv[index] >= minDist;\r\n        return gte ? Math.exp(-(xv[index] - minDist) / spread) : val;\r\n    });\r\n    const initialValues = [0.5, 0.5];\r\n    const data = { x: xv, y: yv };\r\n    // Default options for the algorithm (from github example)\r\n    const options = {\r\n        damping: 1.5,\r\n        initialValues,\r\n        gradientDifference: 10e-2,\r\n        maxIterations: 100,\r\n        errorTolerance: 10e-3,\r\n    };\r\n    const { parameterValues } = ml_levenberg_marquardt_1.default(data, curve, options);\r\n    const [a, b] = parameterValues;\r\n    return { a, b };\r\n}\r\nexports.findABParams = findABParams;\r\n/**\r\n * Under the assumption of categorical distance for the intersecting\r\n * simplicial set perform a fast intersection.\r\n */\r\nfunction fastIntersection(graph, target, unknownDist = 1.0, farDist = 5.0) {\r\n    return graph.map((value, row, col) => {\r\n        if (target[row] === -1 || target[col] === -1) {\r\n            return value * Math.exp(-unknownDist);\r\n        }\r\n        else if (target[row] !== target[col]) {\r\n            return value * Math.exp(-farDist);\r\n        }\r\n        else {\r\n            return value;\r\n        }\r\n    });\r\n}\r\nexports.fastIntersection = fastIntersection;\r\n/**\r\n * Reset the local connectivity requirement -- each data sample should\r\n * have complete confidence in at least one 1-simplex in the simplicial set.\r\n * We can enforce this by locally rescaling confidences, and then remerging the\r\n * different local simplicial sets together.\r\n */\r\nfunction resetLocalConnectivity(simplicialSet) {\r\n    simplicialSet = matrix.normalize(simplicialSet, \"max\" /* max */);\r\n    const transpose = matrix.transpose(simplicialSet);\r\n    const prodMatrix = matrix.pairwiseMultiply(transpose, simplicialSet);\r\n    simplicialSet = matrix.add(simplicialSet, matrix.subtract(transpose, prodMatrix));\r\n    return matrix.eliminateZeros(simplicialSet);\r\n}\r\nexports.resetLocalConnectivity = resetLocalConnectivity;\r\n/**\r\n * Given indices and weights and an original embeddings\r\n * initialize the positions of new points relative to the\r\n * indices and weights (of their neighbors in the source data).\r\n */\r\nfunction initTransform(indices, weights, embedding) {\r\n    const result = utils\r\n        .zeros(indices.length)\r\n        .map(z => utils.zeros(embedding[0].length));\r\n    for (let i = 0; i < indices.length; i++) {\r\n        for (let j = 0; j < indices[0].length; j++) {\r\n            for (let d = 0; d < embedding[0].length; d++) {\r\n                const a = indices[i][j];\r\n                result[i][d] += weights[i][j] * embedding[a][d];\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.initTransform = initTransform;\r\n","\"use strict\";\r\n/**\r\n * @license\r\n *\r\n * Copyright 2019 Google LLC. All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ==============================================================================\r\n */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.reshape2d = exports.rejectionSample = exports.max2d = exports.max = exports.mean = exports.sum = exports.linear = exports.ones = exports.zeros = exports.filled = exports.range = exports.empty = exports.norm = exports.tauRand = exports.tauRandInt = void 0;\r\n/**\r\n * Simple random integer function\r\n */\r\nfunction tauRandInt(n, random) {\r\n    return Math.floor(random() * n);\r\n}\r\nexports.tauRandInt = tauRandInt;\r\n/**\r\n * Simple random float function\r\n */\r\nfunction tauRand(random) {\r\n    return random();\r\n}\r\nexports.tauRand = tauRand;\r\n/**\r\n * Compute the (standard l2) norm of a vector.\r\n */\r\nfunction norm(vec) {\r\n    let result = 0;\r\n    for (let item of vec) {\r\n        result += Math.pow(item, 2);\r\n    }\r\n    return Math.sqrt(result);\r\n}\r\nexports.norm = norm;\r\n/**\r\n * Creates an empty array (filled with undefined)\r\n */\r\nfunction empty(n) {\r\n    const output = [];\r\n    for (let i = 0; i < n; i++) {\r\n        output.push(undefined);\r\n    }\r\n    return output;\r\n}\r\nexports.empty = empty;\r\n/**\r\n * Creates an array filled with index values\r\n */\r\nfunction range(n) {\r\n    return empty(n).map((_, i) => i);\r\n}\r\nexports.range = range;\r\n/**\r\n * Creates an array filled with a specific value\r\n */\r\nfunction filled(n, v) {\r\n    return empty(n).map(() => v);\r\n}\r\nexports.filled = filled;\r\n/**\r\n * Creates an array filled with zeros\r\n */\r\nfunction zeros(n) {\r\n    return filled(n, 0);\r\n}\r\nexports.zeros = zeros;\r\n/**\r\n * Creates an array filled with ones\r\n */\r\nfunction ones(n) {\r\n    return filled(n, 1);\r\n}\r\nexports.ones = ones;\r\n/**\r\n * Creates an array from a to b, of length len, inclusive\r\n */\r\nfunction linear(a, b, len) {\r\n    return empty(len).map((_, i) => {\r\n        return a + i * ((b - a) / (len - 1));\r\n    });\r\n}\r\nexports.linear = linear;\r\n/**\r\n * Returns the sum of an array\r\n */\r\nfunction sum(input) {\r\n    return input.reduce((sum, val) => sum + val);\r\n}\r\nexports.sum = sum;\r\n/**\r\n * Returns the mean of an array\r\n */\r\nfunction mean(input) {\r\n    return sum(input) / input.length;\r\n}\r\nexports.mean = mean;\r\n/**\r\n * Returns the maximum value of an array\r\n */\r\nfunction max(input) {\r\n    let max = 0;\r\n    for (let i = 0; i < input.length; i++) {\r\n        max = input[i] > max ? input[i] : max;\r\n    }\r\n    return max;\r\n}\r\nexports.max = max;\r\n/**\r\n * Returns the maximum value of a 2d array\r\n */\r\nfunction max2d(input) {\r\n    let max = 0;\r\n    for (let i = 0; i < input.length; i++) {\r\n        for (let j = 0; j < input[i].length; j++) {\r\n            max = input[i][j] > max ? input[i][j] : max;\r\n        }\r\n    }\r\n    return max;\r\n}\r\nexports.max2d = max2d;\r\n/**\r\n * Generate nSamples many integers from 0 to poolSize such that no\r\n * integer is selected twice. The duplication constraint is achieved via\r\n * rejection sampling.\r\n */\r\nfunction rejectionSample(nSamples, poolSize, random) {\r\n    const result = zeros(nSamples);\r\n    for (let i = 0; i < nSamples; i++) {\r\n        let rejectSample = true;\r\n        while (rejectSample) {\r\n            const j = tauRandInt(poolSize, random);\r\n            let broken = false;\r\n            for (let k = 0; k < i; k++) {\r\n                if (j === result[k]) {\r\n                    broken = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!broken) {\r\n                rejectSample = false;\r\n            }\r\n            result[i] = j;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nexports.rejectionSample = rejectionSample;\r\n/**\r\n * Reshapes a 1d array into a 2D of given dimensions.\r\n */\r\nfunction reshape2d(x, a, b) {\r\n    const rows = [];\r\n    let count = 0;\r\n    let index = 0;\r\n    if (x.length !== a * b) {\r\n        throw new Error('Array dimensions must match input length.');\r\n    }\r\n    for (let i = 0; i < a; i++) {\r\n        const col = [];\r\n        for (let j = 0; j < b; j++) {\r\n            col.push(x[index]);\r\n            index += 1;\r\n        }\r\n        rows.push(col);\r\n        count += 1;\r\n    }\r\n    return rows;\r\n}\r\nexports.reshape2d = reshape2d;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst UMAP_1 = require(\"../../Utility/UMAP\");\r\nrequire(\"regenerator-runtime/runtime\");\r\n/**\r\n * Worker thread that computes a stepwise projection\r\n */\r\nself.addEventListener('message', function (e) {\r\n    let context = self;\r\n    if (e.data.messageType == 'init') {\r\n        context.raw = e.data;\r\n        context.umap = new UMAP_1.UMAP({\r\n            nNeighbors: e.data.params.nNeighbors\r\n        });\r\n        context.umap.initializeFit(e.data.input, e.data.params.seeded ? e.data.seed : undefined);\r\n        context.umap.step();\r\n        context.postMessage(context.umap.getEmbedding());\r\n    }\r\n    else {\r\n        context.umap.step();\r\n        context.postMessage(context.umap.getEmbedding());\r\n    }\r\n}, false);\r\n"],"sourceRoot":""}